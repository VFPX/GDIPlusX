#INCLUDE System.Drawing.h

LPARAMETER toObject

IF VARTYPE(m.toObject) = "O"
	ADDPROPERTY(m.toObject,"Drawing",CREATEOBJECT("xfcDrawing"))
ENDIF

*************************************************************************
*************************************************************************
*************************************************************************
DEFINE CLASS xfcDrawing AS xfcNamespace OF System.PRG
*************************************************************************
*************************************************************************
*************************************************************************
	CharacterRange = .NULL.
	Color = .NULL.
	ColorTranslator = .NULL.
	Font = .NULL.
	FontFamily = .NULL.
	FontStyle = .NULL.	&& Specifies style information applied to text.
	Graphics = .NULL.
	GraphicsUnit = 0
	HatchBrush = .NULL.
	Icon = .NULL.
	Image = .NULL.
	ImageAnimator = .NULL.
	KnownColor = .NULL.	&& Specifies the known system colors.
	Pen = .NULL.
	Pens = .NULL.
	Point = .NULL.	
	PointF = .NULL.
	Rectangle = .NULL.
	RectangleF = .NULL.
	Region = .NULL.
	RotateFlipType = 0
	Size = .NULL.
	SizeF = .NULL.
	SolidBrush = .NULL.
	StringAlignment = .NULL.	&& Specifies the alignment of a text string relative to its layout rectangle.
	StringDigitSubstitute = .NULL. && The StringDigitSubstitute enumeration specifies how to substitute digits in a string according to a user's locale or language.
	StringFormat = .NULL.
	StringFormatFlags = .NULL. && Specifies the display and layout information for text strings.
	StringTrimming = .NULL.	&& Specifies how to trim characters from a string that does not completely fit into a layout shape.
	SystemBrushes = .NULL.
	SystemColors = .NULL.
	SystemIcons = .NULL.
	SystemPens = .NULL.
	TextureBrush = .NULL.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Initialize the GDI Plus library
		SET PROCEDURE TO (This.ClassLibrary) ADDITIVE
		IF VARTYPE(_SCREEN.GDIPToken) <> "O"
			ADDPROPERTY(_SCREEN, "GDIPToken", CREATEOBJECT("xfcGDIPToken"))
		ENDIF
	ENDFUNC

	*********************************************************************
	Drawing2D = .NULL.
	*********************************************************************
	FUNCTION Drawing2D_ACCESS
	*********************************************************************
		IF VARTYPE(This.Drawing2D) <> "O"
			DO (ADDBS(JUSTPATH(This.ClassLibrary))+"System.Drawing.Drawing2D.PRG") WITH This
		ENDIF
		
		RETURN THIS.Drawing2D
	ENDFUNC

	*********************************************************************
	Imaging = .NULL.
	*********************************************************************
	FUNCTION Imaging_ACCESS
	*********************************************************************
		IF VARTYPE(This.Imaging) <> "O"
			DO (ADDBS(JUSTPATH(This.ClassLibrary))+"System.Drawing.Imaging.PRG") WITH This
		ENDIF
		
		RETURN THIS.Imaging
	ENDFUNC

	*********************************************************************
	Text = .NULL.
	*********************************************************************
	FUNCTION Text_ACCESS
	*********************************************************************
		IF VARTYPE(This.Text) <> "O"
			DO (ADDBS(JUSTPATH(This.ClassLibrary))+"System.Drawing.Text.PRG") WITH This
		ENDIF
		
		RETURN THIS.Text
	ENDFUNC



	#IFDEF USECLASS_XFCBITMAP
	*********************************************************************
	Bitmap = .NULL.
	*********************************************************************
	FUNCTION Bitmap_ACCESS
	*********************************************************************
		IF VARTYPE(This.Bitmap) <> "O"
			This.Bitmap = CREATEOBJECT("xfcBitmap")
		ENDIF
		RETURN THIS.Bitmap
	ENDFUNC
	#ENDIF


	#IFDEF USECLASS_XFCBRUSHES
	*********************************************************************
	Brushes = .NULL.
	*********************************************************************
	FUNCTION Brushes_ACCESS
	*********************************************************************
		IF VARTYPE(This.Brushes) <> "O"
			This.Brushes = CREATEOBJECT("xfcBrushes")
		ENDIF
		RETURN THIS.Brushes
	ENDFUNC
	#ENDIF


	*********************************************************************
	FUNCTION CharacterRange_ACCESS
	*********************************************************************
		IF VARTYPE(This.CharacterRange) <> "O"
			This.CharacterRange = CREATEOBJECT("xfcCharacterRange")
		ENDIF
		
		RETURN THIS.CharacterRange
	ENDFUNC


	*********************************************************************
	FUNCTION ColorTranslator_ACCESS
	*********************************************************************
		IF VARTYPE(This.ColorTranslator) <> "O"
			This.ColorTranslator = CREATEOBJECT("xfcColorTranslator")
		ENDIF
		
		RETURN THIS.ColorTranslator
	ENDFUNC


	*********************************************************************
	FUNCTION Color_ACCESS
	*********************************************************************
	** 2006/08/26: BDurban - Changed to use "ColorS" class
		
		IF VARTYPE(This.Color) <> "O"
			This.Color = CREATEOBJECT("xfcColors")
		ENDIF
		
		RETURN THIS.Color
	ENDFUNC


	*********************************************************************
	FUNCTION FontFamily_ACCESS
	*********************************************************************
		IF VARTYPE(This.FontFamily) <> "O"
			This.FontFamily = CREATEOBJECT("xfcFontFamily",NULL)
		ENDIF
		
		RETURN THIS.FontFamily
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION FontStyle_ACCESS
	*********************************************************************
	** Enumeration: FontStyle (Access)
	**
	** Specifies style information applied to text.
	**
	** History:
	**  2006/06/11: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontStyle%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this method
		
		IF VARTYPE(This.FontStyle) <> "O"
			This.FontStyle = NEWOBJECT(ENUM_BASECLASS,XFCCLASS_SYSTEM)
			ADDPROPERTY(This.FontStyle, "Regular", FontStyleRegular)
			ADDPROPERTY(This.FontStyle, "Bold", FontStyleBold)
			ADDPROPERTY(This.FontStyle, "Italic", FontStyleItalic)
			ADDPROPERTY(This.FontStyle, "BoldItalic", FontStyleBoldItalic)
			ADDPROPERTY(This.FontStyle, "Underline", FontStyleUnderline)
			ADDPROPERTY(This.FontStyle, "Strikeout", FontStyleStrikeout)
			ADDPROPERTY(This.FontStyle, "NotFound", FontStyleNotFound)
		#IFDEF USE_MEMBERDATA
			ADDPROPERTY(This.FontStyle, "_memberdata", [<VFPData>]+;
						[<memberdata name="regular" display="Regular"/>]+;
						[<memberdata name="bold" display="Bold"/>]+;
						[<memberdata name="italic" display="Italic"/>]+;
						[<memberdata name="bolditalic" display="BoldItalic"/>]+;
						[<memberdata name="underline" display="Underline"/>]+;
						[<memberdata name="strikeout" display="Strikeout"/>]+;
						[<memberdata name="notfound" display="NotFound"/>]+;
						[</VFPData>])
		#ENDIF
		ENDIF
		
		RETURN This.FontStyle
	ENDFUNC


	*********************************************************************
	FUNCTION Font_ACCESS
	*********************************************************************
		IF VARTYPE(This.Font) <> "O"
			This.Font = CREATEOBJECT("xfcFont", NULL)
		ENDIF
		
		RETURN THIS.Font
	ENDFUNC


	*********************************************************************
	FUNCTION GraphicsUnit_ACCESS
	*********************************************************************
	** Enumeration: StringTrimming (Access)
	**
	** Specifies how to trim characters from a string that does not completely fit into a layout shape.
	**
	** History:
	**  2006/08/15: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringTrimming%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this method
		
		IF VARTYPE(This.GraphicsUnit) <> "O"
			This.GraphicsUnit = NEWOBJECT(ENUM_BASECLASS,XFCCLASS_SYSTEM)
			ADDPROPERTY(This.GraphicsUnit, "Display", UnitDisplay)
			ADDPROPERTY(This.GraphicsUnit, "Document", UnitDocument)
			ADDPROPERTY(This.GraphicsUnit, "Inch", UnitInch)
			ADDPROPERTY(This.GraphicsUnit, "Millimeter", UnitMillimeter)
			ADDPROPERTY(This.GraphicsUnit, "Pixel", UnitPixel)
			ADDPROPERTY(This.GraphicsUnit, "Point", UnitPoint)
			ADDPROPERTY(This.GraphicsUnit, "World", UnitWorld)
		#IFDEF USE_MEMBERDATA
			ADDPROPERTY(This.GraphicsUnit, "_memberdata", [<VFPData>]+;
						[<memberdata name="display" display="Display"/>]+;
						[<memberdata name="document" display="Document"/>]+;
						[<memberdata name="inch" display="Inch"/>]+;
						[<memberdata name="millimeter" display="Millimeter"/>]+;
						[<memberdata name="pixel" display="Pixel"/>]+;
						[<memberdata name="point" display="Point"/>]+;
						[<memberdata name="world" display="World"/>]+;
						[</VFPData>])
		#ENDIF
		ENDIF
		
		RETURN This.GraphicsUnit
	ENDFUNC


	*********************************************************************
	FUNCTION Graphics_ACCESS
	*********************************************************************
		IF VARTYPE(This.Graphics) <> "O"
			This.Graphics = CREATEOBJECT("xfcGraphics")
		ENDIF
		
		RETURN THIS.Graphics
	ENDFUNC


	*********************************************************************
	FUNCTION Icon_ACCESS
	*********************************************************************
		IF VARTYPE(This.Icon) <> "O"
			This.Icon = CREATEOBJECT("xfcIcon")
		ENDIF
		
		RETURN THIS.Icon
	ENDFUNC


	*********************************************************************
	FUNCTION ImageAnimator_ACCESS
	*********************************************************************
		IF VARTYPE(This.ImageAnimator) <> "O"
			This.ImageAnimator = CREATEOBJECT("xfcImageAnimator")
		ENDIF
		
		RETURN THIS.ImageAnimator
	ENDFUNC


	*********************************************************************
	FUNCTION Image_ACCESS
	*********************************************************************
		IF VARTYPE(This.Image) <> "O"
			This.Image = CREATEOBJECT("xfcImage")
		ENDIF
		
		RETURN THIS.Image
	ENDFUNC

	*********************************************************************
	PROTECTED FUNCTION KnownColor_ACCESS
	*********************************************************************
	** Enumeration: KnownColor (Access)
	**
	** Specifies the known system colors.
	**
	** History:
	**  2006/06/11: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.KnownColor%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this method
		
		IF VARTYPE(This.KnownColor) <> "O"
			This.KnownColor = NEWOBJECT(ENUM_BASECLASS,XFCCLASS_SYSTEM)
			ADDPROPERTY(This.KnownColor, "ActiveBorder", KnownColorActiveBorder)
			ADDPROPERTY(This.KnownColor, "ActiveCaption", KnownColorActiveCaption)
			ADDPROPERTY(This.KnownColor, "ActiveCaptionText", KnownColorActiveCaptionText)
			ADDPROPERTY(This.KnownColor, "AppWorkspace", KnownColorAppWorkspace)
			ADDPROPERTY(This.KnownColor, "Control", KnownColorControl)
			ADDPROPERTY(This.KnownColor, "ControlDark", KnownColorControlDark)
			ADDPROPERTY(This.KnownColor, "ControlDarkDark", KnownColorControlDarkDark)
			ADDPROPERTY(This.KnownColor, "ControlLight", KnownColorControlLight)
			ADDPROPERTY(This.KnownColor, "ControlLightLight", KnownColorControlLightLight)
			ADDPROPERTY(This.KnownColor, "ControlText", KnownColorControlText)
			ADDPROPERTY(This.KnownColor, "Desktop", KnownColorDesktop)
			ADDPROPERTY(This.KnownColor, "GrayText", KnownColorGrayText)
			ADDPROPERTY(This.KnownColor, "Highlight", KnownColorHighlight)
			ADDPROPERTY(This.KnownColor, "HighlightText", KnownColorHighlightText)
			ADDPROPERTY(This.KnownColor, "HotTrack", KnownColorHotTrack)
			ADDPROPERTY(This.KnownColor, "InactiveBorder", KnownColorInactiveBorder)
			ADDPROPERTY(This.KnownColor, "InactiveCaption", KnownColorInactiveCaption)
			ADDPROPERTY(This.KnownColor, "InactiveCaptionText", KnownColorInactiveCaptionText)
			ADDPROPERTY(This.KnownColor, "Info", KnownColorInfo)
			ADDPROPERTY(This.KnownColor, "InfoText", KnownColorInfoText)
			ADDPROPERTY(This.KnownColor, "Menu", KnownColorMenu)
			ADDPROPERTY(This.KnownColor, "MenuText", KnownColorMenuText)
			ADDPROPERTY(This.KnownColor, "ScrollBar", KnownColorScrollBar)
			ADDPROPERTY(This.KnownColor, "Window", KnownColorWindow)
			ADDPROPERTY(This.KnownColor, "WindowFrame", KnownColorWindowFrame)
			ADDPROPERTY(This.KnownColor, "WindowText", KnownColorWindowText)
			ADDPROPERTY(This.KnownColor, "Transparent", KnownColorTransparent)
			ADDPROPERTY(This.KnownColor, "AliceBlue", KnownColorAliceBlue)
			ADDPROPERTY(This.KnownColor, "AntiqueWhite", KnownColorAntiqueWhite)
			ADDPROPERTY(This.KnownColor, "Aqua", KnownColorAqua)
			ADDPROPERTY(This.KnownColor, "Aquamarine", KnownColorAquamarine)
			ADDPROPERTY(This.KnownColor, "Azure", KnownColorAzure)
			ADDPROPERTY(This.KnownColor, "Beige", KnownColorBeige)
			ADDPROPERTY(This.KnownColor, "Bisque", KnownColorBisque)
			ADDPROPERTY(This.KnownColor, "Black", KnownColorBlack)
			ADDPROPERTY(This.KnownColor, "BlanchedAlmond", KnownColorBlanchedAlmond)
			ADDPROPERTY(This.KnownColor, "Blue", KnownColorBlue)
			ADDPROPERTY(This.KnownColor, "BlueViolet", KnownColorBlueViolet)
			ADDPROPERTY(This.KnownColor, "Brown", KnownColorBrown)
			ADDPROPERTY(This.KnownColor, "BurlyWood", KnownColorBurlyWood)
			ADDPROPERTY(This.KnownColor, "CadetBlue", KnownColorCadetBlue)
			ADDPROPERTY(This.KnownColor, "Chartreuse", KnownColorChartreuse)
			ADDPROPERTY(This.KnownColor, "Chocolate", KnownColorChocolate)
			ADDPROPERTY(This.KnownColor, "Coral", KnownColorCoral)
			ADDPROPERTY(This.KnownColor, "CornflowerBlue", KnownColorCornflowerBlue)
			ADDPROPERTY(This.KnownColor, "Cornsilk", KnownColorCornsilk)
			ADDPROPERTY(This.KnownColor, "Crimson", KnownColorCrimson)
			ADDPROPERTY(This.KnownColor, "Cyan", KnownColorCyan)
			ADDPROPERTY(This.KnownColor, "DarkBlue", KnownColorDarkBlue)
			ADDPROPERTY(This.KnownColor, "DarkCyan", KnownColorDarkCyan)
			ADDPROPERTY(This.KnownColor, "DarkGoldenrod", KnownColorDarkGoldenrod)
			ADDPROPERTY(This.KnownColor, "DarkGray", KnownColorDarkGray)
			ADDPROPERTY(This.KnownColor, "DarkGreen", KnownColorDarkGreen)
			ADDPROPERTY(This.KnownColor, "DarkKhaki", KnownColorDarkKhaki)
			ADDPROPERTY(This.KnownColor, "DarkMagenta", KnownColorDarkMagenta)
			ADDPROPERTY(This.KnownColor, "DarkOliveGreen", KnownColorDarkOliveGreen)
			ADDPROPERTY(This.KnownColor, "DarkOrange", KnownColorDarkOrange)
			ADDPROPERTY(This.KnownColor, "DarkOrchid", KnownColorDarkOrchid)
			ADDPROPERTY(This.KnownColor, "DarkRed", KnownColorDarkRed)
			ADDPROPERTY(This.KnownColor, "DarkSalmon", KnownColorDarkSalmon)
			ADDPROPERTY(This.KnownColor, "DarkSeaGreen", KnownColorDarkSeaGreen)
			ADDPROPERTY(This.KnownColor, "DarkSlateBlue", KnownColorDarkSlateBlue)
			ADDPROPERTY(This.KnownColor, "DarkSlateGray", KnownColorDarkSlateGray)
			ADDPROPERTY(This.KnownColor, "DarkTurquoise", KnownColorDarkTurquoise)
			ADDPROPERTY(This.KnownColor, "DarkViolet", KnownColorDarkViolet)
			ADDPROPERTY(This.KnownColor, "DeepPink", KnownColorDeepPink)
			ADDPROPERTY(This.KnownColor, "DeepSkyBlue", KnownColorDeepSkyBlue)
			ADDPROPERTY(This.KnownColor, "DimGray", KnownColorDimGray)
			ADDPROPERTY(This.KnownColor, "DodgerBlue", KnownColorDodgerBlue)
			ADDPROPERTY(This.KnownColor, "Firebrick", KnownColorFirebrick)
			ADDPROPERTY(This.KnownColor, "FloralWhite", KnownColorFloralWhite)
			ADDPROPERTY(This.KnownColor, "ForestGreen", KnownColorForestGreen)
			ADDPROPERTY(This.KnownColor, "Fuchsia", KnownColorFuchsia)
			ADDPROPERTY(This.KnownColor, "Gainsboro", KnownColorGainsboro)
			ADDPROPERTY(This.KnownColor, "GhostWhite", KnownColorGhostWhite)
			ADDPROPERTY(This.KnownColor, "Gold", KnownColorGold)
			ADDPROPERTY(This.KnownColor, "Goldenrod", KnownColorGoldenrod)
			ADDPROPERTY(This.KnownColor, "Gray", KnownColorGray)
			ADDPROPERTY(This.KnownColor, "Green", KnownColorGreen)
			ADDPROPERTY(This.KnownColor, "GreenYellow", KnownColorGreenYellow)
			ADDPROPERTY(This.KnownColor, "Honeydew", KnownColorHoneydew)
			ADDPROPERTY(This.KnownColor, "HotPink", KnownColorHotPink)
			ADDPROPERTY(This.KnownColor, "IndianRed", KnownColorIndianRed)
			ADDPROPERTY(This.KnownColor, "Indigo", KnownColorIndigo)
			ADDPROPERTY(This.KnownColor, "Ivory", KnownColorIvory)
			ADDPROPERTY(This.KnownColor, "Khaki", KnownColorKhaki)
			ADDPROPERTY(This.KnownColor, "Lavender", KnownColorLavender)
			ADDPROPERTY(This.KnownColor, "LavenderBlush", KnownColorLavenderBlush)
			ADDPROPERTY(This.KnownColor, "LawnGreen", KnownColorLawnGreen)
			ADDPROPERTY(This.KnownColor, "LemonChiffon", KnownColorLemonChiffon)
			ADDPROPERTY(This.KnownColor, "LightBlue", KnownColorLightBlue)
			ADDPROPERTY(This.KnownColor, "LightCoral", KnownColorLightCoral)
			ADDPROPERTY(This.KnownColor, "LightCyan", KnownColorLightCyan)
			ADDPROPERTY(This.KnownColor, "LightGoldenrodYellow", KnownColorLightGoldenrodYellow)
			ADDPROPERTY(This.KnownColor, "LightGray", KnownColorLightGray)
			ADDPROPERTY(This.KnownColor, "LightGreen", KnownColorLightGreen)
			ADDPROPERTY(This.KnownColor, "LightPink", KnownColorLightPink)
			ADDPROPERTY(This.KnownColor, "LightSalmon", KnownColorLightSalmon)
			ADDPROPERTY(This.KnownColor, "LightSeaGreen", KnownColorLightSeaGreen)
			ADDPROPERTY(This.KnownColor, "LightSkyBlue", KnownColorLightSkyBlue)
			ADDPROPERTY(This.KnownColor, "LightSlateGray", KnownColorLightSlateGray)
			ADDPROPERTY(This.KnownColor, "LightSteelBlue", KnownColorLightSteelBlue)
			ADDPROPERTY(This.KnownColor, "LightYellow", KnownColorLightYellow)
			ADDPROPERTY(This.KnownColor, "Lime", KnownColorLime)
			ADDPROPERTY(This.KnownColor, "LimeGreen", KnownColorLimeGreen)
			ADDPROPERTY(This.KnownColor, "Linen", KnownColorLinen)
			ADDPROPERTY(This.KnownColor, "Magenta", KnownColorMagenta)
			ADDPROPERTY(This.KnownColor, "Maroon", KnownColorMaroon)
			ADDPROPERTY(This.KnownColor, "MediumAquamarine", KnownColorMediumAquamarine)
			ADDPROPERTY(This.KnownColor, "MediumBlue", KnownColorMediumBlue)
			ADDPROPERTY(This.KnownColor, "MediumOrchid", KnownColorMediumOrchid)
			ADDPROPERTY(This.KnownColor, "MediumPurple", KnownColorMediumPurple)
			ADDPROPERTY(This.KnownColor, "MediumSeaGreen", KnownColorMediumSeaGreen)
			ADDPROPERTY(This.KnownColor, "MediumSlateBlue", KnownColorMediumSlateBlue)
			ADDPROPERTY(This.KnownColor, "MediumSpringGreen", KnownColorMediumSpringGreen)
			ADDPROPERTY(This.KnownColor, "MediumTurquoise", KnownColorMediumTurquoise)
			ADDPROPERTY(This.KnownColor, "MediumVioletRed", KnownColorMediumVioletRed)
			ADDPROPERTY(This.KnownColor, "MidnightBlue", KnownColorMidnightBlue)
			ADDPROPERTY(This.KnownColor, "MintCream", KnownColorMintCream)
			ADDPROPERTY(This.KnownColor, "MistyRose", KnownColorMistyRose)
			ADDPROPERTY(This.KnownColor, "Moccasin", KnownColorMoccasin)
			ADDPROPERTY(This.KnownColor, "NavajoWhite", KnownColorNavajoWhite)
			ADDPROPERTY(This.KnownColor, "Navy", KnownColorNavy)
			ADDPROPERTY(This.KnownColor, "OldLace", KnownColorOldLace)
			ADDPROPERTY(This.KnownColor, "Olive", KnownColorOlive)
			ADDPROPERTY(This.KnownColor, "OliveDrab", KnownColorOliveDrab)
			ADDPROPERTY(This.KnownColor, "Orange", KnownColorOrange)
			ADDPROPERTY(This.KnownColor, "OrangeRed", KnownColorOrangeRed)
			ADDPROPERTY(This.KnownColor, "Orchid", KnownColorOrchid)
			ADDPROPERTY(This.KnownColor, "PaleGoldenrod", KnownColorPaleGoldenrod)
			ADDPROPERTY(This.KnownColor, "PaleGreen", KnownColorPaleGreen)
			ADDPROPERTY(This.KnownColor, "PaleTurquoise", KnownColorPaleTurquoise)
			ADDPROPERTY(This.KnownColor, "PaleVioletRed", KnownColorPaleVioletRed)
			ADDPROPERTY(This.KnownColor, "PapayaWhip", KnownColorPapayaWhip)
			ADDPROPERTY(This.KnownColor, "PeachPuff", KnownColorPeachPuff)
			ADDPROPERTY(This.KnownColor, "Peru", KnownColorPeru)
			ADDPROPERTY(This.KnownColor, "Pink", KnownColorPink)
			ADDPROPERTY(This.KnownColor, "Plum", KnownColorPlum)
			ADDPROPERTY(This.KnownColor, "PowderBlue", KnownColorPowderBlue)
			ADDPROPERTY(This.KnownColor, "Purple", KnownColorPurple)
			ADDPROPERTY(This.KnownColor, "Red", KnownColorRed)
			ADDPROPERTY(This.KnownColor, "RosyBrown", KnownColorRosyBrown)
			ADDPROPERTY(This.KnownColor, "RoyalBlue", KnownColorRoyalBlue)
			ADDPROPERTY(This.KnownColor, "SaddleBrown", KnownColorSaddleBrown)
			ADDPROPERTY(This.KnownColor, "Salmon", KnownColorSalmon)
			ADDPROPERTY(This.KnownColor, "SandyBrown", KnownColorSandyBrown)
			ADDPROPERTY(This.KnownColor, "SeaGreen", KnownColorSeaGreen)
			ADDPROPERTY(This.KnownColor, "SeaShell", KnownColorSeaShell)
			ADDPROPERTY(This.KnownColor, "Sienna", KnownColorSienna)
			ADDPROPERTY(This.KnownColor, "Silver", KnownColorSilver)
			ADDPROPERTY(This.KnownColor, "SkyBlue", KnownColorSkyBlue)
			ADDPROPERTY(This.KnownColor, "SlateBlue", KnownColorSlateBlue)
			ADDPROPERTY(This.KnownColor, "SlateGray", KnownColorSlateGray)
			ADDPROPERTY(This.KnownColor, "Snow", KnownColorSnow)
			ADDPROPERTY(This.KnownColor, "SpringGreen", KnownColorSpringGreen)
			ADDPROPERTY(This.KnownColor, "SteelBlue", KnownColorSteelBlue)
			ADDPROPERTY(This.KnownColor, "Tan", KnownColorTan)
			ADDPROPERTY(This.KnownColor, "Teal", KnownColorTeal)
			ADDPROPERTY(This.KnownColor, "Thistle", KnownColorThistle)
			ADDPROPERTY(This.KnownColor, "Tomato", KnownColorTomato)
			ADDPROPERTY(This.KnownColor, "Turquoise", KnownColorTurquoise)
			ADDPROPERTY(This.KnownColor, "Violet", KnownColorViolet)
			ADDPROPERTY(This.KnownColor, "Wheat", KnownColorWheat)
			ADDPROPERTY(This.KnownColor, "White", KnownColorWhite)
			ADDPROPERTY(This.KnownColor, "WhiteSmoke", KnownColorWhiteSmoke)
			ADDPROPERTY(This.KnownColor, "Yellow", KnownColorYellow)
			ADDPROPERTY(This.KnownColor, "YellowGreen", KnownColorYellowGreen)
			ADDPROPERTY(This.KnownColor, "ButtonFace", KnownColorButtonFace)
			ADDPROPERTY(This.KnownColor, "ButtonHighlight", KnownColorButtonHighlight)
			ADDPROPERTY(This.KnownColor, "ButtonShadow", KnownColorButtonShadow)
			ADDPROPERTY(This.KnownColor, "GradientActiveCaption", KnownColorGradientActiveCaption)
			ADDPROPERTY(This.KnownColor, "GradientInactiveCaption", KnownColorGradientInactiveCaption)
			ADDPROPERTY(This.KnownColor, "MenuBar", KnownColorMenuBar)
			ADDPROPERTY(This.KnownColor, "MenuHighlight", KnownColorMenuHighlight)
		#IFDEF USE_MEMBERDATA
			LOCAL lcMemberData
			m.lcMemberData = ;
						[<memberdata name="activeborder" display="ActiveBorder"/>]+;
						[<memberdata name="activecaption" display="ActiveCaption"/>]+;
						[<memberdata name="activecaptiontext" display="ActiveCaptionText"/>]+;
						[<memberdata name="appworkspace" display="AppWorkspace"/>]+;
						[<memberdata name="control" display="Control"/>]+;
						[<memberdata name="controldark" display="ControlDark"/>]+;
						[<memberdata name="controldarkdark" display="ControlDarkDark"/>]+;
						[<memberdata name="controllight" display="ControlLight"/>]+;
						[<memberdata name="controllightlight" display="ControlLightLight"/>]+;
						[<memberdata name="controltext" display="ControlText"/>]+;
						[<memberdata name="desktop" display="Desktop"/>]+;
						[<memberdata name="graytext" display="GrayText"/>]+;
						[<memberdata name="highlight" display="Highlight"/>]+;
						[<memberdata name="highlighttext" display="HighlightText"/>]+;
						[<memberdata name="hottrack" display="HotTrack"/>]+;
						[<memberdata name="inactiveborder" display="InactiveBorder"/>]+;
						[<memberdata name="inactivecaption" display="InactiveCaption"/>]+;
						[<memberdata name="inactivecaptiontext" display="InactiveCaptionText"/>]+;
						[<memberdata name="info" display="Info"/>]+;
						[<memberdata name="infotext" display="InfoText"/>]+;
						[<memberdata name="menu" display="Menu"/>]+;
						[<memberdata name="menutext" display="MenuText"/>]+;
						[<memberdata name="scrollbar" display="ScrollBar"/>]+;
						[<memberdata name="window" display="Window"/>]+;
						[<memberdata name="windowframe" display="WindowFrame"/>]+;
						[<memberdata name="windowtext" display="WindowText"/>]+;
						[<memberdata name="transparent" display="Transparent"/>]+;
						[<memberdata name="aliceblue" display="AliceBlue"/>]+;
						[<memberdata name="antiquewhite" display="AntiqueWhite"/>]+;
						[<memberdata name="aqua" display="Aqua"/>]+;
						[<memberdata name="aquamarine" display="Aquamarine"/>]
			m.lcMemberData = m.lcMemberData + ;		
						[<memberdata name="azure" display="Azure"/>]+;
						[<memberdata name="beige" display="Beige"/>]+;
						[<memberdata name="bisque" display="Bisque"/>]+;
						[<memberdata name="black" display="Black"/>]+;
						[<memberdata name="blanchedalmond" display="BlanchedAlmond"/>]+;
						[<memberdata name="blue" display="Blue"/>]+;
						[<memberdata name="blueviolet" display="BlueViolet"/>]+;
						[<memberdata name="brown" display="Brown"/>]+;
						[<memberdata name="burlywood" display="BurlyWood"/>]+;
						[<memberdata name="cadetblue" display="CadetBlue"/>]+;
						[<memberdata name="chartreuse" display="Chartreuse"/>]+;
						[<memberdata name="chocolate" display="Chocolate"/>]+;
						[<memberdata name="coral" display="Coral"/>]+;
						[<memberdata name="cornflowerblue" display="CornflowerBlue"/>]+;
						[<memberdata name="cornsilk" display="Cornsilk"/>]+;
						[<memberdata name="crimson" display="Crimson"/>]+;
						[<memberdata name="cyan" display="Cyan"/>]+;
						[<memberdata name="darkblue" display="DarkBlue"/>]+;
						[<memberdata name="darkcyan" display="DarkCyan"/>]+;
						[<memberdata name="darkgoldenrod" display="DarkGoldenrod"/>]+;
						[<memberdata name="darkgray" display="DarkGray"/>]+;
						[<memberdata name="darkgreen" display="DarkGreen"/>]+;
						[<memberdata name="darkkhaki" display="DarkKhaki"/>]+;
						[<memberdata name="darkmagenta" display="DarkMagenta"/>]+;
						[<memberdata name="darkolivegreen" display="DarkOliveGreen"/>]+;
						[<memberdata name="darkorange" display="DarkOrange"/>]+;
						[<memberdata name="darkorchid" display="DarkOrchid"/>]+;
						[<memberdata name="darkred" display="DarkRed"/>]+;
						[<memberdata name="darksalmon" display="DarkSalmon"/>]+;
						[<memberdata name="darkseagreen" display="DarkSeaGreen"/>]+;
						[<memberdata name="darkslateblue" display="DarkSlateBlue"/>]+;
						[<memberdata name="darkslategray" display="DarkSlateGray"/>]+;
						[<memberdata name="darkturquoise" display="DarkTurquoise"/>]+;
						[<memberdata name="darkviolet" display="DarkViolet"/>]+;
						[<memberdata name="deeppink" display="DeepPink"/>]+;
						[<memberdata name="deepskyblue" display="DeepSkyBlue"/>]+;
						[<memberdata name="dimgray" display="DimGray"/>]+;
						[<memberdata name="dodgerblue" display="DodgerBlue"/>]+;
						[<memberdata name="firebrick" display="Firebrick"/>]
			m.lcMemberData = m.lcMemberData + ;
						[<memberdata name="floralwhite" display="FloralWhite"/>]+;
						[<memberdata name="forestgreen" display="ForestGreen"/>]+;
						[<memberdata name="fuchsia" display="Fuchsia"/>]+;
						[<memberdata name="gainsboro" display="Gainsboro"/>]+;
						[<memberdata name="ghostwhite" display="GhostWhite"/>]+;
						[<memberdata name="gold" display="Gold"/>]+;
						[<memberdata name="goldenrod" display="Goldenrod"/>]+;
						[<memberdata name="gray" display="Gray"/>]+;
						[<memberdata name="green" display="Green"/>]+;
						[<memberdata name="greenyellow" display="GreenYellow"/>]+;
						[<memberdata name="honeydew" display="Honeydew"/>]+;
						[<memberdata name="hotpink" display="HotPink"/>]+;
						[<memberdata name="indianred" display="IndianRed"/>]+;
						[<memberdata name="indigo" display="Indigo"/>]+;
						[<memberdata name="ivory" display="Ivory"/>]+;
						[<memberdata name="khaki" display="Khaki"/>]+;
						[<memberdata name="lavender" display="Lavender"/>]+;
						[<memberdata name="lavenderblush" display="LavenderBlush"/>]+;
						[<memberdata name="lawngreen" display="LawnGreen"/>]+;
						[<memberdata name="lemonchiffon" display="LemonChiffon"/>]+;
						[<memberdata name="lightblue" display="LightBlue"/>]+;
						[<memberdata name="lightcoral" display="LightCoral"/>]+;
						[<memberdata name="lightcyan" display="LightCyan"/>]+;
						[<memberdata name="lightgoldenrodyellow" display="LightGoldenrodYellow"/>]+;
						[<memberdata name="lightgray" display="LightGray"/>]+;
						[<memberdata name="lightgreen" display="LightGreen"/>]+;
						[<memberdata name="lightpink" display="LightPink"/>]+;
						[<memberdata name="lightsalmon" display="LightSalmon"/>]+;
						[<memberdata name="lightseagreen" display="LightSeaGreen"/>]+;
						[<memberdata name="lightskyblue" display="LightSkyBlue"/>]+;
						[<memberdata name="lightslategray" display="LightSlateGray"/>]+;
						[<memberdata name="lightsteelblue" display="LightSteelBlue"/>]+;
						[<memberdata name="lightyellow" display="LightYellow"/>]+;
						[<memberdata name="lime" display="Lime"/>]+;
						[<memberdata name="limegreen" display="LimeGreen"/>]+;
						[<memberdata name="linen" display="Linen"/>]+;
						[<memberdata name="magenta" display="Magenta"/>]+;
						[<memberdata name="maroon" display="Maroon"/>]+;
						[<memberdata name="mediumaquamarine" display="MediumAquamarine"/>]+;
						[<memberdata name="mediumblue" display="MediumBlue"/>]+;
						[<memberdata name="mediumorchid" display="MediumOrchid"/>]+;
						[<memberdata name="mediumpurple" display="MediumPurple"/>]+;
						[<memberdata name="mediumseagreen" display="MediumSeaGreen"/>]+;
						[<memberdata name="mediumslateblue" display="MediumSlateBlue"/>]+;
						[<memberdata name="mediumspringgreen" display="MediumSpringGreen"/>]+;
						[<memberdata name="mediumturquoise" display="MediumTurquoise"/>]+;
						[<memberdata name="mediumvioletred" display="MediumVioletRed"/>]+;
						[<memberdata name="midnightblue" display="MidnightBlue"/>]+;
						[<memberdata name="mintcream" display="MintCream"/>]+;
						[<memberdata name="mistyrose" display="MistyRose"/>]+;
						[<memberdata name="moccasin" display="Moccasin"/>]+;
						[<memberdata name="navajowhite" display="NavajoWhite"/>]
			m.lcMemberData = m.lcMemberData + ;
						[<memberdata name="navy" display="Navy"/>]+;
						[<memberdata name="oldlace" display="OldLace"/>]+;
						[<memberdata name="olive" display="Olive"/>]+;
						[<memberdata name="olivedrab" display="OliveDrab"/>]+;
						[<memberdata name="orange" display="Orange"/>]+;
						[<memberdata name="orangered" display="OrangeRed"/>]+;
						[<memberdata name="orchid" display="Orchid"/>]+;
						[<memberdata name="palegoldenrod" display="PaleGoldenrod"/>]+;
						[<memberdata name="palegreen" display="PaleGreen"/>]+;
						[<memberdata name="paleturquoise" display="PaleTurquoise"/>]+;
						[<memberdata name="palevioletred" display="PaleVioletRed"/>]+;
						[<memberdata name="papayawhip" display="PapayaWhip"/>]+;
						[<memberdata name="peachpuff" display="PeachPuff"/>]+;
						[<memberdata name="peru" display="Peru"/>]+;
						[<memberdata name="pink" display="Pink"/>]+;
						[<memberdata name="plum" display="Plum"/>]+;
						[<memberdata name="powderblue" display="PowderBlue"/>]+;
						[<memberdata name="purple" display="Purple"/>]+;
						[<memberdata name="red" display="Red"/>]+;
						[<memberdata name="rosybrown" display="RosyBrown"/>]+;
						[<memberdata name="royalblue" display="RoyalBlue"/>]+;
						[<memberdata name="saddlebrown" display="SaddleBrown"/>]+;
						[<memberdata name="salmon" display="Salmon"/>]+;
						[<memberdata name="sandybrown" display="SandyBrown"/>]+;
						[<memberdata name="seagreen" display="SeaGreen"/>]+;
						[<memberdata name="seashell" display="SeaShell"/>]+;
						[<memberdata name="sienna" display="Sienna"/>]+;
						[<memberdata name="silver" display="Silver"/>]+;
						[<memberdata name="skyblue" display="SkyBlue"/>]+;
						[<memberdata name="slateblue" display="SlateBlue"/>]+;
						[<memberdata name="slategray" display="SlateGray"/>]+;
						[<memberdata name="snow" display="Snow"/>]+;
						[<memberdata name="springgreen" display="SpringGreen"/>]+;
						[<memberdata name="steelblue" display="SteelBlue"/>]+;
						[<memberdata name="tan" display="Tan"/>]+;
						[<memberdata name="teal" display="Teal"/>]+;
						[<memberdata name="thistle" display="Thistle"/>]+;
						[<memberdata name="tomato" display="Tomato"/>]+;
						[<memberdata name="turquoise" display="Turquoise"/>]+;
						[<memberdata name="violet" display="Violet"/>]+;
						[<memberdata name="wheat" display="Wheat"/>]+;
						[<memberdata name="white" display="White"/>]+;
						[<memberdata name="whitesmoke" display="WhiteSmoke"/>]+;
						[<memberdata name="yellow" display="Yellow"/>]
			m.lcMemberData = m.lcMemberData + ;
						[<memberdata name="yellowgreen" display="YellowGreen"/>]+;
						[<memberdata name="buttonface" display="ButtonFace"/>]+;
						[<memberdata name="buttonhighlight" display="ButtonHighlight"/>]+;
						[<memberdata name="buttonshadow" display="ButtonShadow"/>]+;
						[<memberdata name="gradientactivecaption" display="GradientActiveCaption"/>]+;
						[<memberdata name="gradientinactivecaption" display="GradientInactiveCaption"/>]+;
						[<memberdata name="menubar" display="MenuBar"/>]+;
						[<memberdata name="menuhighlight" display="MenuHighlight"/>]
			ADDPROPERTY(This.KnownColor, "_memberdata", [<VFPData>]+;
						m.lcMemberData+;
						[</VFPData>])
		#ENDIF
		ENDIF
		
		RETURN This.KnownColor
	ENDFUNC

	*********************************************************************
	FUNCTION Pens_ACCESS
	*********************************************************************
		IF VARTYPE(This.Pens) <> "O"
			This.Pens = CREATEOBJECT("xfcPens")
		ENDIF
		RETURN THIS.Pens
	ENDFUNC


	*********************************************************************
	FUNCTION Pen_ACCESS
	*********************************************************************
		IF VARTYPE(This.Pen) <> "O"
			This.Pen = CREATEOBJECT("xfcPen", This.Color)
		ENDIF		
		RETURN THIS.Pen
	ENDFUNC


	*********************************************************************
	FUNCTION PointF_ACCESS
	*********************************************************************
		IF VARTYPE(This.PointF) <> "O"
			This.PointF = CREATEOBJECT("xfcPointF")
		ENDIF
		RETURN THIS.PointF
	ENDFUNC


	*********************************************************************
	FUNCTION Point_ACCESS
	*********************************************************************
		IF VARTYPE(This.Point) <> "O"
			This.Point = CREATEOBJECT("xfcPoint")
		ENDIF
		RETURN THIS.Point
	ENDFUNC


	*********************************************************************
	FUNCTION RectangleF_ACCESS
	*********************************************************************
		IF VARTYPE(This.RectangleF) <> "O"
			This.RectangleF = CREATEOBJECT("xfcRectangleF")
		ENDIF
		RETURN THIS.RectangleF
	ENDFUNC


	*********************************************************************
	FUNCTION Rectangle_ACCESS
	*********************************************************************
		IF VARTYPE(This.Rectangle) <> "O"
			This.Rectangle = CREATEOBJECT("xfcRectangle")
		ENDIF
		RETURN THIS.Rectangle
	ENDFUNC


	*********************************************************************
	FUNCTION Region_ACCESS
	*********************************************************************
		IF VARTYPE(This.Region) <> "O"
			This.Region = CREATEOBJECT("xfcRegion")
		ENDIF
		RETURN THIS.Region
	ENDFUNC


	*********************************************************************
	FUNCTION RotateFlipType_ACCESS
	*********************************************************************
	** Enumeration: RotateFlipType (Access)
	**
	** Specifies the direction of an image's rotation and the axis used to flip the image.
	**
	** History:
	**  2007/02/02: CChalom - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/system.drawing.rotatefliptype.aspx
	*********************************************************************
		
		*!ToDo: Test this method
		
		IF VARTYPE(This.RotateFlipType) <> "O"
			This.RotateFlipType = NEWOBJECT(ENUM_BASECLASS,XFCCLASS_SYSTEM)
			ADDPROPERTY(This.RotateFlipType , "RotateNoneFlipNone", RotateNoneFlipNone)
			ADDPROPERTY(This.RotateFlipType , "Rotate90FlipNone", Rotate90FlipNone)
			ADDPROPERTY(This.RotateFlipType , "Rotate180FlipNone", Rotate180FlipNone )
			ADDPROPERTY(This.RotateFlipType , "Rotate270FlipNone", Rotate270FlipNone )
			ADDPROPERTY(This.RotateFlipType , "RotateNoneFlipX", RotateNoneFlipX)
			ADDPROPERTY(This.RotateFlipType , "Rotate90FlipX", Rotate90FlipX)
			ADDPROPERTY(This.RotateFlipType , "Rotate180FlipX", Rotate180FlipX)
			ADDPROPERTY(This.RotateFlipType , "Rotate270FlipX", Rotate270FlipX)
			ADDPROPERTY(This.RotateFlipType , "Rotate180FlipXY", Rotate180FlipXY)
			ADDPROPERTY(This.RotateFlipType , "Rotate270FlipXY", Rotate270FlipXY)
			ADDPROPERTY(This.RotateFlipType , "RotateNoneFlipXY", RotateNoneFlipXY)
			ADDPROPERTY(This.RotateFlipType , "Rotate90FlipXY", Rotate90FlipXY)
			ADDPROPERTY(This.RotateFlipType , "Rotate180FlipY", Rotate180FlipY)
			ADDPROPERTY(This.RotateFlipType , "Rotate270FlipY", Rotate270FlipY)
			ADDPROPERTY(This.RotateFlipType , "RotateNoneFlipY", RotateNoneFlipY)
			ADDPROPERTY(This.RotateFlipType , "Rotate90FlipY", Rotate90FlipY)
		
		#IFDEF USE_MEMBERDATA
			ADDPROPERTY(This.RotateFlipType, "_memberdata", [<VFPData>]+;
						[<memberdata name="rotatenoneflipnone" display="RotateNoneFlipNone"/>]+;
						[<memberdata name="rotate90flipnone" display="Rotate90FlipNone"/>]+;
						[<memberdata name="rotate180flipnone" display="Rotate180FlipNone"/>]+;
						[<memberdata name="rotate270flipnone" display="Rotate270FlipNone"/>]+;
						[<memberdata name="rotatenoneflipx" display="RotateNoneFlipX"/>]+;
						[<memberdata name="rotate90flipx" display="Rotate90FlipX"/>]+;
						[<memberdata name="rotate180flipx" display="Rotate180FlipX"/>]+;
						[<memberdata name="rotate270flipx" display="Rotate270FlipX"/>]+;
						[<memberdata name="rotate180flipxy" display="Rotate180FlipXY"/>]+;
						[<memberdata name="rotate270flipxy" display="Rotate270FlipXY"/>]+;
						[<memberdata name="rotatenoneflipxy" display="RotateNoneFlipXY"/>]+;
						[<memberdata name="rotate90flipxy" display="Rotate90FlipXY"/>]+;
						[<memberdata name="rotate180flipy" display="Rotate180FlipY"/>]+;
						[<memberdata name="rotate270flipy" display="Rotate270FlipY"/>]+;
						[<memberdata name="rotatenoneflipy" display="RotateNoneFlipY"/>]+;
						[<memberdata name="rotate90flipy" display="Rotate90FlipY"/>]+;
						[</VFPData>])
		#ENDIF
		ENDIF
		
		RETURN This.RotateFlipType
	ENDFUNC


	*********************************************************************
	FUNCTION SizeF_ACCESS
	*********************************************************************
		IF VARTYPE(This.SizeF) <> "O"
			This.SizeF = CREATEOBJECT("xfcSizeF")
		ENDIF
		
		RETURN THIS.SizeF
	ENDFUNC


	*********************************************************************
	FUNCTION Size_ACCESS
	*********************************************************************
		IF VARTYPE(This.Size) <> "O"
			This.Size = CREATEOBJECT("xfcSize")
		ENDIF
		
		RETURN THIS.Size
	ENDFUNC


	*********************************************************************
	FUNCTION SolidBrush_ACCESS
	*********************************************************************
		IF VARTYPE(This.SolidBrush) <> "O"
			This.SolidBrush = CREATEOBJECT("xfcSolidBrush", This.Color)
		ENDIF
		
		RETURN THIS.SolidBrush
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION StringAlignment_ACCESS
	*********************************************************************
	** Enumeration: StringAlignment (Access)
	**
	** Specifies the alignment of a text string relative to its layout rectangle.
	**
	** History:
	**  2006/06/11: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringAlignment%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this method
		
		IF VARTYPE(This.StringAlignment) <> "O"
			This.StringAlignment = NEWOBJECT(ENUM_BASECLASS,XFCCLASS_SYSTEM)
			ADDPROPERTY(This.StringAlignment, "Near", StringAlignmentNear)
			ADDPROPERTY(This.StringAlignment, "Center", StringAlignmentCenter)
			ADDPROPERTY(This.StringAlignment, "Far", StringAlignmentFar)
		#IFDEF USE_MEMBERDATA
			ADDPROPERTY(This.StringAlignment, "_memberdata", [<VFPData>]+;
						[<memberdata name="near" display="Near"/>]+;
						[<memberdata name="center" display="Center"/>]+;
						[<memberdata name="far" display="Far"/>]+;
						[</VFPData>])
		#ENDIF
		ENDIF
		
		RETURN This.StringAlignment
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION StringDigitSubstitute_ACCESS
	*********************************************************************
	** Enumeration: StringDigitSubstitute (Access)
	**
	** The StringDigitSubstitute enumeration specifies how to substitute digits in a string according to a user's locale or language.
	**
	** History:
	**  2006/06/11: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringDigitSubstitute%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this method
		
		IF VARTYPE(This.StringDigitSubstitute) <> "O"
			This.StringDigitSubstitute = NEWOBJECT(ENUM_BASECLASS,XFCCLASS_SYSTEM)
			ADDPROPERTY(This.StringDigitSubstitute, "User", StringDigitSubstituteUser)
			ADDPROPERTY(This.StringDigitSubstitute, "None", StringDigitSubstituteNone)
			ADDPROPERTY(This.StringDigitSubstitute, "National", StringDigitSubstituteNational)
			ADDPROPERTY(This.StringDigitSubstitute, "Traditional", StringDigitSubstituteTraditional)
		#IFDEF USE_MEMBERDATA
			ADDPROPERTY(This.StringFormatFlags, "_memberdata", [<VFPData>]+;
						[<memberdata name="user" display="User"/>]+;
						[<memberdata name="none" display="None"/>]+;
						[<memberdata name="national" display="National"/>]+;
						[<memberdata name="traditional" display="Traditional"/>]+;
						[</VFPData>])
		#ENDIF
		ENDIF
		
		RETURN This.StringDigitSubstitute
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION StringFormatFlags_ACCESS
	*********************************************************************
	** Enumeration: StringFormatFlags (Access)
	**
	** Specifies the display and layout information for text strings.
	**
	** History:
	**  2006/06/11: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormatFlags%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this method
		
		IF VARTYPE(This.StringFormatFlags) <> "O"
			This.StringFormatFlags = NEWOBJECT(ENUM_BASECLASS,XFCCLASS_SYSTEM)
			ADDPROPERTY(This.StringFormatFlags, "DirectionRightToLeft", StringFormatFlagsDirectionRightToLeft)
			ADDPROPERTY(This.StringFormatFlags, "DirectionVertical", StringFormatFlagsDirectionVertical)
			ADDPROPERTY(This.StringFormatFlags, "NoFitBlackBox", StringFormatFlagsNoFitBlackBox)
			ADDPROPERTY(This.StringFormatFlags, "DisplayFormatControl", StringFormatFlagsDisplayFormatControl)
			ADDPROPERTY(This.StringFormatFlags, "NoFontFallback", StringFormatFlagsNoFontFallback)
			ADDPROPERTY(This.StringFormatFlags, "MeasureTrailingSpaces", StringFormatFlagsMeasureTrailingSpaces)
			ADDPROPERTY(This.StringFormatFlags, "NoWrap", StringFormatFlagsNoWrap)
			ADDPROPERTY(This.StringFormatFlags, "LineLimit", StringFormatFlagsLineLimit)
			ADDPROPERTY(This.StringFormatFlags, "NoClip", StringFormatFlagsNoClip)
		#IFDEF USE_MEMBERDATA
			ADDPROPERTY(This.StringFormatFlags, "_memberdata", [<VFPData>]+;
						[<memberdata name="directionrighttoleft" display="DirectionRightToLeft"/>]+;
						[<memberdata name="directionvertical" display="DirectionVertical"/>]+;
						[<memberdata name="nofitblackbox" display="NoFitBlackBox"/>]+;
						[<memberdata name="displayformatcontrol" display="DisplayFormatControl"/>]+;
						[<memberdata name="nofontfallback" display="NoFontFallback"/>]+;
						[<memberdata name="measuretrailingspaces" display="MeasureTrailingSpaces"/>]+;
						[<memberdata name="nowrap" display="NoWrap"/>]+;
						[<memberdata name="linelimit" display="LineLimit"/>]+;
						[<memberdata name="noclip" display="NoClip"/>]+;
						[</VFPData>])
		#ENDIF
		ENDIF
		
		RETURN This.StringFormatFlags
	ENDFUNC


	*********************************************************************
	FUNCTION StringFormat_ACCESS
	*********************************************************************
		IF VARTYPE(This.StringFormat) <> "O"
			This.StringFormat = CREATEOBJECT("xfcStringFormat")
		ENDIF
		
		RETURN THIS.StringFormat
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION StringTrimming_ACCESS
	*********************************************************************
	** Enumeration: StringTrimming (Access)
	**
	** Specifies how to trim characters from a string that does not completely fit into a layout shape.
	**
	** History:
	**  2006/06/11: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringTrimming%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this method
		
		IF VARTYPE(This.StringTrimming) <> "O"
			This.StringTrimming = NEWOBJECT(ENUM_BASECLASS,XFCCLASS_SYSTEM)
			ADDPROPERTY(This.StringTrimming, "None", StringTrimmingNone)
			ADDPROPERTY(This.StringTrimming, "Character", StringTrimmingCharacter)
			ADDPROPERTY(This.StringTrimming, "Word", StringTrimmingWord)
			ADDPROPERTY(This.StringTrimming, "EllipsisCharacter", StringTrimmingEllipsisCharacter)
			ADDPROPERTY(This.StringTrimming, "EllipsisWord", StringTrimmingEllipsisWord)
			ADDPROPERTY(This.StringTrimming, "EllipsisPath", StringTrimmingEllipsisPath)
		#IFDEF USE_MEMBERDATA
			ADDPROPERTY(This.StringTrimming, "_memberdata", [<VFPData>]+;
						[<memberdata name="none" display="None"/>]+;
						[<memberdata name="character" display="Character"/>]+;
						[<memberdata name="word" display="Word"/>]+;
						[<memberdata name="ellipsischaracter" display="EllipsisCharacter"/>]+;
						[<memberdata name="ellipsisword" display="EllipsisWord"/>]+;
						[<memberdata name="ellipsispath" display="EllipsisPath"/>]+;
						[</VFPData>])
		#ENDIF
		ENDIF
		
		RETURN This.StringTrimming
	ENDFUNC


	*********************************************************************
	FUNCTION SystemBrushes_ACCESS
	*********************************************************************
		IF VARTYPE(This.SystemBrushes) <> "O"
			This.SystemBrushes = CREATEOBJECT("xfcSystemBrushes")
		ENDIF
		
		RETURN THIS.SystemBrushes
	ENDFUNC


	*********************************************************************
	FUNCTION SystemColors_ACCESS
	*********************************************************************
		IF VARTYPE(This.SystemColors) <> "O"
			This.SystemColors = CREATEOBJECT("xfcSystemColors")
		ENDIF
		
		RETURN THIS.SystemColors
	ENDFUNC


	*********************************************************************
	FUNCTION SystemIcons_ACCESS
	*********************************************************************
		IF VARTYPE(This.SystemIcons) <> "O"
			This.SystemIcons = CREATEOBJECT("xfcSystemIcons")
		ENDIF
		
		RETURN THIS.SystemIcons
	ENDFUNC


	*********************************************************************
	FUNCTION SystemPens_ACCESS
	*********************************************************************
		IF VARTYPE(This.SystemPens) <> "O"
			This.SystemPens = CREATEOBJECT("xfcSystemPens")
		ENDIF
		
		RETURN THIS.SystemPens
	ENDFUNC


	*********************************************************************
	FUNCTION TextureBrush_ACCESS
	*********************************************************************
		IF VARTYPE(This.TextureBrush) <> "O"
			This.TextureBrush = CREATEOBJECT("xfcTextureBrush")
		ENDIF
		
		RETURN THIS.TextureBrush
	ENDFUNC


	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="bitmap" type="property" display="Bitmap"/>]+;
		[<memberdata name="color" type="property" display="Color"/>]+;
		[<memberdata name="drawing2d" type="property" display="Drawing2D"/>]+;
		[<memberdata name="font" type="property" display="Font"/>]+;
		[<memberdata name="fontfamily" type="property" display="FontFamily"/>]+;
		[<memberdata name="graphics" type="property" display="Graphics"/>]+;
		[<memberdata name="image" type="property" display="Image"/>]+;
		[<memberdata name="imaging" type="property" display="Imaging"/>]+;
		[<memberdata name="pen" type="property" display="Pen"/>]+;
		[<memberdata name="point" type="property" display="Point"/>]+;
		[<memberdata name="pointf" type="property" display="PointF"/>]+;
		[<memberdata name="rectangle" type="property" display="Rectangle"/>]+;
		[<memberdata name="rectanglef" type="property" display="RectangleF"/>]+;
		[<memberdata name="solidbrush" type="property" display="SolidBrush"/>]+;
		[<memberdata name="stringformat" type="property" display="StringFormat"/>]+;
		[<memberdata name="size" type="property" display="Size"/>]+;
		[<memberdata name="sizef" type="property" display="SizeF"/>]+;
		[<memberdata name="pens" type="property" display="Pens"/>]+;
		[<memberdata name="systembrushes" type="property" display="SystemBrushes"/>]+;
		[<memberdata name="systemcolors" type="property" display="SystemColors"/>]+;
		[<memberdata name="systemicons" type="property" display="SystemIcons"/>]+;
		[<memberdata name="systempens" type="property" display="SystemPens"/>]+;
		[<memberdata name="imageanimator" type="property" display="ImageAnimator"/>]+;
		[<memberdata name="brushes" type="property" display="Brushes"/>]+;
		[<memberdata name="fontstyle" type="property" display="FontStyle"/>]+;
		[<memberdata name="hatchbrush" type="property" display="HatchBrush"/>]+;
		[<memberdata name="knowncolor" type="property" display="KnownColor"/>]+;
		[<memberdata name="stringalignment" type="property" display="StringAlignment"/>]+;
		[<memberdata name="stringdigitsubstitute" type="property" display="StringDigitSubstitute"/>]+;
		[<memberdata name="stringformatflags" type="property" display="StringFormatFlags"/>]+;
		[<memberdata name="stringtrimming" type="property" display="StringTrimming"/>]+;
		[<memberdata name="texturebrush" type="property" display="TextureBrush"/>]+;
		[<memberdata name="characterrange" type="property" display="CharacterRange"/>]+;
		[<memberdata name="region" type="property" display="Region"/>]+;
		[<memberdata name="graphicsunit" type="property" display="GraphicsUnit"/>]+;
		[<memberdata name="colortranslator" type="property" display="ColorTranslator"/>]+;
		[<memberdata name="rotateflip" type="property" display="RotateFlip"/>]+;
		[<memberdata name="rotatefliptype" type="property" display="RotateFlipType"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
*************************************************************************
*************************************************************************




*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCBITMAP
DEFINE CLASS xfcBitmap AS xfcimage
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Bitmap"
	lastresult = 0
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcBitmap.Bitmap
	**
	** Initializes a new instance of the Bitmap class.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/10: BDurban - Coded, partial
	**  2006/08/25: CChalom - Coded 3 more overloads, still not finished
	**  2007/11/04: CChalom - Coded one more overload for Width, Height, PixelFormat
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.Bitmap%28vs.80%29.aspx
	** Parameters:
	**  Image original
	**  Stream stream
	**  string filename
	**  Image original, Size newSize
	**  int width, int height
	**  Stream stream, bool useIcm
	**  string filename, bool useIcm
	**  Type type, string resource
	**  Image original, int width, int height
	**  int width, int height, Graphics g
	**  int width, int height, PixelFormat format
	**  int width, int height, int stride, PixelFormat format, IntPtr scan0
	*********************************************************************
	LPARAMETERS tiWidth, tiHeight ;
					, tiStride, tiFormat AS EnumPixelFormat, tiScan0 AS IntPtr
	*********** tiWidth, tiHeight
	*********** tiWidth, tiHeight, tiFormat AS EnumPixelFormat
	*********** tiWidth, tiHeight, toG AS xfcGraphics
	*********** tcFilename
	*********** tcFilename, tlUseIcm
	*********** toOriginal AS xfcImage
	*********** toOriginal AS xfcImage, tiWidth, tiHeight
	*********** toOriginal AS xfcImage, toNewSize AS xfcSize
		*!ToDo: handle these overloads 1999
	*********** toStream AS xfcStream
	*********** toStream AS xfcStream, tlUseIcm
	*********** toType AS xfcType, tcResource
		
		*!ToDo: Test this function
		DODEFAULT()
		
		IF PCOUNT() = 0
			RETURN .T.
		ENDIF
		
		LOCAL loGfx AS xfcGraphics
		LOCAL loImage AS xfcImage
		LOCAL loSize AS xfcSize
		LOCAL tcFileName, tlUseIcm, lhBitmap
		LOCAL lnFunctionType
		m.lnFunctionType = 0
		m.loGfx = NULL
		m.tcFileName = ""
		m.tlUseIcm = .F.
		m.lhBitmap = 0
		
		LOCAL loExc AS Exception
		TRY
			
			m.lcVarType = VARTYPE(m.tiWidth)+VARTYPE(m.tiHeight)+;
						VARTYPE(m.tiStride)+VARTYPE(m.tiFormat)+VARTYPE(m.tiScan0)
			
			DO CASE
		** Width, Height, Graphics
			CASE LEFT(m.lcVarType,3) == "NNO" AND m.tiStride.BaseName == "Graphics"
				m.loGfx = m.tiStride
				m.lnFuctionType = 6
			
		** Rectangle/Size, Stride, Format, Scan0
			CASE LEFT(m.lcVarType,1) == "O" AND INLIST(m.tiWidth.BaseName,"Rectangle","RectangleF","Size","SizeF")
				m.tiScan0 = EVL(m.tiFormat, 0)
				m.tiFormat = EVL(m.tiStride, PixelFormat32bppARGB)
				m.tiStride = EVL(m.tiHeight, 0)
				m.tiHeight = m.tiWidth.Height
				m.tiWidth = m.tiWidth.Width
				m.lnFunctionType = 5
			

		** Width, Height, PixelFormat
			CASE LEFT(m.lcVarType,4) == "NNNL"
				m.tiFormat = EVL(m.tiStride, 0)
				m.tiStride = 0
				m.tiScan0 = 0
				m.lnFunctionType = 5


		** Width, Height, Stride, Format, Scan0
			CASE LEFT(m.lcVarType,2) == "NN"
				m.tiStride = EVL(m.tiStride, 0)
				m.tiFormat = EVL(m.tiFormat, PixelFormat32bppARGB)
				m.tiScan0 = EVL(m.tiScan0, 0)
				m.lnFunctionType = 5
				
		** Filename, UseIcm
			CASE LEFT(m.lcVarType,1) == "C"
				m.tcFileName = m.tiWidth
				m.tlUseIcm = m.tiHeight
				m.lnFunctionType = IIF(m.tlUseIcm, 4, 2)
			
		** Image, Width, Height
			CASE LEFT(m.lcVarType,3) == "ONN" AND INLIST(m.tiWidth.BaseName,"Image","Bitmap","MetaFile")
				m.loImage = m.tiWidth
				m.tiWidth = m.tiHeight
				m.tiHeight = m.tiStride
				m.lnFunctionType = 10
				
		** Image, Size
			CASE LEFT(m.lcVarType,2) == "OO" AND INLIST(m.tiWidth.BaseName,"Image","Bitmap","MetaFile") AND m.tiHeight.BaseName == "Size"
				m.loImage = m.tiWidth
				m.loSize = m.tiHeight
				m.loSize.GetExtent(@m.tiWidth, @tiHeight)
				m.lnFunctionType = 10
				
		** Image
			CASE LEFT(m.lcVarType,1) == "O" AND INLIST(m.tiWidth.BaseName,"Image","Bitmap","MetaFile")
				m.loImage = m.tiWidth
				m.tiWidth = m.loImage.Width
				m.tiHeight = m.loImage.Height
				m.lnFunctionType = 10
				
			*!ToDo: handle the remaining overloads
			
		** Stream, UseIcm
			CASE LEFT(m.lcVarType,1) == "O" AND m.tiHeight.BaseName = "Stream"
				m.lnFunctionType = IIF(m.tlUseIcm, 3, 1)
				
			ENDCASE
			
			
			DO CASE
			CASE m.lnFunctionType = 5
				This.SetStatus(xfcGdipCreateBitmapFromScan0(m.tiWidth, m.tiHeight, m.tiStride, m.tiFormat, @tiScan0, @lhBitmap))
			CASE m.lnFunctionType = 6
				This.SetStatus(xfcGdipCreateBitmapFromGraphics(m.tiWidth, m.tiHeight, m.loGfx.Handle, @lhBitmap))
			CASE m.lnFunctionType = 2
				This.SetStatus(xfcGdipCreateBitmapFromFile(STRCONV(m.tcFilename+0h00,5), @lhBitmap))
			CASE m.lnFunctionType = 4
				This.SetStatus(xfcGdipCreateBitmapFromFileICM(STRCONV(m.tcFilename+0h00,5), @lhBitmap))
			CASE m.lnFunctionType = 1
				This.SetStatus(xfcGdipCreateBitmapFromStream(m.liStream, @lhBitmap))
			CASE m.lnFunctionType = 3
				This.SetStatus(xfcGdipCreateBitmapFromStreamICM(m.liStream, @lhBitmap))
			CASE m.lnFunctionType = 7
				This.SetStatus(xfcGdipCreateBitmapFromDirectDrawSurface(@liSurface, @lhBitmap))
			CASE m.lnFunctionType = 8
				This.SetStatus(xfcGdipCreateBitmapFromGdiDib(@lcGdiBitmapInfo, m.lpGdiBitmapData, @lhBitmap))
			CASE m.lnFunctionType = 9
				This.SetStatus(xfcGdipCreateBitmapFromHBITMAP(m.lHbm, m.lHpal, @lhBitmap))
			CASE m.lnFunctionType = 10
				LOCAL loBmp AS xfcBitmap
				m.loBmp = CREATEOBJECT(This.Class, m.tiWidth, m.tiHeight)
				m.loGfx = CREATEOBJECT("xfcGraphics")
				m.loGfx = m.loGfx.FromImage(m.loBmp)
				m.loGfx.Clear(CREATEOBJECT("xfcColor", ARGB_Transparent))
				m.loGfx.DrawImage(m.loImage, 0, 0, m.tiWidth, m.tiHeight)
				
				m.lhBitmap = m.loBmp.Handle
				m.loBmp.Handle = 0
				
				m.loGfx = NULL
				m.loBmp = NULL
			CASE m.lnFunctionType = 11
			ENDCASE
			
			This.Handle = m.lhBitmap
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC



	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcBitmap.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
		RETURN DODEFAULT()
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tiWidth, tiHeight ;
					, tiStride, tiFormat AS EnumPixelFormat, tiScan0 AS IntPtr
		
		RETURN CREATEOBJECT(This.Class, m.tiWidth, m.tiHeight, m.tiStride, m.tiFormat, m.tiScan0)
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcBitmap.Clone
	**
	** Creates a copy of the section of this Bitmap defined with a specified PixelFormat.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2007/08/01: CChalom - Added overload to call parent behavior
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.Clone%28vs.80%29.aspx
	** Parameters:
	**  Rectangle rect, PixelFormat format
	**  RectangleF rect, PixelFormat format
	**  [None]
	** Returns: Bitmap
	*********************************************************************
	LPARAMETERS toRect AS xfcRectangle, tiFormat AS EnumPixelFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loBitmap, lhBitmap
			m.lhBitmap = 0
			m.loBitmap = NULL
		
			IF PCOUNT() = 0
				m.loBitmap = DODEFAULT()
		
			ELSE
				LOCAL lnX, lnY, lnWidth, lnHeight
				toRect.GetExtent(@lnX, @lnY, @lnWidth, @lnHeight)
			
				IF m.toRect.BaseName == "RectangleF"
					This.SetStatus(xfcGdipCloneBitmapArea(m.lnX, m.lnY, m.lnWidth, m.lnHeight, m.tiFormat, This.Handle, @lhBitmap))
				ELSE
					This.SetStatus(xfcGdipCloneBitmapAreaI(m.lnX, m.lnY, m.lnWidth, m.lnHeight, m.tiFormat, This.Handle, @lhBitmap))
				ENDIF
					IF(m.lhBitmap <> 0)
						m.loBitmap = CREATEOBJECT(This.Class)
						m.loBitmap.Handle = m.lhBitmap
					ENDIF
			ENDIF
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBitmap
	ENDFUNC


	*********************************************************************
	FUNCTION FromClipboard
	*********************************************************************
	** Method: xfcBitmap.FromClipboard
	**
	** Creates a Bitmap from the clipboard data
	**
	** History:
	**  2007/02/02: CChalom - Coded (Adapted from FromClipboard Method from GPIMAGE from Alexander Golovlev)
	*********************************************************************
		
		*!ToDo: Test this function
		
		*-- Predefined Clipboard Formats
		#DEFINE ERR_CLIPNOTOPEN "Cannot open the clipboard"
		#DEFINE ERR_CLIPNODATA  "No bitmap data found on the clipboard"
		#DEFINE ERR_CLIPSETDATA "Cannot place data on the clipboard"
		
		#DEFINE CF_BITMAP    2
		#DEFINE CF_PALETTE   9
		#DEFINE OBJ_BITMAP   7
		
		LOCAL lhBitmap, lhBmp, lhPal
		LOCAL loBitmap as xfcBitmap
		
		LOCAL loExc AS Exception
		TRY
		
			m.lhBmp = 0
			m.lhPal = 0
			IF xfcOpenClipboard(0) != 0
				m.lhBmp = xfcGetClipboardData(CF_BITMAP)
				m.lhPal = xfcGetClipboardData(CF_PALETTE)
				xfcCloseClipboard()
		
				m.lhBitmap = 0
				m.loBitmap = NULL
		
				This.SetStatus(xfcGdipCreateBitmapFromHBITMAP(m.lhBmp, m.lhPal, @lhBitmap))
				xfcDeleteObject(m.lhBmp)
		
				IF(m.lhBitmap <> 0)
					m.loBitmap = CREATEOBJECT("xfcBitmap")
					m.loBitmap.Handle = m.lhBitmap
				ENDIF
		
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBitmap
	ENDFUNC


	*********************************************************************
	FUNCTION FromHicon
	*********************************************************************
	** Method: xfcBitmap.FromHicon
	**
	** Creates a Bitmap from a Windows handle to an icon.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.FromHicon%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hicon
	** Returns: Bitmap
	*********************************************************************
	LPARAMETERS tHIcon AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loBitmap, lhBitmap
			m.lhBitmap = 0
			m.loBitmap = NULL
			This.SetStatus(xfcGdipCreateBitmapFromHICON(m.tHicon, @lhBitmap))
		
			IF(m.lhBitmap <> 0)
				m.loBitmap = CREATEOBJECT("xfcBitmap")
				m.loBitmap.Handle = m.lhBitmap
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBitmap
	ENDFUNC


	*********************************************************************
	FUNCTION FromResource
	*********************************************************************
	** Method: xfcBitmap.FromResource
	**
	** Creates a Bitmap object from the specified Windows resource.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.FromResource%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hinstance, string bitmapName
	** Returns: Bitmap
	*********************************************************************
	LPARAMETERS tHInstance AS IntPtr, tcBitmapName
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loBitmap, lhBitmap
			m.lhBitmap = 0
			m.loBitmap = NULL
			This.SetStatus(xfcGdipCreateBitmapFromResource(m.tHInstance, STRCONV(m.tcBitmapName+0h00, 5), @lhBitmap))
		
			IF(m.lhBitmap <> 0)
				m.loBitmap = CREATEOBJECT("xfcBitmap")
				m.loBitmap.Handle = m.lhBitmap
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBitmap
	ENDFUNC


	*********************************************************************
	FUNCTION FromScreen
	*********************************************************************
	** Method: xfcBitmap.FromScreen
	**
	** Captures the window specified by the Hwnd
	**
	** History:
	**	2006/08/26: CChalom - Coded
	**	2007/11/26: CChalom - Added new overload allowing to capture a form object
	**  2013/03/10: DHennig - Fixed - http://vfpx.codeplex.com/workitem/27974
	*********************************************************************
	LPARAMETERS tHWnd, ;
					tiX, tiY, tiWidth, tiHeight, ;
					tlEnsureVisible
	*********** toForm [, tiX, tiY, tiWidth, tiHeight [, tlEnsureVisible]]
	*********** toControl [, tlEnsureVisible]
		
		*!ToDo: Test this function
		
		LOCAL lnLeft0, lnRight0, llMoved
		LOCAL loImage, lhImage, lhBitmap
		LOCAL lqRect, lnLeft, lnTop, lnRight, lnBottom, lnWidth, lnHeight
		LOCAL loForm as Form
		
		m.lhImage = 0
		m.loImage = NULL
		m.llMoved = .F.
		m.loForm = NULL
		
		LOCAL loExc AS Exception
		TRY
			
			DO CASE
			CASE VARTYPE(m.tHWnd) = "O" AND m.tHWnd.BaseClass = "Form"
				m.lnFunctionType = 2 && VFP Form
				m.loForm = m.tHWnd
				IF m.tlEnsureVisible
					IF m.loForm.Left < 0 OR m.loForm.Top < 0
						*!ToDo: Need to check if too far right also
						m.lnLeft0 = m.loForm.Left
						m.lnTop0 = m.loForm.Top
						m.loForm.Move(0,0)
						m.llMoved = .T.
					ENDIF
				ENDIF
				m.tHWnd = loForm.HWnd
				


			CASE VARTYPE(m.tHWnd) = "O" AND m.tHWnd.BaseClass <> "Form"

				LOCAL loControl as Control 
				m.loControl = m.tHWnd
				m.tlEnsureVisible = m.tiX
				
				m.lnFunctionType = 3 && VFP Object inside a form

				LOCAL lnTitleHeight, lnLeftBorder, lnTopBorder
				lnTitleHeight = SYSMETRIC(9)
				lnLeftBorder = SYSMETRIC(3)
				lnTopBorder = SYSMETRIC(4)

				m.tiY = This.OBJTOCLIENTEX(loControl, 1) + m.lnTitleHeight + m.lnTopBorder
				m.tiX = This.OBJTOCLIENTEX(loControl, 2) + m.lnLeftBorder 
				m.tiWidth = loControl.Width
				m.tiHeight = loControl.Height

				DO WHILE NOT UPPER(m.loControl.BaseClass) == [FORM]
					m.loControl = m.loControl.Parent
				ENDDO
				
				m.loForm = m.loControl
				m.tHWnd = m.loForm.HWnd

				IF m.tlEnsureVisible
					IF m.loForm.Left < 0 OR m.loForm.Top < 0
						*!ToDo: Need to check if too far right also
						m.lnLeft0 = m.loForm.Left
						m.lnTop0 = m.loForm.Top
						m.loForm.Move(0,0)
						m.llMoved = .T.
					ENDIF
				ENDIF

				
			CASE VARTYPE(m.tHWnd) <> "N"
				m.tHWnd = 0
				m.lnFunctionType = 1 && hWnd
			ENDCASE
			
			IF m.tHWnd = 0 && No parameter passed or zero, capture the whole Screen
				m.tHWnd = xfcGetDesktopWindow()
			ENDIF
		
		   	m.lqRect = EMPTY_RECTANGLE
		
		    m.lnStat = xfcGetWindowRect(m.tHWnd, @lqRect)
		   	m.lnLeft   = CTOBIN(SUBSTR(m.lqRect,  1, 4),"4rs")
		    m.lnTop    = CTOBIN(SUBSTR(m.lqRect,  5, 4),"4rs")
		   	m.lnRight  = CTOBIN(SUBSTR(m.lqRect,  9, 4),"4rs")
		    m.lnBottom = CTOBIN(SUBSTR(m.lqRect, 13, 4),"4rs")
			m.lnWidth  = m.lnRight - m.lnLeft
			m.lnHeight = m.lnBottom - m.lnTop

			*! ToDo: Need to check the position of the parent window, not just the desktop
			IF m.tlEnsureVisible AND ;
				(m.lnRight > SYSMETRIC(1) OR m.lnBottom > SYSMETRIC(2) OR m.lnLeft < 0 OR m.lnTop < 0)
		
				m.lnLeft0  = m.lnLeft
				m.lnTop0   = m.lnTop
				m.llMoved  = .T.
				=xfcMoveWindow(m.tHWnd, 0, 0, m.lnWidth, m.lnHeight, 1)
			    =xfcGetWindowRect(m.tHWnd, @lqRect)
			   	m.lnLeft   = CTOBIN(SUBSTR(m.lqRect,  1, 4),"4rs")
		    	m.lnTop    = CTOBIN(SUBSTR(m.lqRect,  5, 4),"4rs")
			ENDIF
		
		    LOCAL hdc, hbSave, hdcCompat, hbm
		    hdc = xfcGetWindowDC(m.tHWnd)
		
		    m.hdcCompat = xfcCreateCompatibleDC(hDC)
		    m.hbm = xfcCreateCompatibleBitmap(hDC, m.lnWidth, m.lnHeight)
		    m.hbSave = xfcSelectObject(hdcCompat,hbm)
		    m.xfcBitBlt(hdcCompat,0,0,m.lnWidth, m.lnHeight, hdc, 0, 0, SRCCOPY)
		    xfcSelectObject(m.hdcCompat, m.hbSave)
		
		    m.lhBitmap = 0
		 	This.SetStatus(xfcGdipCreateBitmapFromHBITMAP(m.hbm,0, @m.lhBitmap))
		
		 	IF VARTYPE(m.tiX)+VARTYPE(m.tiY)+VARTYPE(m.tiWidth)+VARTYPE(m.tiHeight)="NNNN"
		 		This.SetStatus(xfcGdipCloneBitmapAreaI(m.tiX, m.tiY, m.tiWidth, m.tiHeight, 0, m.lhBitmap, @lhImage))
			ELSE
				m.lhImage = m.lhBitmap
			ENDIF
		
			IF m.lhImage <> 0
				m.loImage = CREATEOBJECT("xfcBitmap")
				m.loImage.Handle = m.lhImage
			ENDIF
		
			xfcDeleteObject(hbm)
			xfcReleaseDC(m.tHWnd, m.hdcCompat)
			xfcReleaseDC(m.tHWnd, m.hDC)
			IF m.lhImage <> m.lhBitmap
				This.SetStatus(xfcGdipDisposeImage(m.lhBitmap))
			ENDIF
		
			IF m.llMoved && Restore Window to Original position
				IF NOT ISNULL(m.loForm)	&& VFP Form
					m.loForm.Move(m.lnLeft0, m.lnTop0)
				ELSE
					=xfcMoveWindow(tHWnd, m.lnLeft0, m.lnTop0, m.lnWidth, m.lnHeight, 1)
				ENDIF
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loImage
	ENDFUNC


	*********************************************************************
	FUNCTION ObjToClientEx
	*********************************************************************
	** Method: xfcBitmap.ObjToClientEx
	**
	** This replaces OBJTOCLIENT that has bugs with pageframes and SP2
	**
	** History:
	**	2007/11/26: CAlloatti/CChalom - Coded Made small adaptation from the original code from Carlos Alloatti in his CTL32SContainer
	*********************************************************************
	PARAMETERS toControl, tnType && 1 = Top  2 = Left

	*!* TabOrientation parameters
	#DEFINE CON_TABOR_TOP							0
	#DEFINE CON_TABOR_BOTTOM						1
	#DEFINE CON_TABOR_LEFT							2
	#DEFINE CON_TABOR_RIGHT							3

	LOCAL lnPosition AS INTEGER
	m.lnPosition = 0

	DO CASE

	CASE m.tnType = 1 && Top
		DO WHILE NOT UPPER(m.toControl.BASECLASS) == [FORM]
			IF PEMSTATUS(m.toControl, [Top],5) THEN && Defined Property
				m.lnPosition = m.lnPosition + m.toControl.TOP
			ENDIF
			IF UPPER(m.toControl.BASECLASS) == [PAGE] THEN
				IF m.toControl.PARENT.TABORIENTATION = CON_TABOR_TOP THEN	&& Top
					m.lnPosition = m.lnPosition + ;
						m.toControl.PARENT.HEIGHT - ;
						m.toControl.PARENT.PAGEHEIGHT - ;
						m.toControl.PARENT.BORDERWIDTH * 2
				ELSE
					m.lnPosition = m.lnPosition + 1
				ENDIF
			ENDIF
			m.toControl = m.toControl.PARENT
		ENDDO

	CASE m.tnType = 2 && Left
		DO WHILE NOT UPPER(m.toControl.BASECLASS) == [FORM]
			IF PEMSTATUS(m.toControl, [Left], 5) THEN && Defined Property
				m.lnPosition = m.lnPosition + m.toControl.LEFT
			ENDIF
			IF UPPER(m.toControl.BASECLASS) == [PAGE]
				IF m.toControl.PARENT.TABORIENTATION = CON_TABOR_LEFT THEN	&& Left
					m.lnPosition = m.lnPosition + ;
						m.toControl.PARENT.WIDTH - ;
						m.toControl.PARENT.PAGEWIDTH - ;
						m.toControl.PARENT.BORDERWIDTH * 2
				ELSE
					m.lnPosition = m.lnPosition + 1
				ENDIF
			ENDIF
			m.toControl = m.toControl.PARENT
		ENDDO

	ENDCASE

	RETURN m.lnPosition




	*********************************************************************
	FUNCTION GetHbitmap
	*********************************************************************
	** Method: xfcBitmap.GetHbitmap
	**
	** Creates a GDI bitmap object from a GDI+ Bitmap object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2007/01/15: CChalom - Added code to deal with no parameters
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.GetHbitmap%28vs.80%29.aspx
	** Parameters:
	**  [None]
	**  Color background
	** Returns: IntPtr
	*********************************************************************
	LPARAMETERS toBackground AS xfcColor
		
		*!ToDo: Test this function
		IF PCOUNT() = 0
			m.toBackground = CREATEOBJECT("xfcColor", ARGB_LightGray)
		ENDIF
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liPointer
			m.liPointer = 0
			This.SetStatus(xfcGdipCreateHBITMAPFromBitmap(This.Handle, @liPointer, toBackground.ARGB))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liPointer
	ENDFUNC


	*********************************************************************
	FUNCTION GetHicon
	*********************************************************************
	** Method: xfcBitmap.GetHicon
	**
	** Returns the handle to an icon.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.GetHicon%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: IntPtr
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liPointer
			m.liPointer = 0
			This.SetStatus(xfcGdipCreateHICONFromBitmap(This.Handle, @liPointer))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liPointer
	ENDFUNC


	*********************************************************************
	FUNCTION GetPixel
	*********************************************************************
	** Method: xfcBitmap.GetPixel
	**
	** Gets the color of the specified pixel in this Bitmap.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**  2006/08/07: CChalom - Fixed var name liColor -> liARGB
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.GetPixel%28vs.80%29.aspx
	** Parameters:
	**  int x, int y
	** Returns: Color
	*********************************************************************
	LPARAMETERS tiX, tiY
		
		*!ToDo: Test this function
		
		LOCAL loColor AS xfcColor, liArgb
		m.liArgb = 0
		m.loColor = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipBitmapGetPixel(This.Handle, m.tiX, m.tiY, @liARGB))
			m.loColor = CREATEOBJECT("xfcColor", m.liArgb)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION LockBits
	*********************************************************************
	** Method: xfcBitmap.LockBits
	**
	** Locks a Bitmap object into system memory.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.LockBits%28vs.80%29.aspx
	** Parameters:
	**  Rectangle rect, ImageLockMode flags, PixelFormat format
	** Returns: BitmapData
	*********************************************************************
	LPARAMETERS toRect AS xfcRectangle, tiFlags AS EnumImageLockMode, tiFormat AS EnumPixelFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loBitmapData AS xfcBitmapData, lqBitmapData
			m.lqBitmapData = REPLICATE(EMPTY_LONG,6)
			m.loBitmapData = NULL
			This.SetStatus(xfcGdipBitmapLockBits(This.Handle, toRect.ToVarBinary(), m.tiFlags, m.tiFormat, @lqBitmapData))
			m.loBitmapData = NEWOBJECT("xfcBitmapData", XFCCLASS_IMAGING, "", lqBitmapData)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBitmapData
	ENDFUNC


	*********************************************************************
	FUNCTION MakeTransparent
	*********************************************************************
	** Method: xfcBitmap.MakeTransparent
	**
	** Makes the default transparent color transparent for this Bitmap.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/13: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.MakeTransparent%28vs.80%29.aspx
	** Parameters:
	**  [None]
	**  Color transparentColor
	** Returns: void
	*********************************************************************
	LPARAMETERS toTransparentColor AS xfcColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL loBmp AS xfcBitmap
			LOCAL loGfx AS xfcGraphics
			LOCAL loAttr AS xfcImageAttributes
			LOCAL loBmpOrig AS xfcBitmap
			LOCAL loRect AS xfcRectangle
			m.loBmp = CREATEOBJECT(This.Class, This.Width, This.Height, PixelFormat32bppARGB)
			m.loGfx = CREATEOBJECT("xfcGraphics")
			m.loGfx = m.loGfx.FromImage(m.loBmp)
			m.loAttr = NEWOBJECT("xfcImageAttributes", XFCCLASS_IMAGING)
			m.loAttr.SetColorKey(m.toTransparentColor, m.toTransparentColor)
			m.loRect = CREATEOBJECT("xfcRectangle", 0, 0, This.Width, This.Height)
			
			m.loGfx.DrawImage(This, m.loRect, m.loRect, UnitPixel, m.loAttr)
				
			IF This.Handle <> 0
				This.Destroy()
				
				m.loBmpOrig = m.loBmp.Clone(m.loRect, m.loBmp.PixelFormat)
				This.Handle = m.loBmpOrig.Handle
				m.loBmpOrig.Handle = 0
			ENDIF
			
			m.loGfx = NULL
			m.loBmp = NULL
			m.loAttr = NULL
				
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ApplyColorMatrix
	*********************************************************************
	** Method: xfcBitmap.ApplyColorMatrix
	**
	** Aplies the recived ColorMatrix to the current image
	**
	** History:
	**	2007/11/21: CChalom - Coded
	**
	*********************************************************************
	LPARAMETERS toClrMatrix AS xfcColorMatrix, tiFormat AS EnumPixelFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			m.tiFormat = EVL(m.tiFormat, PixelFormat32bppARGB)
		
			LOCAL loBmp AS xfcBitmap
			LOCAL loGfx AS xfcGraphics
			LOCAL loAttr AS xfcImageAttributes
			LOCAL loBmpOrig AS xfcBitmap
			LOCAL loRect AS xfcRectangle
			m.loBmp = CREATEOBJECT(This.Class, This.Width, This.Height, m.tiFormat)
			m.loGfx = CREATEOBJECT("xfcGraphics")
			m.loGfx = m.loGfx.FromImage(m.loBmp)
			m.loGfx.Clear(CREATEOBJECT("xfcColor", ARGB_Transparent))
			m.loAttr = NEWOBJECT("xfcImageAttributes", XFCCLASS_IMAGING)
			m.loAttr.SetColorMatrix(m.toClrMatrix)
			m.loRect = CREATEOBJECT("xfcRectangle", 0, 0, This.Width, This.Height)
			
			m.loGfx.DrawImage(This, m.loRect, m.loRect, UnitPixel, m.loAttr)
				
			IF This.Handle <> 0
				This.Destroy()
				
				m.loBmpOrig = m.loBmp.Clone(m.loRect, m.loBmp.PixelFormat)
				This.Handle = m.loBmpOrig.Handle
				m.loBmpOrig.Handle = 0
			ENDIF
			
			m.loGfx = NULL
			m.loBmp = NULL
			m.loAttr = NULL
				
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FloodFill
	*********************************************************************
	** Method: xfcBitmap.FloodFill
	**
	** Fills an area of the current bitmap surface with the passed color
	**
	** Parameters
	**    [in]tnX - The x-coordinate, in logical units, of the point where filling is to start.
	**    [in]tnY - The y-coordinate, in logical units, of the point where filling is to start.
	**    [xfcColor]toColor or [in]RGB - The color of the boundary or of the area to be filled. The interpretation of crColor depends on the value of the fuFillType parameter.
	**    [in]FillType [in] - The type of fill operation to be performed. This parameter must be one of the following values.
	**           FLOODFILLBORDER (0) - The fill area is bounded by the color specified by the crColor parameter. This style is identical to the filling performed by the FloodFill function.
 	**           FOODFILLSURFACE (1) - The fill area is defined by the color that is specified by crColor. Filling continues outward in all directions as long as the color is encountered. This style is useful for filling areas with multicolored boundaries.
	**
	** Documentation on MSDN
	**    http://msdn.microsoft.com/en-us/library/windows/desktop/dd162709(v=vs.85).aspx
 	**
	** History:
	**	2013/03/11: CChalom - Coded
	**
	*********************************************************************

	#DEFINE FLOODFILLBORDER  0  && Fill until crColor& color encountered.
	#DEFINE FLOODFILLSURFACE 1  && Fill surface until crColor& color not encountered.

	LPARAMETERS tnX, tnY, toColor AS xfcColor, tiFillType
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			IF VARTYPE(m.tiFillType) <> "N"
				m.tiFillType = FLOODFILLSURFACE
			ENDIF 

			IF VARTYPE(m.toColor) = "O"
				LOCAL liColor as Integer 
				m.liColor = RGB(m.toColor.R, m.toColor.G, m.toColor.B)

			ELSE && Received RGB value
				m.liColor = m.toColor
			ENDIF 
		
			#DEFINE FF_SRCCOPY			0x00CC0020
			#DEFINE FF_RGBQUAD_SIZE     4
			#DEFINE FF_DIB_RGB_COLORS   0
			#DEFINE FF_BFHDR_SIZE      14
			#DEFINE FF_BHDR_SIZE       40
			#DEFINE FF_BI_RGB           0

			LOCAL lnSrcDC, lnDstDC
			m.lnSrcDC = xfcCreateCompatibleDC(0)
			m.lnDstDC = xfcCreateCompatibleDC(0)

			LOCAL lnWidth, lnHeight, lnBitsPerPixel, lcDstBMI
			m.lnWidth  = This.Width
			m.lnHeight = This.Height
			m.lnBitsPerPixel = This.GetPixelFormatSize(This.PixelFormat)
			m.lcDstBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(m.lnWidth,"4RS") + BINTOC(m.lnHeight, "4RS") + ;
				(CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(m.lnBitsPerPixel,256))+ CHR(INT(m.lnBitsPerPixel/256))) +;
				BINTOC(FF_BI_RGB, "4RS") + REPLI(0h00, 20)

			LOCAL lnHBitmap, loGDIBmp1, loGDIBmp2, lnDstBits, lnDstHBitmap, loGDIBrush, lhBrush
			m.lnHBitmap    = This.GetHbitmap()
			m.loGDIBmp1    = xfcSelectObject(m.lnSrcDC, m.lnHBitmap)
			m.lnDstBits    = 0
			
			m.lnDstHBitmap = xfcCreateDIBSection(m.lnDstDC, @lcDstBMI, 0, @lnDstbits, 0, 0)
			m.loGDIBmp2    = xfcSelectObject(lnDstDC, lnDstHBitmap)
			xfcBitBlt(m.lnDstDC, 0, 0, m.lnWidth, m.lnHeight, m.lnSrcDC, 0, 0, FF_SRCCOPY)
			xfcGdiFlush()
 
			m.lhBrush      = xfcCreateSolidBrush(m.liColor)
			m.loGDIBrush   = xfcSelectObject(m.lnDstDC, m.lhBrush)

			* Fill the object
			=xfcExtFloodFill(m.lnDstDC, m.tnX, m.tnY, xfcGetPixel(m.lnDstDC, m.tnX, m.tnY), m.tiFillType)

			IF This.Handle <> 0
				This.Destroy()
			    m.lhBitmap = 0
			 	This.SetStatus(xfcGdipCreateBitmapFromHBITMAP(m.lnDstHBitmap,0, @m.lhBitmap))
				This.Handle = m.lhBitmap
			ENDIF
			
			* Cleaning up
			xfcDeleteObject(m.lhBrush)
			xfcDeleteObject(xfcSelectObject(m.lnDstDC, m.lhBrush))
			xfcDeleteObject(xfcSelectObject(m.lnDstDC, m.lnDstHBitmap))
			xfcDeleteObject(xfcSelectObject(m.lnSrcDC, m.lnHBitmap))
			xfcDeleteObject(m.loGDIBrush)
			xfcDeleteObject(m.lnDstBits)
			xfcDeleteObject(m.loGDIBmp2)
			xfcDeleteObject(m.loGDIBmp1)
			xfcDeleteObject(m.lnDstHBitmap)
			xfcDeleteDC(m.lnDstDC)
			xfcDeleteDC(m.lnSrcDC)

		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GetMask
	*********************************************************************
	** Method: xfcBitmap.GetMask
	**
	** Provides the Mask bitmap from the current image
	**
	** History:
	**	2007/11/22: CChalom - Coded
	**
	*********************************************************************
	LPARAMETERS tiFormat AS EnumPixelFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL lnBitsPerPixel
			lnBitsPerPixel = This.GetPixelFormatSize(This.PixelFormat)

			LOCAL loMaskBmp as xfcBitmap
			m.tiFormat = EVL(m.tiFormat, PixelFormat24bppRGB)

			IF lnBitsPerPixel = 32 && Has alpha enabled

				m.loMaskBmp = This.Clone()

				LOCAL loMaskMatrix as xfcColorMatrix
				m.loMaskMatrix = NEWOBJECT("xfcColorMatrix", XFCCLASS_IMAGING)
				m.loMaskMatrix = m.loMaskMatrix.New( ;
					 0, 0, 0, 0, 0, ;
					 0, 0, 0, 0, 0, ;
					 0, 0, 0, 0, 0, ;
					-1,-1,-1, 1, 0, ;
					 0, 0, 0, 0, 1)

				m.loMaskBmp.ApplyColorMatrix(m.loMaskMatrix, m.tiFormat)
				m.loMaskMatrix = NULL
				
			ELSE 
			
				LOCAL loGfx AS xfcGraphics
				LOCAL loAttr AS xfcImageAttributes
				LOCAL loRect AS xfcRectangle
				LOCAL loClrMatrix as xfcColorMatrix
				m.loMaskBmp = CREATEOBJECT(This.Class, This.Width, This.Height, PixelFormat24bppRGB)
				m.loGfx = CREATEOBJECT("xfcGraphics")
				m.loGfx = m.loGfx.FromImage(m.loMaskBmp)
				m.loGfx.Clear(CREATEOBJECT("xfcColor", ARGB_White))
				m.loAttr = NEWOBJECT("xfcImageAttributes", XFCCLASS_IMAGING)
				m.loClrMatrix = NEWOBJECT("xfcColorMatrix", XFCCLASS_IMAGING)
				m.loClrMatrix = m.loClrMatrix.New( ;
					0.2, 0.2, 0.2, 0, 0, ;
					0.2, 0.2, 0.2, 0, 0, ;
					0.1, 0.1, 0.1, 0, 0, ;
					0.0, 0.0, 0.0, 1, 0, ;
					0.0, 0.0, 0.0, 0, 1)
				m.loAttr.SetColorMatrix(m.loClrMatrix)

				*!* Set the Threshold to 0.5, that will make all non-white pixels turn black
				*!* In our case will turn all less RGB(128,128,128) pixels to black, and RGB(128,128,128) to white
				m.loAttr.SetThreshold(0.5)

				m.loRect = CREATEOBJECT("xfcRectangle", 0, 0, This.Width, This.Height)
			
				m.loGfx.DrawImage(This, m.loRect, m.loRect, UnitPixel, m.loAttr)
					
			ENDIF 
	
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loMaskBmp
	ENDFUNC



	*********************************************************************
	FUNCTION SetPixel
	*********************************************************************
	** Method: xfcBitmap.SetPixel
	**
	** Sets the color of the specified pixel in this Bitmap object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.SetPixel%28vs.80%29.aspx
	** Parameters:
	**  int x, int y, Color color
	** Returns: void
	*********************************************************************
	LPARAMETERS tiX, tiY, toColor AS xfcColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipBitmapSetPixel(This.Handle, m.tiX, m.tiY, m.toColor.Argb))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION SetResolution
	*********************************************************************
	** Method: xfcBitmap.SetResolution
	**
	** Sets the resolution for this Bitmap.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/10: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.SetResolution%28vs.80%29.aspx
	** Parameters:
	**  float xDpi, float yDpi
	** Returns: void
	*********************************************************************
	LPARAMETERS tnXDpi, tnYDpi
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipBitmapSetResolution(This.Handle, m.tnXdpi, m.tnYdpi))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ToClipboard
	*********************************************************************
	** Method: xfcBitmap.ToClipboard
	**
	** Sends the Image to the clipboard
	**
	** History:
	**  2007/01/17: CChalom - Coded (Adapted from ToClipboard Method from GPIMAGE from Alexander Golovlev)
	*********************************************************************
		
	LPARAMETERS toImage AS xfcImage
		
		*!ToDo: Test this function
		
		*-- Predefined Clipboard Formats
		#DEFINE ERR_CLIPNOTOPEN "Cannot open the clipboard"
		#DEFINE ERR_CLIPNODATA  "No bitmap data found on the clipboard"
		#DEFINE ERR_CLIPSETDATA "Cannot place data on the clipboard"
		
		#DEFINE CF_BITMAP    2
		#DEFINE CF_PALETTE   9
		#DEFINE OBJ_BITMAP   7
		
		LOCAL lhBitmap, lhBmp, lnStatus
		
		LOCAL loExc AS Exception
		TRY
		
			m.lhBitmap = This.GetHbitmap(CREATEOBJECT("xfcColor", ARGB_LightGray))
			m.lhBmp = xfcCopyImage(lhBitmap, 0, 0, 0, 0)
			xfcDeleteObject(lhBitmap)
		
			IF xfcOpenClipboard(0) != 0
				xfcEmptyClipboard()
				m.lnStatus = xfcSetClipboardData(CF_BITMAP, m.lhBmp)
				xfcCloseClipboard()
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION UnlockBits
	*********************************************************************
	** Method: xfcBitmap.UnlockBits
	**
	** Unlocks this Bitmap from system memory.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Bitmap.UnlockBits%28vs.80%29.aspx
	** Parameters:
	**  BitmapData bitmapdata
	** Returns: void
	*********************************************************************
	LPARAMETERS toBitmapdata AS xfcBitmapData
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			This.SetStatus(xfcGdipBitmapUnlockBits(This.Handle, toBitmapdata.ToVarBinary()))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="fromhicon" type="method" display="FromHicon"/>]+;
		[<memberdata name="fromresource" type="method" display="FromResource"/>]+;
		[<memberdata name="getbounds" type="method" display="GetBounds"/>]+;
		[<memberdata name="getencoderparameterlist" type="method" display="GetEncoderParameterList"/>]+;
		[<memberdata name="getframecount" type="method" display="GetFrameCount"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gethbitmap" type="method" display="GetHbitmap"/>]+;
		[<memberdata name="gethicon" type="method" display="GetHicon"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="getpixel" type="method" display="GetPixel"/>]+;
		[<memberdata name="getpropertyitem" type="method" display="GetPropertyItem"/>]+;
		[<memberdata name="getthumbnailimage" type="method" display="GetThumbnailImage"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="lockbits" type="method" display="LockBits"/>]+;
		[<memberdata name="maketransparent" type="method" display="MakeTransparent"/>]+;
		[<memberdata name="removepropertyitem" type="method" display="RemovePropertyItem"/>]+;
		[<memberdata name="rotateflip" type="method" display="RotateFlip"/>]+;
		[<memberdata name="save" type="method" display="Save"/>]+;
		[<memberdata name="saveadd" type="method" display="SaveAdd"/>]+;
		[<memberdata name="selectactiveframe" type="method" display="SelectActiveFrame"/>]+;
		[<memberdata name="setpixel" type="method" display="SetPixel"/>]+;
		[<memberdata name="setpropertyitem" type="method" display="SetPropertyItem"/>]+;
		[<memberdata name="setresolution" type="method" display="SetResolution"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="unlockbits" type="method" display="UnlockBits"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="flags" type="property" display="Flags"/>]+;
		[<memberdata name="framedimensionslist" type="property" display="FrameDimensionsList"/>]+;
		[<memberdata name="height" type="property" display="Height"/>]+;
		[<memberdata name="horizontalresolution" type="property" display="HorizontalResolution"/>]+;
		[<memberdata name="palette" type="property" display="Palette"/>]+;
		[<memberdata name="physicaldimension" type="property" display="PhysicalDimension"/>]+;
		[<memberdata name="pixelformat" type="property" display="PixelFormat"/>]+;
		[<memberdata name="propertyidlist" type="property" display="PropertyIdList"/>]+;
		[<memberdata name="propertyitems" type="property" display="PropertyItems"/>]+;
		[<memberdata name="rawformat" type="property" display="RawFormat"/>]+;
		[<memberdata name="size" type="property" display="Size"/>]+;
		[<memberdata name="verticalresolution" type="property" display="VerticalResolution"/>]+;
		[<memberdata name="width" type="property" display="Width"/>]+;
		[<memberdata name="new" type="method" display="New"/>]+;
		[<memberdata name="fromscreen" type="method" display="FromScreen"/>]+;
		[<memberdata name="toclipboard" type="method" display="ToClipboard"/>]+;
		[<memberdata name="toprinter" type="method" display="ToPrinter"/>]+;
		[<memberdata name="fromclipboard" type="method" display="FromClipboard"/>]+;
		[<memberdata name="getmask" type="method" display="GetMask"/>]+;
		[<memberdata name="applycolormatrix" type="method" display="ApplyColorMatrix"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCBRUSH
DEFINE CLASS xfcBrush AS xfcgpobject
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Brush"
	lastresult = 0
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcBrush.Brush
	**
	** Classes derived from this abstract base class define objects used to fill the interiors
	** of graphical shapes such as rectangles, ellipses, pies, polygons, and paths.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Brush%28vs.80%29.aspx
	** Parameters:
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcBrush.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2006/08/25: BDurban - Modified to check handle value
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This.Handle <> 0
				This.SetStatus(xfcGdipDeleteBrush(This.Handle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcBrush.Clone
	**
	** When overridden in a derived class, creates an exact copy of this Brush object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/03/07: BDurban - Coded
	**  2006/08/26: BDurban - Fixed return variable
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Brush.Clone%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: abstract
	*********************************************************************
		
		*!ToDo: Test this function
		LOCAL loBrush, lhBrush
		m.lhBrush = 0
		m.loBrush = NULL
		
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipCloneBrush(This.Handle, @lhBrush))
			IF(m.lhBrush <> 0)
				m.loBrush = CREATEOBJECT(This.Class)
				m.loBrush.Handle = m.lhBrush
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBrush
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCBRUSHES
DEFINE CLASS xfcBrushes AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	AliceBlue = .NULL.	&& Gets a system defined Brush object
	AntiqueWhite = .NULL.	&& Gets a system defined Brush object
	Aqua = .NULL.	&& Gets a system defined Brush object
	Aquamarine = .NULL.	&& Gets a system defined Brush object
	Azure = .NULL.	&& Gets a system defined Brush object
	BaseName = "Brushes"
	Beige = .NULL.	&& Gets a system defined Brush object
	Bisque = .NULL.	&& Gets a system defined Brush object
	Black = .NULL.	&& Gets a system defined Brush object
	BlanchedAlmond = .NULL.	&& Gets a system defined Brush object
	Blue = .NULL.	&& Gets a system defined Brush object
	BlueViolet = .NULL.	&& Gets a system defined Brush object
	Brown = .NULL.	&& Gets a system defined Brush object
	BurlyWood = .NULL.	&& Gets a system defined Brush object
	CadetBlue = .NULL.	&& Gets a system defined Brush object
	Chartreuse = .NULL.	&& Gets a system defined Brush object
	Chocolate = .NULL.	&& Gets a system defined Brush object
	Coral = .NULL.	&& Gets a system defined Brush object
	CornflowerBlue = .NULL.	&& Gets a system defined Brush object
	Cornsilk = .NULL.	&& Gets a system defined Brush object
	Crimson = .NULL.	&& Gets a system defined Brush object
	Cyan = .NULL.	&& Gets a system defined Brush object
	DarkBlue = .NULL.	&& Gets a system defined Brush object
	DarkCyan = .NULL.	&& Gets a system defined Brush object
	DarkGoldenrod = .NULL.	&& Gets a system defined Brush object
	DarkGray = .NULL.	&& Gets a system defined Brush object
	DarkGreen = .NULL.	&& Gets a system defined Brush object
	DarkKhaki = .NULL.	&& Gets a system defined Brush object
	DarkMagenta = .NULL.	&& Gets a system defined Brush object
	DarkOliveGreen = .NULL.	&& Gets a system defined Brush object
	DarkOrange = .NULL.	&& Gets a system defined Brush object
	DarkOrchid = .NULL.	&& Gets a system defined Brush object
	DarkRed = .NULL.	&& Gets a system defined Brush object
	DarkSalmon = .NULL.	&& Gets a system defined Brush object
	DarkSeaGreen = .NULL.	&& Gets a system defined Brush object
	DarkSlateBlue = .NULL.	&& Gets a system defined Brush object
	DarkSlateGray = .NULL.	&& Gets a system defined Brush object
	DarkTurquoise = .NULL.	&& Gets a system defined Brush object
	DarkViolet = .NULL.	&& Gets a system defined Brush object
	DeepPink = .NULL.	&& Gets a system defined Brush object
	DeepSkyBlue = .NULL.	&& Gets a system defined Brush object
	DimGray = .NULL.	&& Gets a system defined Brush object
	DodgerBlue = .NULL.	&& Gets a system defined Brush object
	Firebrick = .NULL.	&& Gets a system defined Brush object
	FloralWhite = .NULL.	&& Gets a system defined Brush object
	ForestGreen = .NULL.	&& Gets a system defined Brush object
	Fuchsia = .NULL.	&& Gets a system defined Brush object
	Gainsboro = .NULL.	&& Gets a system defined Brush object
	GhostWhite = .NULL.	&& Gets a system defined Brush object
	Gold = .NULL.	&& Gets a system defined Brush object
	Goldenrod = .NULL.	&& Gets a system defined Brush object
	Gray = .NULL.	&& Gets a system defined Brush object
	Green = .NULL.	&& Gets a system defined Brush object
	GreenYellow = .NULL.	&& Gets a system defined Brush object
	Honeydew = .NULL.	&& Gets a system defined Brush object
	HotPink = .NULL.	&& Gets a system defined Brush object
	IndianRed = .NULL.	&& Gets a system defined Brush object
	Indigo = .NULL.	&& Gets a system defined Brush object
	Ivory = .NULL.	&& Gets a system defined Brush object
	Khaki = .NULL.	&& Gets a system defined Brush object
	Lavender = .NULL.	&& Gets a system defined Brush object
	LavenderBlush = .NULL.	&& Gets a system defined Brush object
	LawnGreen = .NULL.	&& Gets a system defined Brush object
	LemonChiffon = .NULL.	&& Gets a system defined Brush object
	LightBlue = .NULL.	&& Gets a system defined Brush object
	LightCoral = .NULL.	&& Gets a system defined Brush object
	LightCyan = .NULL.	&& Gets a system defined Brush object
	LightGoldenrodYellow = .NULL.
	** Gets a system defined Brush object
	LightGray = .NULL.	&& Gets a system defined Brush object
	LightGreen = .NULL.	&& Gets a system defined Brush object
	LightPink = .NULL.	&& Gets a system defined Brush object
	LightSalmon = .NULL.	&& Gets a system defined Brush object
	LightSeaGreen = .NULL.	&& Gets a system defined Brush object
	LightSkyBlue = .NULL.	&& Gets a system defined Brush object
	LightSlateGray = .NULL.	&& Gets a system defined Brush object
	LightSteelBlue = .NULL.	&& Gets a system defined Brush object
	LightYellow = .NULL.	&& Gets a system defined Brush object
	Lime = .NULL.	&& Gets a system defined Brush object
	LimeGreen = .NULL.	&& Gets a system defined Brush object
	Linen = .NULL.	&& Gets a system defined Brush object
	Magenta = .NULL.	&& Gets a system defined Brush object
	Maroon = .NULL.	&& Gets a system defined Brush object
	MediumAquamarine = .NULL.	&& Gets a system defined Brush object
	MediumBlue = .NULL.	&& Gets a system defined Brush object
	MediumOrchid = .NULL.	&& Gets a system defined Brush object
	MediumPurple = .NULL.	&& Gets a system defined Brush object
	MediumSeaGreen = .NULL.	&& Gets a system defined Brush object
	MediumSlateBlue = .NULL.	&& Gets a system defined Brush object
	MediumSpringGreen = .NULL.
	** Gets a system defined Brush object
	MediumTurquoise = .NULL.	&& Gets a system defined Brush object
	MediumVioletRed = .NULL.	&& Gets a system defined Brush object
	MidnightBlue = .NULL.	&& Gets a system defined Brush object
	MintCream = .NULL.	&& Gets a system defined Brush object
	MistyRose = .NULL.	&& Gets a system defined Brush object
	Moccasin = .NULL.	&& Gets a system defined Brush object
	NavajoWhite = .NULL.	&& Gets a system defined Brush object
	Navy = .NULL.	&& Gets a system defined Brush object
	OldLace = .NULL.	&& Gets a system defined Brush object
	Olive = .NULL.	&& Gets a system defined Brush object
	OliveDrab = .NULL.	&& Gets a system defined Brush object
	Orange = .NULL.	&& Gets a system defined Brush object
	OrangeRed = .NULL.	&& Gets a system defined Brush object
	Orchid = .NULL.	&& Gets a system defined Brush object
	PaleGoldenrod = .NULL.	&& Gets a system defined Brush object
	PaleGreen = .NULL.	&& Gets a system defined Brush object
	PaleTurquoise = .NULL.	&& Gets a system defined Brush object
	PaleVioletRed = .NULL.	&& Gets a system defined Brush object
	PapayaWhip = .NULL.	&& Gets a system defined Brush object
	PeachPuff = .NULL.	&& Gets a system defined Brush object
	Peru = .NULL.	&& Gets a system defined Brush object
	Pink = .NULL.	&& Gets a system defined Brush object
	Plum = .NULL.	&& Gets a system defined Brush object
	PowderBlue = .NULL.	&& Gets a system defined Brush object
	Purple = .NULL.	&& Gets a system defined Brush object
	Red = .NULL.	&& Gets a system defined Brush object
	RosyBrown = .NULL.	&& Gets a system defined Brush object
	RoyalBlue = .NULL.	&& Gets a system defined Brush object
	SaddleBrown = .NULL.	&& Gets a system defined Brush object
	Salmon = .NULL.	&& Gets a system defined Brush object
	SandyBrown = .NULL.	&& Gets a system defined Brush object
	SeaGreen = .NULL.	&& Gets a system defined Brush object
	SeaShell = .NULL.	&& Gets a system defined Brush object
	Sienna = .NULL.	&& Gets a system defined Brush object
	Silver = .NULL.	&& Gets a system defined Brush object
	SkyBlue = .NULL.	&& Gets a system defined Brush object
	SlateBlue = .NULL.	&& Gets a system defined Brush object
	SlateGray = .NULL.	&& Gets a system defined Brush object
	Snow = .NULL.	&& Gets a system defined Brush object
	SpringGreen = .NULL.	&& Gets a system defined Brush object
	SteelBlue = .NULL.	&& Gets a system defined Brush object
	Tan = .NULL.	&& Gets a system defined Brush object
	Teal = .NULL.	&& Gets a system defined Brush object
	Thistle = .NULL.	&& Gets a system defined Brush object
	Tomato = .NULL.	&& Gets a system defined Brush object
	Transparent = .NULL.	&& Gets a system defined Brush object
	Turquoise = .NULL.	&& Gets a system defined Brush object
	Violet = .NULL.	&& Gets a system defined Brush object
	Wheat = .NULL.	&& Gets a system defined Brush object
	White = .NULL.	&& Gets a system defined Brush object
	WhiteSmoke = .NULL.	&& Gets a system defined Brush object
	Yellow = .NULL.	&& Gets a system defined Brush object
	YellowGreen = .NULL.	&& Gets a system defined Brush object

	#IFDEF USE_MEMBERDATA
	_Memberdata = ""	
	#ENDIF
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcBrushes.Brushes
	**
	** Brushes for all the standard colors. This class cannot be inherited.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/04: BDurban - Coded
	**  2006/08/26: BDurban - Added memberdata
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Brushes%28vs.80%29.aspx
	** Parameters:
		
	*********************************************************************
		
		*!ToDo: Test this function
		
		DODEFAULT()
		
		#IFDEF USE_MEMBERDATA
			This._memberdata = [<VFPData>]+;
				[<memberdata name="aliceblue" display="AliceBlue"/>]+;
				[<memberdata name="antiquewhite" display="AntiqueWhite"/>]+;
				[<memberdata name="aqua" display="Aqua"/>]+;
				[<memberdata name="aquamarine" display="Aquamarine"/>]+;
				[<memberdata name="azure" display="Azure"/>]+;
				[<memberdata name="beige" display="Beige"/>]+;
				[<memberdata name="bisque" display="Bisque"/>]+;
				[<memberdata name="black" display="Black"/>]+;
				[<memberdata name="blanchedalmond" display="BlanchedAlmond"/>]+;
				[<memberdata name="blue" display="Blue"/>]+;
				[<memberdata name="blueviolet" display="BlueViolet"/>]+;
				[<memberdata name="brown" display="Brown"/>]+;
				[<memberdata name="burlywood" display="BurlyWood"/>]+;
				[<memberdata name="cadetblue" display="CadetBlue"/>]+;
				[<memberdata name="chartreuse" display="Chartreuse"/>]+;
				[<memberdata name="chocolate" display="Chocolate"/>]+;
				[<memberdata name="coral" display="Coral"/>]+;
				[<memberdata name="cornflowerblue" display="CornflowerBlue"/>]+;
				[<memberdata name="cornsilk" display="Cornsilk"/>]+;
				[<memberdata name="crimson" display="Crimson"/>]+;
				[<memberdata name="cyan" display="Cyan"/>]+;
				[<memberdata name="darkblue" display="DarkBlue"/>]+;
				[<memberdata name="darkcyan" display="DarkCyan"/>]+;
				[<memberdata name="darkgoldenrod" display="DarkGoldenrod"/>]+;
				[<memberdata name="darkgray" display="DarkGray"/>]+;
				[<memberdata name="darkgreen" display="DarkGreen"/>]+;
				[<memberdata name="darkkhaki" display="DarkKhaki"/>]+;
				[<memberdata name="darkmagenta" display="DarkMagenta"/>]+;
				[<memberdata name="darkolivegreen" display="DarkOliveGreen"/>]+;
				[<memberdata name="darkorange" display="DarkOrange"/>]+;
				[<memberdata name="darkorchid" display="DarkOrchid"/>]+;
				[<memberdata name="darkred" display="DarkRed"/>]+;
				[<memberdata name="darksalmon" display="DarkSalmon"/>]+;
				[<memberdata name="darkseagreen" display="DarkSeaGreen"/>]+;
				[<memberdata name="darkslateblue" display="DarkSlateBlue"/>]+;
				[<memberdata name="darkslategray" display="DarkSlateGray"/>]+;
				[<memberdata name="darkturquoise" display="DarkTurquoise"/>]+;
				[<memberdata name="darkviolet" display="DarkViolet"/>]+;
				[<memberdata name="deeppink" display="DeepPink"/>]+;
				[<memberdata name="deepskyblue" display="DeepSkyBlue"/>]+;
				[<memberdata name="dimgray" display="DimGray"/>]+;
				[<memberdata name="dodgerblue" display="DodgerBlue"/>]+;
				[<memberdata name="firebrick" display="Firebrick"/>]+;
				[<memberdata name="floralwhite" display="FloralWhite"/>]+;
				[<memberdata name="forestgreen" display="ForestGreen"/>]+;
				[<memberdata name="fuchsia" display="Fuchsia"/>]+;
				[<memberdata name="gainsboro" display="Gainsboro"/>]+;
				[<memberdata name="ghostwhite" display="GhostWhite"/>]+;
				[<memberdata name="gold" display="Gold"/>]+;
				[<memberdata name="goldenrod" display="Goldenrod"/>]+;
				[<memberdata name="gray" display="Gray"/>]+;
				[<memberdata name="green" display="Green"/>]+;
				[<memberdata name="greenyellow" display="GreenYellow"/>]+;
				[<memberdata name="honeydew" display="Honeydew"/>]+;
				[<memberdata name="hotpink" display="HotPink"/>]+;
				[<memberdata name="indianred" display="IndianRed"/>]+;
				[<memberdata name="indigo" display="Indigo"/>]+;
				[<memberdata name="ivory" display="Ivory"/>]+;
				[<memberdata name="khaki" display="Khaki"/>]+;
				[<memberdata name="lavender" display="Lavender"/>]+;
				[<memberdata name="lavenderblush" display="LavenderBlush"/>]+;
				[<memberdata name="lawngreen" display="LawnGreen"/>]+;
				[<memberdata name="lemonchiffon" display="LemonChiffon"/>]+;
				[<memberdata name="lightblue" display="LightBlue"/>]+;
				[<memberdata name="lightcoral" display="LightCoral"/>]+;
				[<memberdata name="lightcyan" display="LightCyan"/>]+;
				[<memberdata name="lightgoldenrodyellow" display="LightGoldenrodYellow"/>]+;
				[<memberdata name="lightgray" display="LightGray"/>]+;
				[<memberdata name="lightgreen" display="LightGreen"/>]+;
				[<memberdata name="lightpink" display="LightPink"/>]+;
				[<memberdata name="lightsalmon" display="LightSalmon"/>]+;
				[<memberdata name="lightseagreen" display="LightSeaGreen"/>]+;
				[<memberdata name="lightskyblue" display="LightSkyBlue"/>]+;
				[<memberdata name="lightslategray" display="LightSlateGray"/>]+;
				[<memberdata name="lightsteelblue" display="LightSteelBlue"/>]+;
				[<memberdata name="lightyellow" display="LightYellow"/>]+;
				[<memberdata name="lime" display="Lime"/>]+;
				[<memberdata name="limegreen" display="LimeGreen"/>]+;
				[<memberdata name="linen" display="Linen"/>]+;
				[<memberdata name="magenta" display="Magenta"/>]+;
				[<memberdata name="maroon" display="Maroon"/>]+;
				[<memberdata name="mediumaquamarine" display="MediumAquamarine"/>]+;
				[<memberdata name="mediumblue" display="MediumBlue"/>]+;
				[<memberdata name="mediumorchid" display="MediumOrchid"/>]+;
				[<memberdata name="mediumpurple" display="MediumPurple"/>]+;
				[<memberdata name="mediumseagreen" display="MediumSeaGreen"/>]+;
				[<memberdata name="mediumslateblue" display="MediumSlateBlue"/>]+;
				[<memberdata name="mediumspringgreen" display="MediumSpringGreen"/>]+;
				[<memberdata name="mediumturquoise" display="MediumTurquoise"/>]+;
				[<memberdata name="mediumvioletred" display="MediumVioletRed"/>]+;
				[<memberdata name="midnightblue" display="MidnightBlue"/>]+;
				[<memberdata name="mintcream" display="MintCream"/>]+;
				[<memberdata name="mistyrose" display="MistyRose"/>]+;
				[<memberdata name="moccasin" display="Moccasin"/>]+;
				[<memberdata name="navajowhite" display="NavajoWhite"/>]+;
				[<memberdata name="navy" display="Navy"/>]+;
				[<memberdata name="oldlace" display="OldLace"/>]+;
				[<memberdata name="olive" display="Olive"/>]+;
				[<memberdata name="olivedrab" display="OliveDrab"/>]+;
				[<memberdata name="orange" display="Orange"/>]+;
				[<memberdata name="orangered" display="OrangeRed"/>]+;
				[<memberdata name="orchid" display="Orchid"/>]+;
				[<memberdata name="palegoldenrod" display="PaleGoldenrod"/>]+;
				[<memberdata name="palegreen" display="PaleGreen"/>]+;
				[<memberdata name="paleturquoise" display="PaleTurquoise"/>]+;
				[<memberdata name="palevioletred" display="PaleVioletRed"/>]+;
				[<memberdata name="papayawhip" display="PapayaWhip"/>]+;
				[<memberdata name="peachpuff" display="PeachPuff"/>]+;
				[<memberdata name="peru" display="Peru"/>]+;
				[<memberdata name="pink" display="Pink"/>]+;
				[<memberdata name="plum" display="Plum"/>]+;
				[<memberdata name="powderblue" display="PowderBlue"/>]+;
				[<memberdata name="purple" display="Purple"/>]+;
				[<memberdata name="red" display="Red"/>]+;
				[<memberdata name="rosybrown" display="RosyBrown"/>]+;
				[<memberdata name="royalblue" display="RoyalBlue"/>]+;
				[<memberdata name="saddlebrown" display="SaddleBrown"/>]+;
				[<memberdata name="salmon" display="Salmon"/>]+;
				[<memberdata name="sandybrown" display="SandyBrown"/>]+;
				[<memberdata name="seagreen" display="SeaGreen"/>]+;
				[<memberdata name="seashell" display="SeaShell"/>]+;
				[<memberdata name="sienna" display="Sienna"/>]+;
				[<memberdata name="silver" display="Silver"/>]+;
				[<memberdata name="skyblue" display="SkyBlue"/>]+;
				[<memberdata name="slateblue" display="SlateBlue"/>]+;
				[<memberdata name="slategray" display="SlateGray"/>]+;
				[<memberdata name="snow" display="Snow"/>]+;
				[<memberdata name="springgreen" display="SpringGreen"/>]+;
				[<memberdata name="steelblue" display="SteelBlue"/>]+;
				[<memberdata name="tan" display="Tan"/>]+;
				[<memberdata name="teal" display="Teal"/>]+;
				[<memberdata name="thistle" display="Thistle"/>]+;
				[<memberdata name="tomato" display="Tomato"/>]+;
				[<memberdata name="transparent" display="Transparent"/>]+;
				[<memberdata name="turquoise" display="Turquoise"/>]+;
				[<memberdata name="violet" display="Violet"/>]+;
				[<memberdata name="wheat" display="Wheat"/>]+;
				[<memberdata name="white" display="White"/>]+;
				[<memberdata name="whitesmoke" display="WhiteSmoke"/>]+;
				[<memberdata name="yellow" display="Yellow"/>]+;
				[<memberdata name="yellowgreen" display="YellowGreen"/>]+;
				[</VFPData>]
		#ENDIF
		
		RETURN
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION This_ACCESS
	*********************************************************************
	LPARAMETERS tcMember
		
		IF VARTYPE(m.tcMember)="C" ;
				AND PEMSTATUS(This,m.tcMember,5) ;
				AND PEMSTATUS(This,m.tcMember,3)="Property" ;
				AND ISNULL(This.&tcMember)
			LOCAL loColor
			m.loColor = _SCREEN.GdipToken.KnownColorTable.NameToKnownColor(tcMember)
			IF VARTYPE(m.loColor) = "O"
				This.&tcMember = CREATEOBJECT("xfcSolidBrush",m.loColor,.T.)
			ENDIF
		ENDIF
		
		RETURN This
	ENDFUNC





ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCCHARACTERRANGE
DEFINE CLASS xfcCharacterRange AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "CharacterRange"
	First = 0	&& Gets or sets the position in the string of the first character of this CharacterRange.
	Length = 0	&& Gets or sets the number of positions in this CharacterRange.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcCharacterRange.CharacterRange
	**
	** Initializes a new instance of the CharacterRange structure, specifying a range of
	** character positions within a string.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11; BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.CharacterRange.CharacterRange%28vs.80%29.aspx
	** Parameters:
	**  int First, int Length
	*********************************************************************
	LPARAMETERS tiFirst, tiLength
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lqStruct
			DODEFAULT()
			
			DO CASE
			CASE INLIST(VARTYPE(m.tiFirst),"C","Q")	&& Binary
				m.lqStruct = m.tiFirst
				This.First = CTOBIN(SUBSTR(m.lqStruct,1,4),"4rs")
				This.Length = CTOBIN(SUBSTR(m.lqStruct,5,4),"4rs")
				
			CASE VARTYPE(m.tiFirst)+VARTYPE(m.tiLength) == "NN"
				This.First = m.tiFirst
				This.Length = m.tiLength
				
			OTHERWISE
				*!ToDo: Error handling?
			ENDCASE
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tiFirst, tiLength
		
		RETURN CREATEOBJECT(This.Class, m.tiFirst, m.tiLength)
	ENDFUNC


	*********************************************************************
	FUNCTION First_ASSIGN
	*********************************************************************
	** Property: First (Assign)
	**
	** Gets or sets the position in the string of the first character of this CharacterRange.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.CharacterRange.First%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.First = INT(m.tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Length_ASSIGN
	*********************************************************************
	** Property: Length (Assign)
	**
	** Gets or sets the number of positions in this CharacterRange.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.CharacterRange.Length%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.Length = INT(m.tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ToVarbinary
	*********************************************************************
	** Method: xfcCharacterRange.ToVarbinary
	**
	** Returns a binary representation of this CharacterRange structure
	**
	** History:
	**	2006/05/11: BDurban - Coded
	**  2006/07/08: BDurban - Changed names
	*********************************************************************
	LPARAMETERS taoRange AS xfcCharacterRange, tiCount
		
		*!ToDo: Test this function
		LOCAL lqBinary, loRange
		m.lqBinary = 0h
		m.tiCount = 0
		
		DO CASE
		CASE PCOUNT() = 0
			m.lqBinary = 0h+;
				BINTOC(This.First, "4rs")+;
				BINTOC(This.Length, "4rs")
				
		CASE TYPE("taoRange[1]") = "O"
			FOR EACH loRange AS xfcCharacterRange IN taoRange FOXOBJECT
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.loRange.First, "4rs")+;
					BINTOC(m.loRange.Length, "4rs")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE VARTYPE(m.taoRange) = "O"
			m.loRange = m.taoRange
			m.lqBinary = m.lqBinary + ;
				BINTOC(m.loRange.First, "4rs")+;
				BINTOC(m.loRange.Length, "4rs")
			m.tiCount = 1
		ENDCASE
		
		RETURN m.lqBinary
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="first" type="property" display="First"/>]+;
		[<memberdata name="length" type="property" display="Length"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCCOLOR
DEFINE CLASS xfcColor AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Color"
	A = 0	&& Gets the alpha component value of this Color structure.
	R = 0	&& Gets the red component value of this Color structure.
	G = 0	&& Gets the green component value of this Color structure.
	B = 0	&& Gets the blue component value of this Color structure.
	Argb = 0
	IsEmpty = 0	&& Specifies whether this Color structure is uninitialized.
	IsKnownColor = 0	&& Specifies whether this Color structure is a pre-defined color. Pre-defined colors are represented by the elements of the KnownColor enumeration.
	IsNamedColor = 0	&& Specifies whether this Color structure is a pre-defined color. Pre-defined colors are represented by the elements of the KnownColor enumeration.
	IsSystemColor = 0	&& Specifies whether this Color structure is a system color. A system color is a color that is used in a windows display element. System colors are represented by elements of the KnownColor enumeration.
	PROTECTED _knowncolor
	_knowncolor = 0
	PROTECTED _knowncolortable
	_knowncolortable = .NULL.
	PROTECTED _state
	_state = 0

 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcColor.Color
	**
	** Converts colors from one data type to another. Access this class through the TypeDescriptor.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**	2006/05/04: BDurban - Set default color to black
	**  2006/08/25: BDurban - Added support for KnownColor and State
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ColorConverter%28vs.80%29.aspx
	** Parameters:
	*********************************************************************
	LPARAMETERS tiArgb, ;
					tiState, tcName, tiKnownColor
	*********** tiKnownColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			ADDPROPERTY(This, "Proxy", CREATEOBJECT("Empty"))
			ADDPROPERTY(This.Proxy, "Name", "ColorName")
		
			DO CASE
		** KnownColor
			CASE VARTYPE(m.tiArgb) = "N" AND BETWEEN(m.tiArgb, 0x01, 0xae)
				m.tiKnownColor = m.tiArgb
				This.Argb = _SCREEN.GdipToken.KnownColorTable.KnownColorToArgb(m.tiKnownColor)
				This._knownColor = m.tiKnownColor
				This._state = (1+2)	&& StateKnownColorValid + StateARGBValueValid
				This.Proxy.Name = NULL
				
		** ARGB
			CASE VARTYPE(m.tiArgb) = "N"
				m.tiState = EVL(m.tiState,0)
				m.tcName = EVL(m.tcName,NULL)
				m.tiKnownColor = EVL(m.tiKnownColor,0)
				
				IF m.tiKnownColor > 0
					m.tiState = BITOR(m.tiState,1)
				ENDIF
				
				IF VARTYPE(m.tcName) = "C"
					m.tiState = BITOR(m.tiState,8)
				ENDIF
				
				IF m.tiArgb > 0
					m.tiState = BITOR(m.tiState,2)
				ENDIF
				
				IF m.tiState > 0 AND BITAND(m.tiState,2)<>2
					DO CASE
					CASE BITAND(m.tiState,1)=1
						m.tiArgb = _SCREEN.GdipToken.KnownColorTable.KnownColorToArgb(m.tiKnownColor)
					CASE BITAND(m.tiState,8)=8	
						m.tiKnownColor = _SCREEN.GdipToken.KnownColorTable.NameToKnownColor(m.tcName,.T.)
						m.tiArgb = _SCREEN.GdipToken.KnownColorTable.KnownColorToArgb(m.tiKnownColor)
					ENDCASE
				ENDIF
				
				This.Argb = BITLSHIFT(INT(m.tiArgb),0)
				This._state = m.tiState
				This._knownColor = m.tiKnownColor
				This.Proxy.Name = m.tcName
				
			OTHERWISE
				This.Argb = ARGB_Black	&& Default to black
				This._state = 0
			ENDCASE
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tiArgb, ;
					tiState, tcName, tiKnowColor
		
		RETURN CREATEOBJECT(This.Class, tiArgb, tiState, tcName, tiKnowColor)
	ENDFUNC


	*********************************************************************
	FUNCTION NewArray
	*********************************************************************
	LPARAMETERS teP1, teP2, teP3, teP4, teP5, teP6, teP7, ;
					teP8, teP9, teP10, teP11, teP12, teP13, teP14, ;
					teP15, teP16, teP17, teP18, teP19, teP20, teP21, ;
					teP22, teP23, teP24, teP25, teP26, teP27, teP28
		
		LOCAL lnValue, lnLoop, lqBinary, laValue[1], loValue
		
		m.lqBinary = 0h
		
		DO CASE
		CASE VARTYPE(m.teP1)="N"
			FOR m.lnLoop = 1 TO PCOUNT()
				m.lnValue = EVALUATE("m.teP"+PADR(m.lnLoop,2))
				IF VARTYPE(m.lnValue)="N"
					m.lqBinary = m.lqBinary + BINTOC(BITLSHIFT(m.lnValue,0),"4rs")
				ELSE
					EXIT
				ENDIF
			ENDFOR
			
		CASE VARTYPE(m.teP1)="O"
			FOR m.lnLoop = 1 TO PCOUNT()
				m.loValue = EVALUATE("m.teP"+PADR(m.lnLoop,2))
				IF VARTYPE(m.loValue)="O"
					m.lqBinary = m.lqBinary + BINTOC(BITLSHIFT(m.loValue.Argb,0),"4rs")
				ELSE
					EXIT
				ENDIF
			ENDFOR
			
		CASE VARTYPE(m.teP1)="C" AND USED(m.teP1)
			*! ToDo: Handle a cursor here
			
		CASE VARTYPE(m.teP1)="C"
			FOR lnLoop = 1 TO ALINES(laValue, m.teP1, 1, ",")
				m.lnValue = EVALUATE(laValue[m.lnLoop])
				IF VARTYPE(m.lnValue)="N"
					m.lqBinary = m.lqBinary + BINTOC(m.lnValue,"4rs")
				ELSE
					EXIT
				ENDIF
			ENDFOR
		ENDCASE
		
		RETURN m.lqBinary
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION This_ACCESS
	*********************************************************************
	** Property: This (Access)
	**
	** History:
	**  2006/08/25: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.Name%28vs.80%29.aspx
	** Returns: string
	*********************************************************************
	LPARAMETERS tcMember
		
		DO CASE
		CASE UPPER(m.tcMember) = "NAME"
	*********************************************************************
	** Use a proxy object for the Name property instead of Name_ACCESS to avoid C..5 errors
	** Property: Name (Access)
	**
	** Gets the name of this Color Name. This will either return the user-defined name
	** of the color, if the color was created from a name, or the name of the known color.
	** For custom colors, the RGB value will be returned.
	*********************************************************************
			IF NOT BITAND(This._state,8)=8	&& Unknown name
				IF This.IsKnownColor
					This.Proxy.Name = _SCREEN.GdipToken.KnownColorTable.KnownColorToName(This._knownColor)
					This._state = BITOR(This._state,8)
				ELSE
					This.Proxy.Name = TRANSFORM(This.Argb,"@0")
				ENDIF
			ENDIF
			
			RETURN This.Proxy
		ENDCASE
		
		RETURN This
	ENDFUNC

	*********************************************************************
	PROTECTED FUNCTION Argb_ASSIGN
	*********************************************************************
	LPARAMETERS vNewVal
		
	** Force value to be a signed int
		This.Argb = BITLSHIFT(m.vNewVal,0)
		This._state=2
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION A_ACCESS
	*********************************************************************
	** Property: A (Access)
	**
	** Gets the alpha component value of this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.A%28vs.80%29.aspx
	** Returns: byte
	*********************************************************************
		LOCAL liByte
		LOCAL loExc AS Exception
		TRY
			liByte = BITRSHIFT(BITAND(This.Argb,0xff000000),24)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liByte
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION A_ASSIGN
	*********************************************************************
	** Property: A (Assign)
	**
	** Sets the alpha component value of this Color structure.
	**
	** History:
	** 2006/08/22: CChalom - Coded based on _gdiplus.vcx
	*********************************************************************
	LPARAMETERS tnNewVal
		LOCAL loExc AS Exception
		TRY
		   This.Argb = BITOR(BITAND(This.Argb,0x00FFFFFF), BITLSHIFT(m.tnNewVal,24))
		   This._state = 2
		CATCH TO loExc
		   THROW_EXCEPTION
		ENDTRY
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION B_ACCESS
	*********************************************************************
	** Property: B (Access)
	**
	** Gets the blue component value of this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.B%28vs.80%29.aspx
	** Returns: byte
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liByte
		
		LOCAL loExc AS Exception
		TRY
			liByte = BITAND(This.Argb,0x000000ff)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liByte
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION B_ASSIGN
	*********************************************************************
	** Property: B (Assign)
	**
	** Sets the blue component value of this Color structure.
	**
	** History:
	** 2006/08/22: CChalom - Coded based on _gdiplus.vcx
	*********************************************************************
	LPARAMETERS tnNewVal
		LOCAL loExc AS Exception
		TRY
		   This.ARGB = BITOR(BITAND(This.ARGB,0xFFFFFF00), m.tnNewVal)
		   This._state = 2
		CATCH TO loExc
		   THROW_EXCEPTION
		ENDTRY
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcColor.Equals
	**
	** Tests whether the specified object is a Color structure and is equivalent to this
	** Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toColor AS xfcColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue
			m.llValue = This.Argb = m.toColor.ARGB
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION FromArgb
	*********************************************************************
	** Method: xfcColor.FromArgb
	**
	** Creates a Color structure from the four 8-bit ARGB component (alpha, red, green,
	** and blue) values.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/26: BDurban - Added support for (A,RGB) parameters
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.FromArgb%28vs.80%29.aspx
	** Parameters:
	**  int argb
	**  int alpha, Color baseColor
	**  int red, int green, int blue
	**  int alpha, int red, int green, int blue
	** Returns: Color
	*********************************************************************
	LPARAMETERS tiAlpha, tiRed, tiGreen, tiBlue
	*********** tiRed, tiGreen, tiBlue
	*********** tiAlpha, toBaseColor AS xfcColor
	*********** tiArgb
	*********** tiAlpha, tiRgb
		
		*!ToDo: Test this function
		
		LOCAL loColor AS xfcColor, liArgb
		m.liArgb = 0
		m.loColor = NULL
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 1	&& ARGB
				m.liArgb = tiAlpha
				m.loColor = CREATEOBJECT(This.Class,m.liArgb,2)
				
			CASE PCOUNT() = 2 AND VARTYPE(m.tiRed)="N"	&& A,RGB
				m.loColor = This.FromRgb(m.tiRed)
				m.loColor.A = m.tiAlpha
				
			CASE PCOUNT() = 2 AND VARTYPE(m.tiRed)="O"	&& A,Color
				m.liArgb = m.tiRed.Argb
				m.liArgb = BITAND(liArgb,0x00FFFFFF)+BITLSHIFT(BITAND(tiAlpha,0xFF),24)
				m.loColor = CREATEOBJECT(This.Class,m.liArgb,2)
				
			CASE PCOUNT() = 3	&& R,G,B
				m.tiBlue = m.tiGreen
				m.tiGreen = m.tiRed
				m.tiRed = m.tiAlpha
				m.tiAlpha = 0xFF
				m.liArgb = BITLSHIFT(BITAND(m.tiAlpha,0xFF),24)+;
					BITLSHIFT(BITAND(m.tiRed,0xFF),16)+;
					BITLSHIFT(BITAND(m.tiGreen,0xFF),8)+;
					BITAND(m.tiBlue,0xFF)
				m.loColor = CREATEOBJECT(This.Class,m.liArgb,2)
				
			CASE PCOUNT() = 4	&& A,R,G,B
				m.liArgb = BITLSHIFT(BITAND(m.tiAlpha,0xFF),24)+;
					BITLSHIFT(BITAND(m.tiRed,0xFF),16)+;
					BITLSHIFT(BITAND(m.tiGreen,0xFF),8)+;
					BITAND(m.tiBlue,0xFF)
				m.loColor = CREATEOBJECT(This.Class,m.liArgb,2)
			
			OTHERWISE
				m.loColor = CREATEOBJECT(This.Class,0,0)
		
			ENDCASE
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION FromKnownColor
	*********************************************************************
	** Method: xfcColor.FromKnownColor
	**
	** Creates a Color structure from the specified pre-defined color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.FromKnownColor%28vs.80%29.aspx
	** Parameters:
	**  KnownColor color
	** Returns: Color
	*********************************************************************
	LPARAMETERS tiKnownColor AS EnumKnownColor
		*!ToDo: Test this function
		LOCAL loExc AS Exception
		TRY
			LOCAL loColor AS xfcColor
			m.loColor = NULL
			IF BETWEEN(m.tiKnownColor, 0x01, 0xae)
				m.loColor = CREATEOBJECT("xfcColor", m.tiKnownColor)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION FromName
	*********************************************************************
	** Method: xfcColor.FromName
	**
	** Creates a Color structure from the specified name of a pre-defined color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/08/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.FromName%28vs.80%29.aspx
	** Parameters:
	**  string name
	** Returns: Color
	*********************************************************************
	LPARAMETERS tcName
		*!ToDo: Test this function
		LOCAL loExc AS Exception
		TRY
			LOCAL loColor, liArgb
			m.liArgb = 0
			m.loColor = NULL
			
			liArgb = _SCREEN.GdiPToken.NamedColor(m.tcName)
			IF NOT ISNULL(m.liArgb)
				m.loColor = This.FromArgb(m.liARGB)
			ENDIF
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION FromRgb
	*********************************************************************
	** Method: xfcColor.FromRgb
	**
	** Creates a Color structure from the 3 8-bit RGB component (red, green,
	** and blue) values.
	**
	** History:
	**	2006/03/29: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.FromArgb%28vs.80%29.aspx
	** Parameters:
	**  int argb
	**  int alpha, Color baseColor
	**  int red, int green, int blue
	**  int alpha, int red, int green, int blue
	** Returns: Color
	*********************************************************************
	LPARAMETERS tiRed, tiGreen, tiBlue
	*********** tiRgb
		*!ToDo: Test this function
		LOCAL loColor AS xfcColor, liArgb, liRGB
		m.loColor = NULL
		m.liArgb = 0
		m.liRGB = 0
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 1	&& RGB
				m.liRGB = m.tiRed
				m.liArgb = BITLSHIFT(0xFF,24)+ ;
					BITLSHIFT(BITAND(m.liRGB,0x000000FF),16)+;
					BITAND(m.liRGB,0x0000FF00)+;
					BITRSHIFT(BITAND(m.liRGB,0x00FF0000),16)
					
			CASE PCOUNT() = 3	&& R,G,B
				m.liArgb = BITLSHIFT(0xFF,24)+;
					BITLSHIFT(BITAND(m.tiRed,0xFF),16)+;
					BITLSHIFT(BITAND(m.tiGreen,0xFF),8)+;
					BITAND(m.tiBlue,0xFF)
			ENDCASE
				m.loColor = CREATEOBJECT("xfcColor")
				m.loColor.argb = liArgb
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION GetBrightness
	*********************************************************************
	** Method: xfcColor.GetBrightness
	**
	** Gets the hue-saturation-brightness (HSB) brightness value for this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.GetBrightness%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: float
	*********************************************************************
		*!ToDo: Test this function
		LOCAL loExc AS Exception
		TRY
			LOCAL lnValue
			m.lnValue = 0.0
			This.GetHSB(0,0,@lnValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcColor.GetHashCode
	**
	** Returns a hash code for this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetHSB
	*********************************************************************
	** Method: xfcColor.GetHSB
	**
	** Gets the Hue, Saturation and Brightness for the current color. The
	** H,S,B values should be passed by reference.
	**
	** History:
	**  2006/05/11: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiH, tiS, tiL
		
		
	** Translated from:
	** http://groups.google.com/group/microsoft.public.vb.controls.creation/browse_thread/thread/f892564adf35516c/6f90b1613e11764d?lnk=st&q=convert+RGB+to+HSB&rnum=15&hl=en#6f90b1613e11764d
		
		LOCAL lnR, lnG, lnB, lnMax, lnMin, lnDelta, lnH, lnS, lnL
		STORE 0.0 TO lnR, lnG, lnB, lnMax, lnMin, lnDelta, lnH, lnS, lnL
		
		m.lnR = This.R / 255.00
		m.lnG = This.G / 255.00
		m.lnB = This.B / 255.00
		
		m.lnMax = MAX(m.lnR, m.lnG, m.lnB)
		m.lnMin = MIN(m.lnR, m.lnG, m.lnB)
		m.lnDelta = (m.lnMax-m.lnMin)
		
		m.lnL = (m.lnMax+m.lnMin)/2
		IF m.lnMax = m.lnMin
			m.lnS = 0
			m.lnH = 0
			m.lnL = m.lnL * 240
		ENDIF
		
		IF m.lnL < 0.5
			m.lnS = m.lnDelta / (m.lnMax+m.lnMin)
		ELSE
			m.lnS = m.lnDelta / (2-m.lnMax-m.lnMin)
		ENDIF
		
		DO CASE
		CASE m.lnR = m.lnMax
			m.lnH = (m.lnG-m.lnB)/m.lnDelta
		CASE m.lnG = m.lnMax
			m.lnH = 2+(m.lnB-m.lnR)/m.lnDelta
		CASE m.lnB = m.lnMax
			m.lnH = 4+(m.lnR-m.lnG)/m.lnDelta
		ENDCASE
		
		m.lnH = m.lnH * 40
		m.lnH = IIF(m.lnH < 0.0, m.lnH+240, m.lnH)
		m.lnS = m.lnS * 240
		m.lnL = m.lnL * 240
		
		m.tiH = ROUND(m.lnH,0)
		m.tiS = ROUND(m.lnS,0)
		m.tiL = ROUND(m.lnL,0)
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GetHue
	*********************************************************************
	** Method: xfcColor.GetHue
	**
	** Gets the hue-saturation-brightness (HSB) hue value, in degrees, for this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.GetHue%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lnValue
			m.lnValue = 0.0
			This.GetHSB(@lnValue,0,0)
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetSaturation
	*********************************************************************
	** Method: xfcColor.GetSaturation
	**
	** Gets the hue-saturation-brightness (HSB) saturation value for this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.GetSaturation%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lnValue
			m.lnValue = 0.0
			This.GetHSB(0,@lnValue,0)
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION G_ACCESS
	*********************************************************************
	** Property: G (Access)
	**
	** Gets the green component value of this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.G%28vs.80%29.aspx
	** Returns: byte
	*********************************************************************
		*!ToDo: Test this function
		LOCAL liByte
		
		LOCAL loExc AS Exception
		TRY
			liByte = BITRSHIFT(BITAND(This.Argb,0x0000ff00),8)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liByte
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION G_ASSIGN
	*********************************************************************
	** Property: G (Assign)
	**
	** Sets the green component value of this Color structure.
	**
	** History:
	** 2006/08/22: CChalom - Coded based on _gdiplus.vcx
	*********************************************************************
	LPARAMETERS tnNewVal
		LOCAL loExc AS Exception
		TRY
		   This.Argb = BITOR(BITAND(This.Argb,0xFFFF00FF),BITLSHIFT(m.tnNewVal,8))
		   This._state = 2
		CATCH TO loExc
		   THROW_EXCEPTION
		ENDTRY
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION IsEmpty_ACCESS
	*********************************************************************
	** Property: IsEmpty (Access)
	**
	** Specifies whether this Color structure is uninitialized.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**  2006/08/25: BDurban - Changed to use _state
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.IsEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		RETURN (This._state = 0)
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION IsKnownColor_ACCESS
	*********************************************************************
	** Property: IsKnownColor (Access)
	**
	** Specifies whether this Color structure is a pre-defined color. Pre-defined colors
	** are represented by the elements of the KnownColor enumeration.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/08/25: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.IsKnownColor%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			IF NOT BITAND(This._state,1)=1
				This._knownColor = _SCREEN.GdipToken.KnownColorTable.ArgbToKnownColor(This.Argb,.T.)
				This._state = BITOR(This._state,1)
			ENDIF
			m.llValue = (This._knownColor <> 0)
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION IsNamedColor_ACCESS
	*********************************************************************
	** Property: IsNamedColor (Access)
	**
	** Specifies whether this Color structure is a pre-defined color. Pre-defined colors
	** are represented by the elements of the KnownColor enumeration.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/08/26: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.IsNamedColor%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			m.llValue = BITAND(This._state,8)=8 ;
						OR This.IsKnownColor
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION IsSystemColor_ACCESS
	*********************************************************************
	** Property: IsSystemColor (Access)
	**
	** Specifies whether this Color structure is a system color. A system color is a color
	** that is used in a windows display element. System colors are represented by elements
	** of the KnownColor enumeration.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/08/25: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.IsSystemColor%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		*!ToDo: Test this function
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			IF This.IsKnownColor
				m.llValue = (BETWEEN(This._knownColor,0x01,0x19) ;
							OR BETWEEN(This._knownColor,0xa8,0xae))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION R_ACCESS
	*********************************************************************
	** Property: R (Access)
	**
	** Gets the red component value of this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.R%28vs.80%29.aspx
	** Returns: byte
	*********************************************************************
		LOCAL liByte
		LOCAL loExc AS Exception
		TRY
			liByte = BITRSHIFT(BITAND(This.Argb,0x00ff0000),16)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liByte
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION R_ASSIGN
	*********************************************************************
	** Property: R (Assign)
	**
	** Sets the red component value of this Color structure.
	**
	** History:
	** 2006/08/22: CChalom - Coded based on _gdiplus.vcx
	*********************************************************************
	LPARAMETERS tnNewVal
		LOCAL loExc AS Exception
		TRY
		   This.Argb = BITOR(BITAND(This.Argb,0xFF00FFFF),BITLSHIFT(m.tnNewVal,16))
		   This._state = 2
		CATCH TO loExc
		   THROW_EXCEPTION
		ENDTRY
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ToArgb
	*********************************************************************
	** Method: xfcColor.ToArgb
	**
	** Gets the 32-bit ARGB value of this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.ToArgb%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		RETURN BITLSHIFT(This.Argb,0)
	ENDFUNC


	*********************************************************************
	FUNCTION ToRgb
	*********************************************************************
	** Method: xfcColor.ToRgb
	**
	** Gets the 24-bit RGB value of this Color structure. The Alpha channel is ignored
	**
	** History:
	**	2006/09/02: BDurban - Coded
	**
	** Returns: int
	*********************************************************************
		RETURN BITRSHIFT(BITAND(This.Argb,0x00FF0000),16) + ;
				BITAND(This.Argb,0x0000FF00) + ;
				BITLSHIFT(BITAND(This.Argb,0x000000FF),16)
	ENDFUNC
	

	*********************************************************************
	FUNCTION ToKnownColor
	*********************************************************************
	** Method: xfcColor.ToKnownColor
	**
	** Gets the KnownColor value of this Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.ToKnownColor%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: KnownColor
	*********************************************************************
		
		*!ToDo: Test this function
		LOCAL llKnown
		
		LOCAL loExc AS Exception
		TRY
			m.llKnown = This.IsKnownColor
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN This._knownColor
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcColor.ToString
	**
	** Converts this Color structure to a human-readable string.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/08/26: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		LOCAL lcString
		m.lcString = ""
		
		LOCAL loExc AS Exception
		TRY
			m.lcString = This.BaseName + " ["
			DO CASE
			CASE This.IsKnownColor
				m.lcString = lcString + This.Name
			CASE This.IsEmpty
				m.lcString = lcString + "Empty"
			OTHERWISE
				m.lcString = m.lcString + ;
						"A="+ALLTRIM(STR(This.A))+;
						", R="+ALLTRIM(STR(This.R))+;
						", G="+ALLTRIM(STR(This.G))+;
						", B="+ALLTRIM(STR(This.B))
			ENDCASE
		
			m.lcString = m.lcString + "]"
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lcString
	ENDFUNC


	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="fromargb" type="method" display="FromArgb"/>]+;
		[<memberdata name="fromknowncolor" type="method" display="FromKnownColor"/>]+;
		[<memberdata name="fromname" type="method" display="FromName"/>]+;
		[<memberdata name="getbrightness" type="method" display="GetBrightness"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gethue" type="method" display="GetHue"/>]+;
		[<memberdata name="getsaturation" type="method" display="GetSaturation"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="toargb" type="method" display="ToArgb"/>]+;
		[<memberdata name="torgb" type="method" display="ToRgb"/>]+;
		[<memberdata name="toknowncolor" type="method" display="ToKnownColor"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="a" type="property" display="A"/>]+;
		[<memberdata name="b" type="property" display="B"/>]+;
		[<memberdata name="g" type="property" display="G"/>]+;
		[<memberdata name="isempty" type="property" display="IsEmpty"/>]+;
		[<memberdata name="isknowncolor" type="property" display="IsKnownColor"/>]+;
		[<memberdata name="isnamedcolor" type="property" display="IsNamedColor"/>]+;
		[<memberdata name="issystemcolor" type="property" display="IsSystemColor"/>]+;
		[<memberdata name="name" type="property" display="Name"/>]+;
		[<memberdata name="r" type="property" display="R"/>]+;
		[<memberdata name="fromrgb" type="method" display="FromRgb"/>]+;
		[<memberdata name="gethsb" type="method" display="GetHSB"/>]+;
		[<memberdata name="argb" type="property" display="Argb"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************


*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCCOLORS
DEFINE CLASS xfccolors AS xfccolor
*************************************************************************
*************************************************************************
*************************************************************************
	AliceBlue = .NULL.	&& Gets a system defined color
	AntiqueWhite = .NULL.	&& Gets a system defined color
	Aqua = .NULL.	&& Gets a system defined color
	Aquamarine = .NULL.	&& Gets a system defined color
	Azure = .NULL.	&& Gets a system defined color
	Beige = .NULL.	&& Gets a system defined color
	Bisque = .NULL.	&& Gets a system defined color
	Black = .NULL.	&& Gets a system defined color
	BlanchedAlmond = .NULL.	&& Gets a system defined color
	Blue = .NULL.	&& Gets a system defined color
	BlueViolet = .NULL.	&& Gets a system defined color
	Brown = .NULL.	&& Gets a system defined color
	BurlyWood = .NULL.	&& Gets a system defined color
	CadetBlue = .NULL.	&& Gets a system defined color
	Chartreuse = .NULL.	&& Gets a system defined color
	Chocolate = .NULL.	&& Gets a system defined color
	Coral = .NULL.	&& Gets a system defined color
	CornflowerBlue = .NULL.	&& Gets a system defined color
	Cornsilk = .NULL.	&& Gets a system defined color
	Crimson = .NULL.	&& Gets a system defined color
	Cyan = .NULL.	&& Gets a system defined color
	DarkBlue = .NULL.	&& Gets a system defined color
	DarkCyan = .NULL.	&& Gets a system defined color
	DarkGoldenrod = .NULL.	&& Gets a system defined color
	DarkGray = .NULL.	&& Gets a system defined color
	DarkGreen = .NULL.	&& Gets a system defined color
	DarkKhaki = .NULL.	&& Gets a system defined color
	DarkMagenta = .NULL.	&& Gets a system defined color
	DarkOliveGreen = .NULL.	&& Gets a system defined color
	DarkOrange = .NULL.	&& Gets a system defined color
	DarkOrchid = .NULL.	&& Gets a system defined color
	DarkRed = .NULL.	&& Gets a system defined color
	DarkSalmon = .NULL.	&& Gets a system defined color
	DarkSeaGreen = .NULL.	&& Gets a system defined color
	DarkSlateBlue = .NULL.	&& Gets a system defined color
	DarkSlateGray = .NULL.	&& Gets a system defined color
	DarkTurquoise = .NULL.	&& Gets a system defined color
	DarkViolet = .NULL.	&& Gets a system defined color
	DeepPink = .NULL.	&& Gets a system defined color
	DeepSkyBlue = .NULL.	&& Gets a system defined color
	DimGray = .NULL.	&& Gets a system defined color
	DodgerBlue = .NULL.	&& Gets a system defined color
	Firebrick = .NULL.	&& Gets a system defined color
	FloralWhite = .NULL.	&& Gets a system defined color
	ForestGreen = .NULL.	&& Gets a system defined color
	Fuchsia = .NULL.	&& Gets a system defined color
	Gainsboro = .NULL.	&& Gets a system defined color
	GhostWhite = .NULL.	&& Gets a system defined color
	Gold = .NULL.	&& Gets a system defined color
	Goldenrod = .NULL.	&& Gets a system defined color
	Gray = .NULL.	&& Gets a system defined color
	Green = .NULL.	&& Gets a system defined color
	GreenYellow = .NULL.	&& Gets a system defined color
	Honeydew = .NULL.	&& Gets a system defined color
	HotPink = .NULL.	&& Gets a system defined color
	IndianRed = .NULL.	&& Gets a system defined color
	Indigo = .NULL.	&& Gets a system defined color
	Ivory = .NULL.	&& Gets a system defined color
	Khaki = .NULL.	&& Gets a system defined color
	Lavender = .NULL.	&& Gets a system defined color
	LavenderBlush = .NULL.	&& Gets a system defined color
	LawnGreen = .NULL.	&& Gets a system defined color
	LemonChiffon = .NULL.	&& Gets a system defined color
	LightBlue = .NULL.	&& Gets a system defined color
	LightCoral = .NULL.	&& Gets a system defined color
	LightCyan = .NULL.	&& Gets a system defined color
	LightGoldenrodYellow = .NULL.
	** Gets a system defined color
	LightGray = .NULL.	&& Gets a system defined color
	LightGreen = .NULL.	&& Gets a system defined color
	LightPink = .NULL.	&& Gets a system defined color
	LightSalmon = .NULL.	&& Gets a system defined color
	LightSeaGreen = .NULL.	&& Gets a system defined color
	LightSkyBlue = .NULL.	&& Gets a system defined color
	LightSlateGray = .NULL.	&& Gets a system defined color
	LightSteelBlue = .NULL.	&& Gets a system defined color
	LightYellow = .NULL.	&& Gets a system defined color
	Lime = .NULL.	&& Gets a system defined color
	LimeGreen = .NULL.	&& Gets a system defined color
	Linen = .NULL.	&& Gets a system defined color
	Magenta = .NULL.	&& Gets a system defined color
	Maroon = .NULL.	&& Gets a system defined color
	MediumAquamarine = .NULL.	&& Gets a system defined color
	MediumBlue = .NULL.	&& Gets a system defined color
	MediumOrchid = .NULL.	&& Gets a system defined color
	MediumPurple = .NULL.	&& Gets a system defined color
	MediumSeaGreen = .NULL.	&& Gets a system defined color
	MediumSlateBlue = .NULL.	&& Gets a system defined color
	MediumSpringGreen = .NULL.
	** Gets a system defined color
	MediumTurquoise = .NULL.	&& Gets a system defined color
	MediumVioletRed = .NULL.	&& Gets a system defined color
	MidnightBlue = .NULL.	&& Gets a system defined color
	MintCream = .NULL.	&& Gets a system defined color
	MistyRose = .NULL.	&& Gets a system defined color
	Moccasin = .NULL.	&& Gets a system defined color
	NavajoWhite = .NULL.	&& Gets a system defined color
	Navy = .NULL.	&& Gets a system defined color
	OldLace = .NULL.	&& Gets a system defined color
	Olive = .NULL.	&& Gets a system defined color
	OliveDrab = .NULL.	&& Gets a system defined color
	Orange = .NULL.	&& Gets a system defined color
	OrangeRed = .NULL.	&& Gets a system defined color
	Orchid = .NULL.	&& Gets a system defined color
	PaleGoldenrod = .NULL.	&& Gets a system defined color
	PaleGreen = .NULL.	&& Gets a system defined color
	PaleTurquoise = .NULL.	&& Gets a system defined color
	PaleVioletRed = .NULL.	&& Gets a system defined color
	PapayaWhip = .NULL.	&& Gets a system defined color
	PeachPuff = .NULL.	&& Gets a system defined color
	Peru = .NULL.	&& Gets a system defined color
	Pink = .NULL.	&& Gets a system defined color
	Plum = .NULL.	&& Gets a system defined color
	PowderBlue = .NULL.	&& Gets a system defined color
	Purple = .NULL.	&& Gets a system defined color
	Red = .NULL.	&& Gets a system defined color
	RosyBrown = .NULL.	&& Gets a system defined color
	RoyalBlue = .NULL.	&& Gets a system defined color
	SaddleBrown = .NULL.	&& Gets a system defined color
	Salmon = .NULL.	&& Gets a system defined color
	SandyBrown = .NULL.	&& Gets a system defined color
	SeaGreen = .NULL.	&& Gets a system defined color
	SeaShell = .NULL.	&& Gets a system defined color
	Sienna = .NULL.	&& Gets a system defined color
	Silver = .NULL.	&& Gets a system defined color
	SkyBlue = .NULL.	&& Gets a system defined color
	SlateBlue = .NULL.	&& Gets a system defined color
	SlateGray = .NULL.	&& Gets a system defined color
	Snow = .NULL.	&& Gets a system defined color
	SpringGreen = .NULL.	&& Gets a system defined color
	SteelBlue = .NULL.	&& Gets a system defined color
	Tan = .NULL.	&& Gets a system defined color
	Teal = .NULL.	&& Gets a system defined color
	Thistle = .NULL.	&& Gets a system defined color
	Tomato = .NULL.	&& Gets a system defined color
	Transparent = .NULL.	&& Gets a system defined color
	Turquoise = .NULL.	&& Gets a system defined color
	Violet = .NULL.	&& Gets a system defined color
	Wheat = .NULL.	&& Gets a system defined color
	White = .NULL.	&& Gets a system defined color
	WhiteSmoke = .NULL.	&& Gets a system defined color
	Yellow = .NULL.	&& Gets a system defined color
	YellowGreen = .NULL.	&& Gets a system defined color
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfccolors.Colors
	**
	** Colors for all the standard colors. This class cannot be inherited.
	**
	** History:
	**  2006/08/26: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Color%28vs.80%29.aspx
	** Parameters:
		
	*********************************************************************
	LPARAMETERS tiAlpha, tiRed, tiGreen, tiBlue
		*!ToDo: Test this function
		
		#IFDEF USE_MEMBERDATA
			This._memberdata = [<VFPData>]+;
				STREXTRACT(This._memberdata,[<VFPData>],[</VFPData>])+;
				[<memberdata name="aliceblue" display="AliceBlue"/>]+;
				[<memberdata name="antiquewhite" display="AntiqueWhite"/>]+;
				[<memberdata name="aqua" display="Aqua"/>]+;
				[<memberdata name="aquamarine" display="Aquamarine"/>]+;
				[<memberdata name="azure" display="Azure"/>]+;
				[<memberdata name="beige" display="Beige"/>]+;
				[<memberdata name="bisque" display="Bisque"/>]+;
				[<memberdata name="black" display="Black"/>]+;
				[<memberdata name="blanchedalmond" display="BlanchedAlmond"/>]+;
				[<memberdata name="blue" display="Blue"/>]+;
				[<memberdata name="blueviolet" display="BlueViolet"/>]+;
				[<memberdata name="brown" display="Brown"/>]+;
				[<memberdata name="burlywood" display="BurlyWood"/>]+;
				[<memberdata name="cadetblue" display="CadetBlue"/>]+;
				[<memberdata name="chartreuse" display="Chartreuse"/>]+;
				[<memberdata name="chocolate" display="Chocolate"/>]+;
				[<memberdata name="coral" display="Coral"/>]+;
				[<memberdata name="cornflowerblue" display="CornflowerBlue"/>]+;
				[<memberdata name="cornsilk" display="Cornsilk"/>]+;
				[<memberdata name="crimson" display="Crimson"/>]+;
				[<memberdata name="cyan" display="Cyan"/>]+;
				[<memberdata name="darkblue" display="DarkBlue"/>]+;
				[<memberdata name="darkcyan" display="DarkCyan"/>]+;
				[<memberdata name="darkgoldenrod" display="DarkGoldenrod"/>]+;
				[<memberdata name="darkgray" display="DarkGray"/>]+;
				[<memberdata name="darkgreen" display="DarkGreen"/>]+;
				[<memberdata name="darkkhaki" display="DarkKhaki"/>]+;
				[<memberdata name="darkmagenta" display="DarkMagenta"/>]+;
				[<memberdata name="darkolivegreen" display="DarkOliveGreen"/>]+;
				[<memberdata name="darkorange" display="DarkOrange"/>]+;
				[<memberdata name="darkorchid" display="DarkOrchid"/>]+;
				[<memberdata name="darkred" display="DarkRed"/>]+;
				[<memberdata name="darksalmon" display="DarkSalmon"/>]+;
				[<memberdata name="darkseagreen" display="DarkSeaGreen"/>]+;
				[<memberdata name="darkslateblue" display="DarkSlateBlue"/>]+;
				[<memberdata name="darkslategray" display="DarkSlateGray"/>]+;
				[<memberdata name="darkturquoise" display="DarkTurquoise"/>]+;
				[<memberdata name="darkviolet" display="DarkViolet"/>]+;
				[<memberdata name="deeppink" display="DeepPink"/>]+;
				[<memberdata name="deepskyblue" display="DeepSkyBlue"/>]+;
				[<memberdata name="dimgray" display="DimGray"/>]+;
				[<memberdata name="dodgerblue" display="DodgerBlue"/>]+;
				[<memberdata name="firebrick" display="Firebrick"/>]+;
				[<memberdata name="floralwhite" display="FloralWhite"/>]+;
				[<memberdata name="forestgreen" display="ForestGreen"/>]+;
				[<memberdata name="fuchsia" display="Fuchsia"/>]+;
				[<memberdata name="gainsboro" display="Gainsboro"/>]+;
				[<memberdata name="ghostwhite" display="GhostWhite"/>]+;
				[<memberdata name="gold" display="Gold"/>]+;
				[<memberdata name="goldenrod" display="Goldenrod"/>]+;
				[<memberdata name="gray" display="Gray"/>]+;
				[<memberdata name="green" display="Green"/>]+;
				[<memberdata name="greenyellow" display="GreenYellow"/>]+;
				[<memberdata name="honeydew" display="Honeydew"/>]+;
				[<memberdata name="hotpink" display="HotPink"/>]+;
				[<memberdata name="indianred" display="IndianRed"/>]+;
				[<memberdata name="indigo" display="Indigo"/>]+;
				[<memberdata name="ivory" display="Ivory"/>]+;
				[<memberdata name="khaki" display="Khaki"/>]+;
				[<memberdata name="lavender" display="Lavender"/>]+;
				[<memberdata name="lavenderblush" display="LavenderBlush"/>]+;
				[<memberdata name="lawngreen" display="LawnGreen"/>]+;
				[<memberdata name="lemonchiffon" display="LemonChiffon"/>]+;
				[<memberdata name="lightblue" display="LightBlue"/>]+;
				[<memberdata name="lightcoral" display="LightCoral"/>]+;
				[<memberdata name="lightcyan" display="LightCyan"/>]+;
				[<memberdata name="lightgoldenrodyellow" display="LightGoldenrodYellow"/>]+;
				[<memberdata name="lightgray" display="LightGray"/>]+;
				[<memberdata name="lightgreen" display="LightGreen"/>]+;
				[<memberdata name="lightpink" display="LightPink"/>]+;
				[<memberdata name="lightsalmon" display="LightSalmon"/>]+;
				[<memberdata name="lightseagreen" display="LightSeaGreen"/>]+;
				[<memberdata name="lightskyblue" display="LightSkyBlue"/>]+;
				[<memberdata name="lightslategray" display="LightSlateGray"/>]+;
				[<memberdata name="lightsteelblue" display="LightSteelBlue"/>]+;
				[<memberdata name="lightyellow" display="LightYellow"/>]+;
				[<memberdata name="lime" display="Lime"/>]+;
				[<memberdata name="limegreen" display="LimeGreen"/>]+;
				[<memberdata name="linen" display="Linen"/>]+;
				[<memberdata name="magenta" display="Magenta"/>]+;
				[<memberdata name="maroon" display="Maroon"/>]+;
				[<memberdata name="mediumaquamarine" display="MediumAquamarine"/>]+;
				[<memberdata name="mediumblue" display="MediumBlue"/>]+;
				[<memberdata name="mediumorchid" display="MediumOrchid"/>]+;
				[<memberdata name="mediumpurple" display="MediumPurple"/>]+;
				[<memberdata name="mediumseagreen" display="MediumSeaGreen"/>]+;
				[<memberdata name="mediumslateblue" display="MediumSlateBlue"/>]+;
				[<memberdata name="mediumspringgreen" display="MediumSpringGreen"/>]+;
				[<memberdata name="mediumturquoise" display="MediumTurquoise"/>]+;
				[<memberdata name="mediumvioletred" display="MediumVioletRed"/>]+;
				[<memberdata name="midnightblue" display="MidnightBlue"/>]+;
				[<memberdata name="mintcream" display="MintCream"/>]+;
				[<memberdata name="mistyrose" display="MistyRose"/>]+;
				[<memberdata name="moccasin" display="Moccasin"/>]+;
				[<memberdata name="navajowhite" display="NavajoWhite"/>]+;
				[<memberdata name="navy" display="Navy"/>]+;
				[<memberdata name="oldlace" display="OldLace"/>]+;
				[<memberdata name="olive" display="Olive"/>]+;
				[<memberdata name="olivedrab" display="OliveDrab"/>]+;
				[<memberdata name="orange" display="Orange"/>]+;
				[<memberdata name="orangered" display="OrangeRed"/>]+;
				[<memberdata name="orchid" display="Orchid"/>]+;
				[<memberdata name="palegoldenrod" display="PaleGoldenrod"/>]+;
				[<memberdata name="palegreen" display="PaleGreen"/>]+;
				[<memberdata name="paleturquoise" display="PaleTurquoise"/>]+;
				[<memberdata name="palevioletred" display="PaleVioletRed"/>]+;
				[<memberdata name="papayawhip" display="PapayaWhip"/>]+;
				[<memberdata name="peachpuff" display="PeachPuff"/>]+;
				[<memberdata name="peru" display="Peru"/>]+;
				[<memberdata name="pink" display="Pink"/>]+;
				[<memberdata name="plum" display="Plum"/>]+;
				[<memberdata name="powderblue" display="PowderBlue"/>]+;
				[<memberdata name="purple" display="Purple"/>]+;
				[<memberdata name="red" display="Red"/>]+;
				[<memberdata name="rosybrown" display="RosyBrown"/>]+;
				[<memberdata name="royalblue" display="RoyalBlue"/>]+;
				[<memberdata name="saddlebrown" display="SaddleBrown"/>]+;
				[<memberdata name="salmon" display="Salmon"/>]+;
				[<memberdata name="sandybrown" display="SandyBrown"/>]+;
				[<memberdata name="seagreen" display="SeaGreen"/>]+;
				[<memberdata name="seashell" display="SeaShell"/>]+;
				[<memberdata name="sienna" display="Sienna"/>]+;
				[<memberdata name="silver" display="Silver"/>]+;
				[<memberdata name="skyblue" display="SkyBlue"/>]+;
				[<memberdata name="slateblue" display="SlateBlue"/>]+;
				[<memberdata name="slategray" display="SlateGray"/>]+;
				[<memberdata name="snow" display="Snow"/>]+;
				[<memberdata name="springgreen" display="SpringGreen"/>]+;
				[<memberdata name="steelblue" display="SteelBlue"/>]+;
				[<memberdata name="tan" display="Tan"/>]+;
				[<memberdata name="teal" display="Teal"/>]+;
				[<memberdata name="thistle" display="Thistle"/>]+;
				[<memberdata name="tomato" display="Tomato"/>]+;
				[<memberdata name="transparent" display="Transparent"/>]+;
				[<memberdata name="turquoise" display="Turquoise"/>]+;
				[<memberdata name="violet" display="Violet"/>]+;
				[<memberdata name="wheat" display="Wheat"/>]+;
				[<memberdata name="white" display="White"/>]+;
				[<memberdata name="whitesmoke" display="WhiteSmoke"/>]+;
				[<memberdata name="yellow" display="Yellow"/>]+;
				[<memberdata name="yellowgreen" display="YellowGreen"/>]+;
				[</VFPData>]
		#ENDIF
		
		DODEFAULT(m.tiAlpha, m.tiRed, m.tiGreen, m.tiBlue)
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION This_ACCESS
	*********************************************************************
	LPARAMETERS tcMember
		
		IF VARTYPE(m.tcMember)="C" ;
				AND PEMSTATUS(This,m.tcMember,5) ;
				AND PEMSTATUS(This,m.tcMember,3)="Property" ;
				AND ISNULL(This.&tcMember)
			LOCAL loColor
			m.loColor = _SCREEN.GdipToken.KnownColorTable.NameToKnownColor(tcMember)
			IF VARTYPE(m.loColor) = "O"
				This.&tcMember = m.loColor
			ENDIF
		ENDIF
		
		RETURN DODEFAULT(m.tcMember)
	ENDFUNC

ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCCOLORTRANSLATOR
DEFINE CLASS xfcColorTranslator AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "ColorTranslator"
	PROTECTED _htmlsyscolortable
	_htmlsyscolortable = .NULL.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcColorTranslator.ColorTranslator
	**
	** Translates colors to and from GDI+ Color structures. This class cannot be inherited.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ColorTranslator%28vs.80%29.aspx
	** Parameters:
		
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		RETURN
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
		** This.SetStatus(GdipSomeFunction???())
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcColorTranslator.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	*********************************************************************
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
	** This.SetStatus(GdipSomeFunction???())
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION FromHtml
	*********************************************************************
	** Method: xfcColorTranslator.FromHtml
	**
	** Translates an HTML color representation to a GDI+ Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/09/02: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ColorTranslator.FromHtml%28vs.80%29.aspx
	** Parameters:
	**  string htmlColor
	** Returns: Color
	*********************************************************************
	LPARAMETERS tcHtmlColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loColor AS xfcColor, liArgb
			LOCAL m.loCheckColor AS xfcColor
			LOCAL lcR, lcG, lcB
		
			m.loColor = CREATEOBJECT("xfcColor",0,0)
			m.loCheckColor = NULL
		
			DO CASE
			CASE LEFT(tcHtmlColor,1)=="#" AND INLIST(LEN(m.tcHtmlColor),7,4)
				IF LEN(m.tcHtmlColor) = 7
					m.loColor = m.loColor.FromRgb( ;
							ASC(STRCONV(SUBSTR(m.tcHtmlColor,2,2),16)), ;	&& R
							ASC(STRCONV(SUBSTR(m.tcHtmlColor,4,2),16)), ;	&& G
							ASC(STRCONV(SUBSTR(m.tcHtmlColor,6,2),16)))		&& B
				ELSE
					m.lcR = SUBSTR(m.tcHtmlColor,2,1)
					m.lcG = SUBSTR(m.tcHtmlColor,3,1)
					m.lcB = SUBSTR(m.tcHtmlColor,4,1)
					m.loColor = m.loColor.FromRgb( ;
							ASC(STRCONV(m.lcR+m.lcR,16)), ;	&& R
							ASC(STRCONV(m.lcG+m.lcG,16)), ;	&& G
							ASC(STRCONV(m.lcB+m.lcB,16)))	&& B
				ENDIF
				
			CASE LOWER(m.tcHtmlColor) == "lightgrey"
				m.loColor = m.loColor.FromKnownColor(KnownColorLightGray)
				
			ENDCASE
		
			IF m.loColor.IsEmpty
				This._InitializeHtmlSysColorTable()
				IF This._htmlSysColorTable.GetKey(LOWER(m.tcHtmlColor)) > 0
					m.loColor = This._htmlSysColorTable(LOWER(m.tcHtmlColor))
				ENDIF
			ENDIF
			
			IF m.loColor.IsEmpty
				m.loCheckColor = m.loColor.FromName(m.tcHtmlColor)
				IF NOT ISNULL(m.loCheckColor)
					m.loColor = m.loCheckColor
				ENDIF
			ENDIF
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION FromOle
	*********************************************************************
	** Method: xfcColorTranslator.FromOle
	**
	** Translates an OLE color value to a GDI+ Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/09/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ColorTranslator.FromOle%28vs.80%29.aspx
	** Parameters:
	**  int oleColor
	** Returns: Color
	*********************************************************************
	LPARAMETERS tiOleColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL loColor AS xfcColor, liKColor
			m.loColor = NULL
			m.liKColor = 0
			
			m.tiOleColor = BITLSHIFT(m.tiOleColor,0)
			
			IF BITAND(m.tiOleColor,0xff000000) = -2147483648 AND BITAND(m.tiOleColor,0xffffff) <= 0x18
				m.liKColor = BITAND(m.tiOleColor,0xffffff)
				DO CASE
				CASE m.liKColor = COLOR_SCROLLBAR
					m.loColor = CREATEOBJECT("xfcColor",KnownColorScrollBar)
				CASE m.liKColor = COLOR_DESKTOP
					m.loColor = CREATEOBJECT("xfcColor",KnownColorDesktop)
				CASE m.liKColor = COLOR_ACTIVECAPTION
					m.loColor = CREATEOBJECT("xfcColor",KnownColorActiveCaption)
				CASE m.liKColor = COLOR_INACTIVECAPTION
					m.loColor = CREATEOBJECT("xfcColor",KnownColorInactiveCaption)
				CASE m.liKColor = COLOR_MENU
					m.loColor = CREATEOBJECT("xfcColor",KnownColorMenu)
				CASE m.liKColor = COLOR_WINDOW
					m.loColor = CREATEOBJECT("xfcColor",KnownColorWindow)
				CASE m.liKColor = COLOR_WINDOWFRAME
					m.loColor = CREATEOBJECT("xfcColor",KnownColorWindowFrame)
				CASE m.liKColor = COLOR_MENUTEXT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorMenuText)
				CASE m.liKColor = COLOR_WINDOWTEXT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorWindowText)
				CASE m.liKColor = COLOR_CAPTIONTEXT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorActiveCaptionText)
				CASE m.liKColor = COLOR_ACTIVEBORDER
					m.loColor = CREATEOBJECT("xfcColor",KnownColorActiveBorder)
				CASE m.liKColor = COLOR_INACTIVEBORDER
					m.loColor = CREATEOBJECT("xfcColor",KnownColorInactiveBorder)
				CASE m.liKColor = COLOR_APPWORKSPACE
					m.loColor = CREATEOBJECT("xfcColor",KnownColorAppWorkspace)
				CASE m.liKColor = COLOR_HIGHLIGHT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorHighlight)
				CASE m.liKColor = COLOR_HIGHLIGHTTEXT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorHighlightText)
				CASE m.liKColor = COLOR_BTNFACE
					m.loColor = CREATEOBJECT("xfcColor",KnownColorControl)
				CASE m.liKColor = COLOR_BTNSHADOW
					m.loColor = CREATEOBJECT("xfcColor",KnownColorControlDark)
				CASE m.liKColor = COLOR_GRAYTEXT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorGrayText)
				CASE m.liKColor = COLOR_BTNTEXT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorControlText)
				CASE m.liKColor = COLOR_INACTIVECAPTIONTEXT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorInactiveCaptionText)
				CASE m.liKColor = COLOR_BTNHIGHLIGHT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorControlLightLight)
				CASE m.liKColor = COLOR_3DDKSHADOW
					m.loColor = CREATEOBJECT("xfcColor",KnownColorControlDarkDark)
				CASE m.liKColor = COLOR_3DLIGHT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorControlLight)
				CASE m.liKColor = COLOR_INFOTEXT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorInfoText)
				CASE m.liKColor = COLOR_INFOBK && 24   && -2147483624
					m.loColor = CREATEOBJECT("xfcColor",KnownColorInfo)
				CASE m.liKColor = -2147483621
					m.loColor = CREATEOBJECT("xfcColor",KnownColorGradientActiveCaption)
				CASE m.liKColor = -2147483620
					m.loColor = CREATEOBJECT("xfcColor",KnownColorGradientInactiveCaption)
				CASE m.liKColor = COLOR_MENUHILIGHT
					m.loColor = CREATEOBJECT("xfcColor",KnownColorMenuHighlight)
				CASE m.liKColor = COLOR_MENUBAR
					m.loColor = CREATEOBJECT("xfcColor",KnownColorMenuBar)
				ENDCASE
			ELSE
				m.loColor = CREATEOBJECT("xfcColor")
				m.loColor = m.loColor.FromRGB(m.tiOleColor)
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION FromWin32
	*********************************************************************
	** Method: xfcColorTranslator.FromWin32
	**
	** Translates a Windows color value to a GDI+ Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/09/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ColorTranslator.FromWin32%28vs.80%29.aspx
	** Parameters:
	**  int win32Color
	** Returns: Color
	*********************************************************************
	LPARAMETERS tiWin32Color
		
		*!ToDo: Test this function
		
		RETURN This.FromOle(m.tiWin32Color)
	ENDFUNC


	*********************************************************************
	FUNCTION ToHtml
	*********************************************************************
	** Method: xfcColorTranslator.ToHtml
	**
	** Translates the specified Color structure to an HTML string color representation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/09/02: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ColorTranslator.ToHtml%28vs.80%29.aspx
	** Parameters:
	**  Color c
	** Returns: string
	*********************************************************************
	LPARAMETERS toColor AS xfcColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lcValue
			m.lcValue = ""
			
			DO CASE
			CASE ISNULL(m.toColor)
				m.lcValue = ""
				
			CASE m.toColor.IsEmpty
				m.lcValue = ""
				
			CASE NOT m.toColor.IsSystemColor AND m.toColor.IsNamedColor
				m.lcValue = m.toColor.Name
				IF m.lcValue = "LightGray"
					m.lcValue = "LightGrey"
				ENDIF
				
			CASE NOT m.toColor.IsSystemColor
				m.lcValue = "#"+STRCONV(CHR(m.toColor.R)+CHR(m.toColor.G)+CHR(m.toColor.B),15)
				
			CASE m.toColor.IsSystemColor
				m.tiKColor = m.toColor.ToKnownColor()
				DO CASE
				CASE m.tiKColor = KnownColorActiveBorder
					m.lcValue = "activeborder"
				CASE m.tiKColor = KnownColorActiveCaption
					m.lcValue = "activecaption"
				CASE m.tiKColor = KnownColorGradientActiveCaption
					m.lcValue = "activecaption"
				CASE m.tiKColor = KnownColorActiveCaptionText
					m.lcValue = "captiontext"
				CASE m.tiKColor = KnownColorAppWorkspace
					m.lcValue = "appworkspace"
				CASE m.tiKColor = KnownColorControl
					m.lcValue = "buttonface"
				CASE m.tiKColor = KnownColorControlDark
					m.lcValue = "buttonshadow"
				CASE m.tiKColor = KnownColorControlDarkDark
					m.lcValue = "threeddarkshadow"
				CASE m.tiKColor = KnownColorControlLight
					m.lcValue = "buttonface"
				CASE m.tiKColor = KnownColorControlLightLight
					m.lcValue = "buttonhighlight"
				CASE m.tiKColor = KnownColorControlText
					m.lcValue = "buttontext"
				CASE m.tiKColor = KnownColorDesktop
					m.lcValue = "background"
				CASE m.tiKColor = KnownColorGrayText
					m.lcValue = "graytext"
				CASE m.tiKColor = KnownColorHighlight
					m.lcValue = "highlight"
				CASE m.tiKColor = KnownColorHotTrack
					m.lcValue = "highlight"
				CASE m.tiKColor = KnownColorHighlightText
					m.lcValue = "highlighttext"
				CASE m.tiKColor = KnownColorMenuHighlight
					m.lcValue = "highlighttext"
				CASE m.tiKColor = KnownColorInactiveBorder
					m.lcValue = "inactiveborder"
				CASE m.tiKColor = KnownColorInactiveCaption
					m.lcValue = "inactivecaption"
				CASE m.tiKColor = KnownColorGradientInactiveCaption
					m.lcValue = "inactivecaption"
				CASE m.tiKColor = KnownColorInactiveCaptionText
					m.lcValue = "inactivecaptiontext"
				CASE m.tiKColor = KnownColorInfo
					m.lcValue = "infobackground"
				CASE m.tiKColor = KnownColorInfoText
					m.lcValue = "infotext"
				CASE m.tiKColor = KnownColorMenu
					m.lcValue = "menu"
				CASE m.tiKColor = KnownColorMenuBar
					m.lcValue = "menu"
				CASE m.tiKColor = KnownColorMenuText
					m.lcValue = "menutext"
				CASE m.tiKColor = KnownColorScrollBar
					m.lcValue = "scrollbar"
				CASE m.tiKColor = KnownColorWindow
					m.lcValue = "window"
				CASE m.tiKColor = KnownColorWindowFrame
					m.lcValue = "windowframe"
				CASE m.tiKColor = KnownColorWindowText
					m.lcValue = "windowtext"
				ENDCASE
			ENDCASE
				
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lcValue
	ENDFUNC


	*********************************************************************
	FUNCTION ToOle
	*********************************************************************
	** Method: xfcColorTranslator.ToOle
	**
	** Translates the specified Color structure to an OLE color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/09/02: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ColorTranslator.ToOle%28vs.80%29.aspx
	** Parameters:
	**  Color c
	** Returns: int
	*********************************************************************
	LPARAMETERS toColor AS xfcColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue, tiKColor
			m.liValue = 0
			
			IF m.toColor.IsKnownColor
				m.tiKColor = m.toColor.ToKnownColor()
				DO CASE
				CASE m.tiKColor = KnownColorActiveBorder
					m.liValue = -2147483638
				CASE m.tiKColor = KnownColorActiveCaption
					m.liValue = -2147483646
				CASE m.tiKColor = KnownColorActiveCaptionText
					m.liValue = -2147483639
				CASE m.tiKColor = KnownColorAppWorkspace
					m.liValue = -2147483636
				CASE m.tiKColor = KnownColorControl
					m.liValue = -2147483633
				CASE m.tiKColor = KnownColorControlDark
					m.liValue = -2147483632
				CASE m.tiKColor = KnownColorControlDarkDark
					m.liValue = -2147483627
				CASE m.tiKColor = KnownColorControlLight
					m.liValue = -2147483626
				CASE m.tiKColor = KnownColorControlLightLight
					m.liValue = -2147483628
				CASE m.tiKColor = KnownColorControlText
					m.liValue = -2147483630
				CASE m.tiKColor = KnownColorDesktop
					m.liValue = -2147483647
				CASE m.tiKColor = KnownColorGrayText
					m.liValue = -2147483631
				CASE m.tiKColor = KnownColorHighlight
					m.liValue = -2147483635
				CASE m.tiKColor = KnownColorHighlightText
					m.liValue = -2147483634
				CASE m.tiKColor = KnownColorHotTrack
					m.liValue = -2147483635
				CASE m.tiKColor = KnownColorInactiveBorder
					m.liValue = -2147483637
				CASE m.tiKColor = KnownColorInactiveCaption
					m.liValue = -2147483645
				CASE m.tiKColor = KnownColorInactiveCaptionText
					m.liValue = -2147483629
				CASE m.tiKColor = KnownColorInfo
					m.liValue = -2147483624
				CASE m.tiKColor = KnownColorInfoText
					m.liValue = -2147483625
				CASE m.tiKColor = KnownColorMenu
					m.liValue = -2147483644
				CASE m.tiKColor = KnownColorMenuText
					m.liValue = -2147483641
				CASE m.tiKColor = KnownColorScrollBar
					m.liValue = -2147483648
				CASE m.tiKColor = KnownColorWindow
					m.liValue = -2147483643
				CASE m.tiKColor = KnownColorWindowFrame
					m.liValue = -2147483642
				CASE m.tiKColor = KnownColorWindowText
					m.liValue = -2147483640
				CASE m.tiKColor = KnownColorButtonFace
					m.liValue = -2147483633
				CASE m.tiKColor = KnownColorButtonHighlight
					m.liValue = -2147483628
				CASE m.tiKColor = KnownColorButtonShadow
					m.liValue = -2147483632
				CASE m.tiKColor = KnownColorGradientActiveCaption
					m.liValue = -2147483621
				CASE m.tiKColor = KnownColorGradientInactiveCaption
					m.liValue = -2147483620
				CASE m.tiKColor = KnownColorMenuBar
					m.liValue = -2147483618
				CASE m.tiKColor = KnownColorMenuHighlight
					m.liValue = -2147483619
				ENDCASE
			ELSE
				m.liValue = This.ToWin32(m.toColor)
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION ToWin32
	*********************************************************************
	** Method: xfcColorTranslator.ToWin32
	**
	** Translates the specified Color structure to a Windows color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/09/02: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ColorTranslator.ToWin32%28vs.80%29.aspx
	** Parameters:
	**  Color c
	** Returns: int
	*********************************************************************
	LPARAMETERS toColor AS xfcColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = BITOR(m.toColor.R,BITRSHIFT(m.toColor.G,0x08),BITRSHIFT(m.toColor.B,0x10))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION _initializehtmlsyscolortable
	*********************************************************************
		LOCAL loColor AS xfcColor
		
		IF VARTYPE(This._htmlSysColorTable) <> "O"
			m.loColor = CREATEOBJECT("xfcColor")
		
			This._htmlSysColorTable = CREATEOBJECT("Collection")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorActiveBorder), "activeborder")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorActiveCaption), "activecaption")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorAppWorkspace), "appworkspace")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorDesktop), "background")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorControl), "buttonface")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorControlLightLight), "buttonhighlight")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorControlDark), "buttonshadow")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorControlText), "buttontext")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorActiveCaptionText), "captiontext")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorGrayText), "graytext")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorHighlight), "highlight")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorHighlightText), "highlighttext")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorInactiveBorder), "inactiveborder")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorInactiveCaption), "inactivecaption")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorInactiveCaptionText), "inactivecaptiontext")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorInfo), "infobackground")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorInfoText), "infotext")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorMenu), "menu")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorMenuText), "menutext")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorScrollBar), "scrollbar")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorControlDarkDark), "threeddarkshadow")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorControl), "threedface")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorControlLight), "threedhighlight")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorControlLightLight), "threedlightshadow")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorWindow), "window")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorWindowFrame), "windowframe")
			This._htmlSysColorTable.Add(m.loColor.FromKnownColor(KnownColorWindowText), "windowtext")
		ENDIF
		
		RETURN
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="fromhtml" type="method" display="FromHtml"/>]+;
		[<memberdata name="fromole" type="method" display="FromOle"/>]+;
		[<memberdata name="fromwin32" type="method" display="FromWin32"/>]+;
		[<memberdata name="tohtml" type="method" display="ToHtml"/>]+;
		[<memberdata name="toole" type="method" display="ToOle"/>]+;
		[<memberdata name="towin32" type="method" display="ToWin32"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
DEFINE CLASS xfcdrawingbase AS xfcObject OF System.PRG
*************************************************************************
*************************************************************************
*************************************************************************

ENDDEFINE
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCFONT
DEFINE CLASS xfcFont AS xfcgpobject
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Font"
	Bold = 0	&& Gets a value that indicates whether this Font object is bold.
	FontFamily = 0	&& Gets the FontFamily object associated with this Font object.
	GdiCharSet = 0	&& Gets a byte value that specifies the GDI character set that this Font object uses.
	GdiVerticalFont = 0	&& Gets a Boolean value that indicates whether this Font object is derived from a GDI vertical font.
	Italic = 0	&& Gets a value that indicates whether this Font object is italic.
	lastresult = 0
	Size = 0	&& Gets the em-size of this Font object measured in the unit of this Font object.
	SizeInPoints = 0	&& Gets the em-size, in points, of this Font object.
	Strikeout = 0	&& Gets a value that indicates whether this Font object specifies a horizontal line through the font.
	Style = 0	&& Gets style information for this Font object.
	Underline = 0	&& Gets a value that indicates whether this Font object is underlined.
	Unit = 0	&& Gets the unit of measure for this Font object.
	PROTECTED _gdicharset
	_gdicharset = 1
	PROTECTED _gdiverticalfont
	_gdiverticalfont = .F.
	PROTECTED _name
	_name = ""
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcFont.Font
	**
	** Initializes a new Font object that uses the specified existing Font object and FontStyle
	** enumeration.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Font%28vs.80%29.aspx
	** Parameters:
	**  IntPtr htx
	**  Font prototype, FontStyle newStyle
	**  FontFamily family, float emSize
	**  string familyName, float emSize
	**  FontFamily family, float emSize, FontStyle style
	**  FontFamily family, float emSize, GraphicsUnit unit
	**  string familyName, float emSize, FontStyle style
	**  string familyName, float emSize, GraphicsUnit unit
	**  FontFamily family, float emSize, FontStyle style, GraphicsUnit unit
	**  string familyName, float emSize, FontStyle style, GraphicsUnit unit
	**  FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet
	**  string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet
	**  FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont
	**  string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont
	*********************************************************************
	LPARAMETERS teFamily, tnEmSize, ;
					tiStyle AS EnumFontStyle, tiUnit AS EnumGraphicsUnit, tiGdiCharSet AS Byte, tlGdiVerticalFont
	*********** toPrototype AS xfcFont, tiNewStyle AS EnumFontStyle
	** Note: these 2 overloads are the same as passing nothing for the font style
	*********** tcFamilyName, tnEmSize, tiUnit AS EnumGraphicsUnit
	*********** toFamily AS xfcFontFamily, tnEmSize, tiUnit AS EnumGraphicsUnit
		*!ToDo: Implement this overload
	*********** tHTx AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL lhFontFamily, lcFamilyName, lhFont, m.loFont AS xfcFont
		m.lhFontFamily = 0
		m.lcFamilyName = ""
		m.lhFont = 0
		m.loFont = NULL
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			IF VARTYPE(teFamily) = "L"
				m.teFamily = _SCREEN.FontName
				m.tnEmSize = _SCREEN.FontSize
			ENDIF
			
			DO CASE
		** NULL
			CASE VARTYPE(teFamily) = "X"	&& Family Name, Size
				EXIT
			
		** lcFamilyName, lnSize
			CASE VARTYPE(teFamily) = "C"	&& Family Name, Size
			** Support for font format returned from VFP's GETFONT function
				IF "," $ teFamily
					m.tnEmSize = VAL(GETWORDNUM(teFamily,2,","))
					m.lcStyle = GETWORDNUM(teFamily,3,",")
					m.teFamily = GETWORDNUM(teFamily,1,",")
					
					m.tiStyle = 0
					m.tiStyle = m.tiStyle + IIF("B" $ m.lcStyle, FontStyleBold, 0)
					m.tiStyle = m.tiStyle + IIF("I" $ m.lcStyle, FontStyleItalic, 0)
					m.tiStyle = m.tiStyle + IIF("-" $ m.lcStyle, FontStyleStrikeout, 0)
					m.tiStyle = m.tiStyle + IIF("U" $ m.lcStyle, FontStyleUnderline, 0)
					m.tiStyle = IIF("N" $ m.lcStyle, FontStyleRegular, m.tiStyle)
				ENDIF
					
				m.lcFamilyName = m.teFamily
				m.teFamily = CREATEOBJECT("xfcFontFamily", m.lcFamilyName)
				m.lhFontFamily = m.teFamily.Handle
			
		** loFontFamily, lnSize
			CASE VARTYPE(teFamily) = "O" AND teFamily.BaseName = "FontFamily"
				m.lhFontFamily = m.teFamily.Handle
				
		** loFont, liNewStyle
			CASE VARTYPE(teFamily) = "O" AND teFamily.BaseName = "Font"
				m.loFont = m.teFamily
				m.lhFontFamily = m.loFont.FontFamily.Handle
				m.teFamily = m.loFont.FontFamily
				m.tiStyle = m.tnEmSize
				m.tnEmSize = m.loFont.Size
				m.tiUnit = m.loFont.Unit
			ENDCASE
			
		** Handle optional parameters
			m.tiStyle = EVL(m.tiStyle, FontStyleRegular)	&& FontStyle = Regular
			m.tiUnit  = EVL(m.tiUnit, UnitPoint)	&& GraphicsUnit = point
			
			IF This.SetStatus(xfcGdipCreateFont(m.lhFontFamily, m.tnEmSize, m.tiStyle, m.tiUnit, @lhFont)) = 0		&& Ok
				This.Handle = m.lhFont
				This._name = m.teFamily.Name
			ENDIF
		
			*!ToDo: Figure out what these parameters do and implement the code for it
			This._GdiCharSet = EVL(m.tiGdiCharSet, 1)
			This._GdiVerticalFont = EVL(m.tlGdiVerticalFont, LEFT(This._name,1)=="@")
			
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcFont.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This.Handle <> 0
				This.SetStatus(xfcGdipDeleteFont(This.Handle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	** Property: New
	**
	** History:
	**  2006/03/08: BDurban - Coded
	*********************************************************************
	LPARAMETERS teFamily, tnEmSize, ;
					tiStyle AS EnumFontStyle, tiUnit AS EnumGraphicsUnit, tqGdiCharSet AS Char, tlGdiVerticalFont
		
		RETURN CREATEOBJECT(This.Class, m.teFamily, m.tnEmSize, ;
					m.tiStyle, m.tiUnit, m.tqGdiCharSet, m.tlGdiVerticalFont)
	ENDFUNC


	*********************************************************************
	FUNCTION Bold_ACCESS
	*********************************************************************
	** Property: Bold (Access)
	**
	** Gets a value that indicates whether this Font object is bold.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Bold%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN (BITAND(This.Style, FontStyleBold) = FontStyleBold)
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcFont.Clone
	**
	** Creates an exact copy of this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Clone%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: object
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loObject, lhObject
			m.lhObject = 0
			m.loObject = NULL
			This.SetStatus(xfcGdipCloneFont(This.Handle, @lhObject))
			IF(m.lhObject <> 0)
				m.loObject = CREATEOBJECT(This.Class)
				m.loObject.Handle = m.lhObject
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loObject
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcFont.Equals
	**
	** Indicates whether the specified object is a Font object and is identical to this
	** Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toFont AS xfcFont
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue
			m.llValue = (This.Name == m.toFont.Name AND This.SizeInPoints = m.toFont.SizeInPoints)
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION FontFamily_ACCESS
	*********************************************************************
	** Property: FontFamily (Access)
	**
	** Gets the FontFamily object associated with this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.FontFamily%28vs.80%29.aspx
	** Returns: FontFamily
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loFontFamily, lhFontFamily
		m.lhFontFamily = 0
		m.loFontFamily = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetFamily(This.Handle, @lhFontFamily))
			IF(m.lhFontFamily <> 0)
				m.loFontFamily = CREATEOBJECT("xfcFontFamily",NULL)
				m.loFontFamily.Handle = m.lhFontFamily
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loFontFamily
	ENDFUNC


	*********************************************************************
	FUNCTION FromHdc
	*********************************************************************
	** Method: xfcFont.FromHdc
	**
	** Creates a Font object from the specified Windows handle to a device context.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.FromHdc%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hdc
	** Returns: Font
	*********************************************************************
	LPARAMETERS tHDc AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loFont, lhFont
			m.lhFont = 0
			m.loFont = NULL
			This.SetStatus(xfcGdipCreateFontFromDC(m.lHdc, @lhFont))
			IF(m.lhFont <> 0)
				m.loFont = CREATEOBJECT(This.Class)
				m.loFont.Handle = m.lhFont
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loFont
	ENDFUNC


	*********************************************************************
	FUNCTION FromHfont
	*********************************************************************
	** Method: xfcFont.FromHfont
	**
	** Creates a Font object from the specified Windows handle.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.FromHfont%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hfont
	** Returns: Font
	*********************************************************************
	LPARAMETERS tHFont AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loFont, lqLogfont
			m.loFont = NULL
			
			m.lqLogfont = SYS(2600, tHFont, 60)
			m.loFont = This.FromLogFont(m.lqLogfont)
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loFont
	ENDFUNC


	*********************************************************************
	FUNCTION FromLogFont
	*********************************************************************
	** Method: xfcFont.FromLogFont
	**
	** Creates a Font object from the specified GDI LOGFONT structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.FromLogFont%28vs.80%29.aspx
	** Parameters:
	**  object lf
	**  object lf, IntPtr hdc
	** Returns: Font
	*********************************************************************
	LPARAMETERS tqLogfont AS VarBinary, ;
					tHDc AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loFont, lhFont, llReleaseHDC
			m.lhFont = 0
			m.loFont = NULL
			
			IF EMPTY(tHDc)
				llReleaseHDC = .T.
				tHDc = xfcGetDC(0)
			ENDIF
			
			This.SetStatus(xfcGdipCreateFontFromLogfontA(m.tHdc, @tqLogfont, @lhFont))
		*!*	This.SetStatus(xfcGdipCreateFontFromLogfontW(m.lHdc, @tqLogfont, @lhFont))
		
			IF(m.lhFont <> 0)
				m.loFont = CREATEOBJECT(This.Class)
				m.loFont.Handle = m.lhFont
			ENDIF
			
			IF llReleaseHDC
				xfcReleaseDC(tHDc)
			ENDIF
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loFont
	ENDFUNC


	*********************************************************************
	FUNCTION GdiCharSet_ACCESS
	*********************************************************************
	** Property: GdiCharSet (Access)
	**
	** Gets a byte value that specifies the GDI character set that this Font object uses.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.GdiCharSet%28vs.80%29.aspx
	** Returns: byte
	*********************************************************************
		
		*!ToDo: Test this function
		This.GdiCharSet = This._gdicharset
		RETURN This._gdicharset
	ENDFUNC


	*********************************************************************
	FUNCTION GdiVerticalFont_ACCESS
	*********************************************************************
	** Property: GdiVerticalFont (Access)
	**
	** Gets a Boolean value that indicates whether this Font object is derived from a GDI
	** vertical font.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.GdiVerticalFont%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		This.GdiVerticalFont = This._gdiverticalfont
		RETURN This._gdiverticalfont
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcFont.GetHashCode
	**
	** Gets the hash code for this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetHeight
	*********************************************************************
	** Method: xfcFont.GetHeight
	**
	** Returns the line spacing of this font.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2006/09/03: CChalom - fixed overload for PCOUNT() = 0
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.GetHeight%28vs.80%29.aspx
	** Parameters:
	**  [None]
	**  Graphics graphics
	**  float dpi
	** Returns: float
	*********************************************************************
	LPARAMETERS tnDpi
	*********** toGraphics AS xfcGraphics
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loGraphics as xfcGraphics
			LOCAL lnValue
			m.lnValue = 0.0
			
			DO CASE
			CASE PCOUNT() = 0
			
				* HDC xfcGetDC(
				*  HWND hWnd   // handle to window
				* [in] Handle to the window whose DC is to be retrieved.
				* If this value is NULL, GetDC retrieves the DC for the entire screen.
				* http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/devcons_4esj.asp	
		
				lhDC = xfcGetDC(0)
				m.loGraphics = CREATEOBJECT("xfcGraphics")
				m.loGraphics = m.loGraphics.FromHdcInternal(lhDC)
				This.SetStatus(xfcGdipGetFontHeight(This.Handle, m.loGraphics.Handle, @lnValue))
				xfcReleaseDC(0, lhDC)
		
			CASE VARTYPE(m.tnDpi) = "O" AND m.tnDpi.BaseName = "Graphics"
				m.loGraphics = m.tnDpi
				This.SetStatus(xfcGdipGetFontHeight(This.Handle, m.loGraphics.Handle, @lnValue))
			CASE VARTYPE(m.tnDpi) = "N"
				This.SetStatus(xfcGdipGetFontHeightGivenDPI(This.Handle, m.tnDpi, @lnValue))
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ACCESS
	*********************************************************************
	** Property: Height (Access)
	**
	** Gets the line spacing of this font.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Height%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN CEILING(This.GetHeight())
	ENDFUNC


	*********************************************************************
	FUNCTION Italic_ACCESS
	*********************************************************************
	** Property: Italic (Access)
	**
	** Gets a value that indicates whether this Font object is italic.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Italic%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN (BITAND(This.Style, FontStyleItalic) = FontStyleItalic)
	ENDFUNC


	*********************************************************************
	FUNCTION Name_ACCESS
	*********************************************************************
	** Property: Name (Access)
	**
	** Gets the face name of this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Name%28vs.80%29.aspx
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		
		IF This.Handle <> 0
	** It is possible, that the name can be called many times by the IDE.
	** Since the name cannot be changed, for performance, we will used a
	** cached version instead of calling the FontFamily_ACCESS method.
	**	RETURN This.FontFamily.Name
			RETURN This._name
		ELSE
			RETURN This.Name
		ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION SizeInPoints_ACCESS
	*********************************************************************
	** Property: SizeInPoints (Access)
	**
	** Gets the em-size, in points, of this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.SizeInPoints%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL lhDC, lnSize, loGfx AS xfcGraphics
		m.lhDC = 0
		m.lnSize = 0
		
		LOCAL loExc AS Exception
		TRY
			IF This.Unit = UnitPoint
				m.lnSize = This.Size
			ELSE
				m.lhDC = xfcGetDC(0)
				m.loGfx = CREATEOBJECT("xfcGraphics")
				m.loGfx = m.loGfx.FromHdc(lhDC)
				
				m.lnSize = ((This.GetHeight(m.loGfx) * This.FontFamily.GetEMHeight(This.Style)) / This.FontFamily.GetLineSpacing(This.Style)) / m.loGfx.DpiX
				
				xfcReleaseDC(0,m.lhDC)
				m.loGfx = NULL
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lnSize
	ENDFUNC


	*********************************************************************
	FUNCTION Size_ACCESS
	*********************************************************************
	** Property: Size (Access)
	**
	** Gets the em-size of this Font object measured in the unit of this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Size%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetFontSize(This.Handle, @lnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	FUNCTION Strikeout_ACCESS
	*********************************************************************
	** Property: Strikeout (Access)
	**
	** Gets a value that indicates whether this Font object specifies a horizontal line
	** through the font.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Strikeout%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN (BITAND(This.Style, FontStyleStrikeout) = FontStyleStrikeout)
	ENDFUNC


	*********************************************************************
	FUNCTION Style_ACCESS
	*********************************************************************
	** Property: Style (Access)
	**
	** Gets style information for this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Style%28vs.80%29.aspx
	** Returns: FontStyle
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liFontStyle
		m.liFontStyle = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetFontStyle(This.Handle, @liFontStyle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liFontStyle
	ENDFUNC


	*********************************************************************
	FUNCTION ToHfont
	*********************************************************************
	** Method: xfcFont.ToHfont
	**
	** Returns a handle to this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/08/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.ToHfont%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: IntPtr
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lhFont, lqLogFont
			
			m.lqLogFont = EMPTY_LOGFONT
			This.ToLogFont(@m.lqLogFont)
			m.lhFont = xfcCreateFontIndirect(@m.lqLogFont)
			*! ToDo: Check for errors here
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lhFont
	ENDFUNC


	*********************************************************************
	FUNCTION ToLogFont
	*********************************************************************
	** Method: xfcFont.ToLogFont
	**
	** Creates a GDI LOGFONT structure from this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/08/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.ToLogFont%28vs.80%29.aspx
	** Parameters:
	**  object logFont
	**  object logFont, Graphics graphics
	** Returns: void
	*********************************************************************
	LPARAMETERS tqLogFont AS VarBinary, ;
					toGraphics AS xfcGraphics
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lhDC, lcFontName
			lhDC = 0
			
			IF VARTYPE(m.toGraphics) <> "O"
				lhDC = xfcGetDC(0)
				m.toGraphics = CREATEOBJECT("xfcGraphics")
				m.toGraphics = m.toGraphics.FromHdc(lhDC)
			ENDIF
			
			m.tqLogFont = EMPTY_LOGFONT
			This.SetStatus(xfcGdipGetLogFontA(This.Handle, m.toGraphics.Handle, @m.tqLogFont))
			
			IF This._gdiverticalfont
				m.lcFontName = SUBSTR(m.tqLogFont, 29, 29)
				m.tqLogFont = STUFF(m.tqLogFont, 29, 30, "@"+m.lcFontName)
			ENDIF
			
			IF SUBSTR(m.tqLogFont, 24, 1) = 0h00
				m.tqLogFont = STUFF(m.tqLogFont, 24, 1, CHR(This._gdicharset))
			ENDIF
			
		CATCH TO loExc
			THROW_EXCEPTION
		FINALLY
			IF lhDC <> 0
				xfcReleaseDC(0,lhDC)
			ENDIF
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcFont.ToString
	**
	** Returns a human-readable string representation of this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lcValue
			m.lcValue = "[{0}: Name="+This.FontFamily.Name+", Size="+ALLTRIM(STR(This.Size))+", "+;
					"Units="+ALLTRIM(STR(This.Unit))+", GdiCharSet="+ALLTRIM(STR(This.GdiCharSet))+", "+;
					"GdiVerticalFont="+ALLTRIM(STR(This.GdiVerticalFont))+"]"
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lcValue
	ENDFUNC


	*********************************************************************
	FUNCTION Underline_ACCESS
	*********************************************************************
	** Property: Underline (Access)
	**
	** Gets a value that indicates whether this Font object is underlined.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Underline%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN (BITAND(This.Style, FontStyleUnderline) = FontStyleUnderline)
	ENDFUNC


	*********************************************************************
	FUNCTION Unit_ACCESS
	*********************************************************************
	** Property: Unit (Access)
	**
	** Gets the unit of measure for this Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Font.Unit%28vs.80%29.aspx
	** Returns: GraphicsUnit
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liGraphicsUnit
		m.liGraphicsUnit = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetFontUnit(This.Handle, @liGraphicsUnit))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liGraphicsUnit
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="fromhdc" type="method" display="FromHdc"/>]+;
		[<memberdata name="fromhfont" type="method" display="FromHfont"/>]+;
		[<memberdata name="fromlogfont" type="method" display="FromLogFont"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getheight" type="method" display="GetHeight"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="tohfont" type="method" display="ToHfont"/>]+;
		[<memberdata name="tologfont" type="method" display="ToLogFont"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="bold" type="property" display="Bold"/>]+;
		[<memberdata name="fontfamily" type="property" display="FontFamily"/>]+;
		[<memberdata name="gdicharset" type="property" display="GdiCharSet"/>]+;
		[<memberdata name="gdiverticalfont" type="property" display="GdiVerticalFont"/>]+;
		[<memberdata name="height" type="property" display="Height"/>]+;
		[<memberdata name="italic" type="property" display="Italic"/>]+;
		[<memberdata name="name" type="property" display="Name"/>]+;
		[<memberdata name="size" type="property" display="Size"/>]+;
		[<memberdata name="sizeinpoints" type="property" display="SizeInPoints"/>]+;
		[<memberdata name="strikeout" type="property" display="Strikeout"/>]+;
		[<memberdata name="style" type="property" display="Style"/>]+;
		[<memberdata name="underline" type="property" display="Underline"/>]+;
		[<memberdata name="unit" type="property" display="Unit"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************


*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCFONTFAMILY
DEFINE CLASS xfcFontFamily AS xfcgpobject
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "FontFamily"
	Families = 0	&& Returns an array that contains all the FontFamily objects associated with the current graphics context.
	GenericMonospace = 0	&& Gets a generic monospace FontFamily object.
	GenericSansSerif = 0	&& Gets a generic sans serif FontFamily object.
	GenericSerif = 0	&& Gets a generic serif FontFamily object.
	lastresult = 0
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcFontFamily.FontFamily
	**
	** Initializes a new FontFamily object that uses the specified name.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.FontFamily%28vs.80%29.aspx
	** Parameters:
	**  GenericFontFamilies genericFamily
	**  string name
	**  string name, FontCollection fontCollection
	*********************************************************************
	LPARAMETERS tcName, toFontCollection AS xfcFontCollection
	*********** tiGenericFamily AS EnumGenericFontFamilies
		
		*!ToDo: Test this function
		
		LOCAL lhFontCollection, lhFontFamily, liGenericFamily
		m.lhFontCollection = 0
		m.lhFontFamily = 0
		m.liGenericFamily = 0
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			DO CASE
			CASE VARTYPE(tcName) = "X"		&& NULL object
				EXIT
				
			CASE VARTYPE(tcName) = "N" 		&& GenericFamily
				m.liGenericFamily = m.tcName
				DO CASE
				CASE liGenericFamily = 1	&& Monospace
					This.SetStatus(xfcGdipGetGenericFontFamilyMonospace(@lhFontFamily))
				CASE liGenericFamily = 2	&& SansSerif
					This.SetStatus(xfcGdipGetGenericFontFamilySansSerif(@lhFontFamily))
				CASE liGenericFamily = 3	&& Serif
					This.SetStatus(xfcGdipGetGenericFontFamilySerif(@lhFontFamily))
				ENDCASE
			
			CASE VARTYPE(tcName) = "C"
				IF VARTYPE(m.toFontCollection) = "O" AND m.toFontCollection.BaseName = "FontCollection"
					m.lhFontCollection = m.toFontCollection.Handle
				ENDIF
				m.tcName = PADR(m.tcName, LF_FACESIZE, 0h00) + 0h00
				This.SetStatus(xfcGdipCreateFontFamilyFromName(STRCONV(m.tcName,5), m.lhFontCollection, @lhFontFamily))
			ENDCASE
			This.Handle = m.lhFontFamily
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcFontFamily.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This.Handle <> 0
				This.SetStatus(xfcGdipDeleteFontFamily(This.Handle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	** Method: xfcFontFamily.New
	**
	** History:
	**  2006/03/08: BDurban - Coded
	*********************************************************************
	LPARAMETERS tcName, toFontCollection AS xfcFontCollection
		
		RETURN CREATEOBJECT(This.Class, m.tcName, m.toFontCollection)
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcFontFamily.Equals
	**
	** Indicates whether the specified object is a FontFamily object and is identical to
	** this FontFamily object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/13: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toFamily AS xfcFontFamily
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue
			m.llValue = (This.GetName() == m.toFamily.Getname())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION Families_ACCESS
	*********************************************************************
	** Property: Families (Access)
	**
	** Returns an array that contains all the FontFamily objects associated with the current
	** graphics context.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/08/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.Families%28vs.80%29.aspx
	** Returns: FontFamily[]
	*********************************************************************
		
		*!ToDo: Test this function
		
		IF VARTYPE(This.Families) <> "O"
			This.Families = This.GetFamilies()
		ENDIF
		
		RETURN This.Families
	ENDFUNC


	*********************************************************************
	FUNCTION GenericMonospace_ACCESS
	*********************************************************************
	** Property: GenericMonospace (Access)
	**
	** Gets a generic monospace FontFamily object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GenericMonospace%28vs.80%29.aspx
	** Returns: FontFamily
	*********************************************************************
		
		RETURN This.New( GenericFontFamilyMonospace )
	ENDFUNC


	*********************************************************************
	FUNCTION GenericSansSerif_ACCESS
	*********************************************************************
	** Property: GenericSansSerif (Access)
	**
	** Gets a generic sans serif FontFamily object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GenericSansSerif%28vs.80%29.aspx
	** Returns: FontFamily
	*********************************************************************
		
		RETURN This.New( GenericFontFamilySansSerif )
	ENDFUNC


	*********************************************************************
	FUNCTION GenericSerif_ACCESS
	*********************************************************************
	** Property: GenericSerif (Access)
	**
	** Gets a generic serif FontFamily object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GenericSerif%28vs.80%29.aspx
	** Returns: FontFamily
	*********************************************************************
		
		RETURN This.New( GenericFontFamilySerif )
	ENDFUNC


	*********************************************************************
	FUNCTION GetCellAscent
	*********************************************************************
	** Method: xfcFontFamily.GetCellAscent
	**
	** Returns the cell ascent, in design units, of the FontFamily object of the specified
	** style. For information about font metrics, see Obtaining Font Metrics.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GetCellAscent%28vs.80%29.aspx
	** Parameters:
	**  FontStyle style
	** Returns: int
	*********************************************************************
	LPARAMETERS tiStyle AS EnumFontStyle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
			This.SetStatus(xfcGdipGetCellAscent(This.Handle, m.tiStyle, @liValue))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetCellDescent
	*********************************************************************
	** Method: xfcFontFamily.GetCellDescent
	**
	** Returns the cell descent, in design units, of the FontFamily object of the specified
	** style. For information about font metrics, see Obtaining Font Metrics.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GetCellDescent%28vs.80%29.aspx
	** Parameters:
	**  FontStyle style
	** Returns: int
	*********************************************************************
	LPARAMETERS tiStyle AS EnumFontStyle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
			This.SetStatus(xfcGdipGetCellDescent(This.Handle, m.tiStyle, @liValue))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetEmHeight
	*********************************************************************
	** Method: xfcFontFamily.GetEmHeight
	**
	** Gets the height, in font design units, of the em square for the specified style.
	** For information about font metrics, see Obtaining Font Metrics.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2006/07/08: BDurban - Fixed
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GetEmHeight%28vs.80%29.aspx
	** Parameters:
	**  FontStyle style
	** Returns: int
	*********************************************************************
	LPARAMETERS tiStyle AS EnumFontStyle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
			This.SetStatus(xfcGdipGetEmHeight(This.Handle, m.tiStyle, @liValue))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetFamilies
	*********************************************************************
	** Method: xfcFontFamily.GetFamilies
	**
	** Returns an array that contains all the FontFamily objects available for the specified
	** graphics context.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/08/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GetFamilies%28vs.80%29.aspx
	** Parameters:
	**  Graphics graphics
	** Returns: FontFamily[]
	*********************************************************************
	LPARAMETERS toGraphics AS xfcGraphics
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loFamilies, loInstalled AS xfcInstalledFontCollection
			
			m.loInstalled = NEWOBJECT("xfcInstalledFontCollection", XFCCLASS_TEXT)
			m.loFamilies = m.loInstalled.Families
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loFamilies
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcFontFamily.GetHashCode
	**
	** Gets a hash code for this FontFamily object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetLineSpacing
	*********************************************************************
	** Method: xfcFontFamily.GetLineSpacing
	**
	** Returns the line spacing, in design units, of the FontFamily object of the specified
	** style. The line spacing is the vertical distance between the base lines of two consecutive
	** lines of text. For information about font metrics, see Obtaining Font Metrics.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GetLineSpacing%28vs.80%29.aspx
	** Parameters:
	**  FontStyle style
	** Returns: int
	*********************************************************************
	LPARAMETERS tiStyle AS EnumFontStyle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
			This.SetStatus(xfcGdipGetLineSpacing(This.Handle, m.tiStyle, @liValue))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetName
	*********************************************************************
	** Method: xfcFontFamily.GetName
	**
	** Returns the name, in the specified language, of this FontFamily object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/04: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.GetName%28vs.80%29.aspx
	** Parameters:
	**  int language
	** Returns: string
	*********************************************************************
	LPARAMETERS tiLanguage
		
		LOCAL lcValue
		m.lcValue = STRCONV(REPLICATE(0h00, LF_FACESIZE),5)
		*! ToDo: Determine the correct default value for language
		m.tiLanguage = EVL(m.tiLanguage, 0)
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetFamilyName(This.Handle, @lcValue, m.tiLanguage))
			m.lcValue = STRCONV(m.lcValue,6)
			m.lcValue = LEFT(m.lcValue, AT(0h00, m.lcValue)-1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lcValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsStyleAvailable
	*********************************************************************
	** Method: xfcFontFamily.IsStyleAvailable
	**
	** Indicates whether the specified FontStyle enumeration is available.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.IsStyleAvailable%28vs.80%29.aspx
	** Parameters:
	**  FontStyle style
	** Returns: bool
	*********************************************************************
	LPARAMETERS tiStyle AS EnumFontStyle
		
		*!ToDo: Test this function
		
		LOCAL llValue, liIsStyleAvailable
		m.llValue = .F.
		m.liIsStyleAvailable = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipIsStyleAvailable(This.Handle, m.tiStyle, @liIsStyleAvailable))
			m.llValue = (liIsStyleAvailable <> 0)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION Name_ACCESS
	*********************************************************************
	** Property: Name (Access)
	**
	** Gets the name of this FontFamily object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**	2006/05/04: BDurban - Changed to call GetName
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.Name%28vs.80%29.aspx
	** Returns: string
	*********************************************************************
		
		RETURN This.GetName()
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcFontFamily.ToString
	**
	** Converts this FontFamily object to a human-readable string representation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/13: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.FontFamily.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lcValue
			m.lcValue = "[FontFamily: Name="+This.GetName()+"]"
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lcValue
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="getcellascent" type="method" display="GetCellAscent"/>]+;
		[<memberdata name="getcelldescent" type="method" display="GetCellDescent"/>]+;
		[<memberdata name="getemheight" type="method" display="GetEmHeight"/>]+;
		[<memberdata name="getfamilies" type="method" display="GetFamilies"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="getlinespacing" type="method" display="GetLineSpacing"/>]+;
		[<memberdata name="getname" type="method" display="GetName"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="isstyleavailable" type="method" display="IsStyleAvailable"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="families" type="property" display="Families"/>]+;
		[<memberdata name="genericmonospace" type="property" display="GenericMonospace"/>]+;
		[<memberdata name="genericsansserif" type="property" display="GenericSansSerif"/>]+;
		[<memberdata name="genericserif" type="property" display="GenericSerif"/>]+;
		[<memberdata name="name" type="property" display="Name"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
DEFINE CLASS xfcGdipToken AS xfcObject OF System.PRG
*************************************************************************
*************************************************************************
*************************************************************************
	namedcolors = .NULL.
	PROTECTED gdiplustoken
	gdiplustoken = 0
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
		LOCAL lqGdiplusStartupInput, lhToken
		
		* Initialize GDI+.
		DECLARE Long GdiplusStartup IN GDIPLUS.DLL Long @token, String @input, Long @output
		
		* struct GdiplusStartupInput
		* {
		* UINT32 GdiplusVersion; // Must be 1
		* DebugEventProc DebugEventCallback; // Ignored on free builds
		* BOOL SuppressBackgroundThread; // FALSE unless you're prepared to call
		* // the hook/unhook functions properly
		* BOOL SuppressExternalCodecs; // FALSE unless you want GDI+ only to use
		* // its internal image codecs.
		* }
		* GdiplusStartupInput structure (sizeof = 16)
		
		lqGdiplusStartupInput = ;
		   		0h0100000000000000+;
		   		0h0000000000000000
		lhToken = 0
		IF GdiplusStartup(@lhToken, @lqGdiplusStartupInput, 0) != 0
			RETURN .F.
		ENDIF
		This.gdiplusToken = lhToken
		
*		SET CLASSLIB TO (ADDBS(JUSTPATH(This.ClassLibrary))+"system") ADDITIVE
		
		This.InitKnownColors()
		
		ADDPROPERTY(This,"KnownColorTable",CREATEOBJECT("_xfcKnownColorTable"))
		
			
	ENDFUNC


	*********************************************************************
	FUNCTION InitKnownColors
	*********************************************************************
		
		
		This.NamedColors = CREATEOBJECT("Collection")
		WITH This.NamedColors
			.Add(-984833,"aliceblue")
			.Add(-332841,"antiquewhite")
			.Add(-16711681,"aqua")
			.Add(-8388652,"aquamarine")
			.Add(-983041,"azure")
			.Add(-657956,"beige")
			.Add(-6972,"bisque")
			.Add(-16777216,"black")
			.Add(-5171,"blanchedalmond")
			.Add(0xff0000ff,"blue")
			.Add(-7722014,"blueviolet")
			.Add(-5952982,"brown")
			.Add(-2180985,"burlywood")
			.Add(-10510688,"cadetblue")
			.Add(-8388864,"chartreuse")
			.Add(-2987746,"chocolate")
			.Add(-32944,"coral")
			.Add(-10185235,"cornflowerblue")
			.Add(-1828,"cornsilk")
			.Add(-2354116,"crimson")
			.Add(-16711681,"cyan")
			.Add(-16777077,"darkblue")
			.Add(-16741493,"darkcyan")
			.Add(-4684277,"darkgoldenrod")
			.Add(-5658199,"darkgray")
			.Add(-16751616,"darkgreen")
			.Add(-4343957,"darkkhaki")
			.Add(-7667573,"darkmagenta")
			.Add(-11179217,"darkolivegreen")
			.Add(-29696,"darkorange")
			.Add(-6737204,"darkorchid")
			.Add(-7667712,"darkred")
			.Add(-1468806,"darksalmon")
			.Add(-7357301,"darkseagreen")
			.Add(-12042869,"darkslateblue")
			.Add(-13676721,"darkslategray")
			.Add(-16724271,"darkturquoise")
			.Add(-7077677,"darkviolet")
			.Add(-60269,"deeppink")
			.Add(-16728065,"deepskyblue")
			.Add(-9868951,"dimgray")
			.Add(-14774017,"dodgerblue")
			.Add(-5103070,"firebrick")
			.Add(-1296,"floralwhite")
			.Add(-14513374,"forestgreen")
			.Add(-65281,"fuchsia")
			.Add(-2302756,"gainsboro")
			.Add(-460545,"ghostwhite")
			.Add(-10496,"gold")
			.Add(-2448096,"goldenrod")
			.Add(-8355712,"gray")
			.Add(0xff00ff00,"green")
			.Add(-5374161,"greenyellow")
			.Add(-983056,"honeydew")
			.Add(-38476,"hotpink")
			.Add(-3318692,"indianred")
			.Add(-11861886,"indigo")
			.Add(-16,"ivory")
			.Add(-989556,"khaki")
			.Add(-1644806,"lavender")
			.Add(-3851,"lavenderblush")
			.Add(-8586240,"lawngreen")
			.Add(-1331,"lemonchiffon")
			.Add(-5383962,"lightblue")
			.Add(-1015680,"lightcoral")
			.Add(-2031617,"lightcyan")
			.Add(-329006,"lightgoldenrodyellow")
			.Add(-2894893,"lightgray")
			.Add(-7278960,"lightgreen")
			.Add(-18751,"lightpink")
			.Add(-24454,"lightsalmon")
			.Add(-14634326,"lightseagreen")
			.Add(-7876870,"lightskyblue")
			.Add(-8943463,"lightslategray")
			.Add(-5192482,"lightsteelblue")
			.Add(-32,"lightyellow")
			.Add(-16711936,"lime")
			.Add(-13447886,"limegreen")
			.Add(-331546,"linen")
			.Add(-65281,"magenta")
			.Add(-8388608,"maroon")
			.Add(-10039894,"mediumaquamarine")
			.Add(-16777011,"mediumblue")
			.Add(-4565549,"mediumorchid")
			.Add(-7114533,"mediumpurple")
			.Add(-12799119,"mediumseagreen")
			.Add(-8689426,"mediumslateblue")
			.Add(-16713062,"mediumspringgreen")
			.Add(-12004916,"mediumturquoise")
			.Add(-3730043,"mediumvioletred")
			.Add(-15132304,"midnightblue")
			.Add(-655366,"mintcream")
			.Add(-6943,"mistyrose")
			.Add(-6987,"moccasin")
			.Add(-8531,"navajowhite")
			.Add(-16777088,"navy")
			.Add(-133658,"oldlace")
			.Add(-8355840,"olive")
			.Add(-9728477,"olivedrab")
			.Add(-23296,"orange")
			.Add(-47872,"orangered")
			.Add(-2461482,"orchid")
			.Add(-1120086,"palegoldenrod")
			.Add(-6751336,"palegreen")
			.Add(-5247250,"paleturquoise")
			.Add(-2396013,"palevioletred")
			.Add(-4139,"papayawhip")
			.Add(-9543,"peachpuff")
			.Add(-3308225,"peru")
			.Add(-16181,"pink")
			.Add(-2252579,"plum")
			.Add(-5185306,"powderblue")
			.Add(-8388480,"purple")
			.Add(0xffff0000,"red")
			.Add(-4419697,"rosybrown")
			.Add(-12490271,"royalblue")
			.Add(-7650029,"saddlebrown")
			.Add(-360334,"salmon")
			.Add(-744352,"sandybrown")
			.Add(-13726889,"seagreen")
			.Add(-2578,"seashell")
			.Add(-6270419,"sienna")
			.Add(-4144960,"silver")
			.Add(-7876885,"skyblue")
			.Add(-9807155,"slateblue")
			.Add(-9404272,"slategray")
			.Add(-1286,"snow")
			.Add(-16711809,"springgreen")
			.Add(-12156236,"steelblue")
			.Add(-2968436,"tan")
			.Add(-16744320,"teal")
			.Add(-2572328,"thistle")
			.Add(-40121,"tomato")
			.Add(0,"transparent")
			.Add(-12525360,"turquoise")
			.Add(-1146130,"violet")
			.Add(-663885,"wheat")
			.Add(-1,"white")
			.Add(-657931,"whitesmoke")
			.Add(-256,"yellow")
			.Add(-6632142,"yellowgreen")
		ENDWITH
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
		
		DECLARE Long GdiplusShutdown IN GDIPLUS.DLL Long token
		GdiplusShutdown(This.gdiplusToken)
	ENDFUNC


	*********************************************************************
	FUNCTION NamedColor
	*********************************************************************
	LPARAMETERS tcColorName
		
		m.tcColorName = LOWER(m.tcColorName)
		
		IF This.NamedColors.GetKey(m.tcColorName) > 0
			RETURN BITRSHIFT(This.NamedColors.Item(m.tcColorName),0)
		ENDIF
		
		RETURN NULL
	ENDFUNC

ENDDEFINE
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
DEFINE CLASS xfcGpObject AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	Handle = 0
	PROTECTED LastResult
	LastResult = 0
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Initialize the GDI Plus library
		IF VARTYPE(_SCREEN.GDIPToken) <> "O"
			ADDPROPERTY(_SCREEN, "GDIPToken", CREATEOBJECT("xfcGDIPToken"))
		ENDIF
		
	ENDFUNC


	*********************************************************************
	FUNCTION Dispose
	*********************************************************************
		RELEASE This
	ENDFUNC


	*********************************************************************
	FUNCTION GetHandle
	*********************************************************************
	** Method: xfcgpobject.GetHandle
	**
	** Added for support with _gdiplus FFC classes.
	**
	** History:
	**  2006/08/??: BDurban/CChalom - Coded
	*********************************************************************
		RETURN This.Handle
	ENDFUNC


	*********************************************************************
	FUNCTION GetLastStatus
	*********************************************************************
		LOCAL lnLastStatus
		m.lnLastStatus = This.LastResult
		This.LastResult = 0
		
		RETURN m.lnLastStatus
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION SetStatus
	*********************************************************************
	LPARAMETERS tnStatus
		
		LOCAL loExc AS Exception
		LOCAL lcText
		
		IF m.tnStatus <> 0
			IF This.LastResult = 0
				This.LastResult = m.tnStatus
			ENDIF
			
			DO CASE
			CASE m.tnStatus = StatusGenericError
				m.lcText = "GdiPlusError:GenericError"
			CASE m.tnStatus = StatusInvalidParameter
				m.lcText = "GdiPlusError:InvalidParameter"
			CASE m.tnStatus = StatusOutOfMemory
				m.lcText = "GdiPlusError:OutOfMemory"
			CASE m.tnStatus = StatusObjectBusy
				m.lcText = "GdiPlusError:"
			CASE m.tnStatus = StatusInsufficientBuffer
				m.lcText = "GdiPlusError:InsufficientBuffer"
			CASE m.tnStatus = StatusNotImplemented
				m.lcText = "GdiPlusError:NotImplemented"
			CASE m.tnStatus = StatusWin32Error
				m.lcText = "GdiPlusError:Win32Error"
			CASE m.tnStatus = StatusWrongState
				m.lcText = "GdiPlusError:WrongState"
			CASE m.tnStatus = StatusAborted
				m.lcText = "GdiPlusError:Aborted"
			CASE m.tnStatus = StatusFileNotFound
				m.lcText = "GdiPlusError:FileNotFound"
			CASE m.tnStatus = StatusValueOverflow
				m.lcText = "GdiPlusError:ValueOverflow"
			CASE m.tnStatus = StatusAccessDenied
				m.lcText = "GdiPlusError:AccessDenied"
			CASE m.tnStatus = StatusUnknownImageFormat
				m.lcText = "GdiPlusError:UnknownImageFormat"
			CASE m.tnStatus = StatusFontFamilyNotFound
				m.lcText = "GdiPlusError:FontFamilyNotFound"
			CASE m.tnStatus = StatusFontStyleNotFound
				m.lcText = "GdiPlusError:FontStyleNotFound"
			CASE m.tnStatus = StatusNotTrueTypeFont
				m.lcText = "GdiPlusError:NotTrueTypeFont"
			CASE m.tnStatus = StatusUnsupportedlusVersion
				m.lcText = "GdiPlusError:UnsupportedlusVersion"
			CASE m.tnStatus = StatusGdiPlusNotInitialized
				m.lcText = "GdiPlusError:GdiPlusNotInitialized"
			CASE m.tnStatus = StatusPropertyNotFound
				m.lcText = "GdiPlusError:PropertyNotFound"
			CASE m.tnStatus = StatusPropertyNotSupported
				m.lcText = "GdiPlusError:PropertyNotSupported"
			OTHERWISE
				m.lcText = "GdiPlusError:UnknownError ("+ALLTRIM(STR(m.tnStatus))+")"
			ENDCASE
			
			ASSERT .F. MESSAGE m.lcText
		
		*	ERROR m.lcText
		ENDIF
		
		RETURN m.tnStatus
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="getlaststatus" type="method" display="GetLastStatus"/>]+;
		[<memberdata name="lastresult" type="property" display="LastResult"/>]+;
		[<memberdata name="setstatus" type="method" display="SetStatus"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="handle" type="property" display="Handle"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCGRAPHICS
DEFINE CLASS xfcGraphics AS xfcgpobject
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Graphics"
	Clip = 0	&& Gets or sets a Region object that limits the drawing region of this Graphics object.
	ClipBounds = 0	&& Gets a RectangleF structure that bounds the clipping region of this Graphics object.
	CompositingMode = 0	&& Gets a value that specifies how composited images are drawn to this Graphics object.
	CompositingQuality = 0	&& Gets or sets the rendering quality of composited images drawn to this Graphics object.
	DpiX = 0	&& Gets the horizontal resolution of this Graphics object.
	DpiY = 0	&& Gets the vertical resolution of this Graphics object.
	InterpolationMode = 0	&& Gets or sets the interpolation mode associated with this Graphics object.
	IsClipEmpty = 0	&& Gets a value indicating whether the clipping region of this Graphics object is empty.
	IsVisibleClipEmpty = 0	&& Gets a value indicating whether the visible clipping region of this Graphics object is empty.
	lastresult = 0
	PageScale = 0	&& Gets or sets the scaling between world units and page units for this Graphics object.
	PageUnit = 0	&& Gets or sets the unit of measure used for page coordinates in this Graphics object.
	PixelOffsetMode = 0	&& Gets or set a value specifying how pixels are offset during rendering of this Graphics object.
	RenderingOrigin = 0	&& Gets or sets the rendering origin of this Graphics object for dithering and for hatch brushes.
	SmoothingMode = 0	&& Gets or sets the rendering quality for this Graphics object.
	TextContrast = 0	&& Gets or sets the gamma correction value for rendering text.
	TextRenderingHint = 0	&& Gets or sets the rendering mode for text associated with this Graphics object.
	Transform = 0	&& Gets or sets the world transformation for this Graphics object.
	useprecision = .T.
	VisibleClipBounds = 0	&& Gets or sets the bounding rectangle of the visible clipping region of this Graphics object.
	DIMENSION _internalarray[1]

 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcGraphics.Graphics
	**
	** Encapsulates a GDI+ drawing surface. This class cannot be inherited.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcGraphics.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This.Handle <> 0
				This.SetStatus(xfcGdipDeleteGraphics(This.Handle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION AddMetafileComment
	*********************************************************************
	** Method: xfcGraphics.AddMetafileComment
	**
	** Adds a comment to the current Metafile object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.AddMetafileComment%28vs.80%29.aspx
	** Parameters:
	**  byte[] data
	** Returns: void
	*********************************************************************
	LPARAMETERS tqData AS VarBinary
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liSizeData
			liSizeData = LEN(tqData)
			This.SetStatus(xfcGdipComment(This.Handle, m.liSizeData, @tqData))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION BeginContainer
	*********************************************************************
	** Method: xfcGraphics.BeginContainer
	**
	** Saves a graphics container with the current state of this Graphics object and opens
	** and uses a new graphics container.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.BeginContainer%28vs.80%29.aspx
	** Parameters:
	**  [None]
	**  Rectangle dstrect, Rectangle srcrect, GraphicsUnit unit
	**  RectangleF dstrect, RectangleF srcrect, GraphicsUnit unit
	** Returns: GraphicsContainer
	*********************************************************************
	LPARAMETERS toDstRect AS xfcRectangle, toSrcRect AS xfcRectangle, tiUnit AS EnumGraphicsUnit
	********** [None]
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loGraphicsContainer, lhGraphicsContainer
			m.lhGraphicsContainer = 0
			m.loGraphicsContainer = NULL
			
			DO CASE
			CASE VARTYPE(toDstRect)="O" AND m.toDstRect.BaseName="RectangleF"
				This.SetStatus(xfcGdipBeginContainer(This.Handle, m.toDstRect.ToVarBinary(), m.toSrcRect.ToVarBinary(), m.tiUnit, @lhGraphicsContainer ))
				
			CASE VARTYPE(toDstRect)="O" AND m.toDstRect.BaseName="Rectangle"
				This.SetStatus(xfcGdipBeginContainerI(This.Handle, m.toDstRect.ToVarBinary(), m.toSrcRect.ToVarBinary(), m.tiUnit, @lhGraphicsContainer ))
				
			OTHERWISE
				This.SetStatus(xfcGdipBeginContainer2(This.Handle, @lhGraphicsContainer ))
				
			ENDCASE
			IF(m.lhGraphicsContainer <> 0)
				m.loGraphicsContainer = CREATEOBJECT("xfcGraphicsContainer")
				m.loGraphicsContainer.Handle = m.lhGraphicsContainer
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loGraphicsContainer
	ENDFUNC


	*********************************************************************
	FUNCTION Clear
	*********************************************************************
	** Method: xfcGraphics.Clear
	**
	** Clears the entire drawing surface and fills it with the specified background color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.Clear%28vs.80%29.aspx
	** Parameters:
	**  Color color
	** Returns: void
	*********************************************************************
	LPARAMETERS toColor AS xfcColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGraphicsClear(This.Handle, m.toColor.Argb))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ClipBounds_ACCESS
	*********************************************************************
	** Property: ClipBounds (Access)
	**
	** Gets a RectangleF structure that bounds the clipping region of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.ClipBounds%28vs.80%29.aspx
	** Returns: RectangleF
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loRectangleF AS xfcRectangle
		m.loRectangle = NULL
		
		LOCAL loExc AS Exception
		LOCAL lcRect
		TRY
			IF This.UsePrecision
				m.lcRect = EMPTY_RECTANGLEF
				This.SetStatus(xfcGdipGetClipBounds(This.Handle, @lcRect))
				m.loRectangle = CREATEOBJECT("xfcRectangleF", m.lcRect)
			ELSE
				m.lcRect = EMPTY_RECTANGLE
				This.SetStatus(xfcGdipGetClipBoundsI(This.Handle, @lcRect))
				m.loRectangle = CREATEOBJECT("xfcRectangle", m.lcRect)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loRectangle
	ENDFUNC


	*********************************************************************
	FUNCTION Clip_ACCESS
	*********************************************************************
	** Property: Clip (Access)
	**
	** Gets or sets a Region object that limits the drawing region of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.Clip%28vs.80%29.aspx
	** Returns: Region
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loRegion, lhRegion
		m.lhRegion = 0
		m.loRegion = NULL
		
		LOCAL loExc AS Exception
		TRY
			m.loRegion = CREATEOBJECT("xfcRegion")
			This.SetStatus(xfcGdipGetClip(This.Handle, m.loRegion.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loRegion
	ENDFUNC


	*********************************************************************
	FUNCTION Clip_ASSIGN
	*********************************************************************
	** Property: Clip (Assign)
	**
	** Gets or sets a Region object that limits the drawing region of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/14: BDurban - Coded
	*********************************************************************
	LPARAMETERS toRegion
		
		*!ToDo: Test this function
		IF VARTYPE(m.toRegion) = "O"
			This.SetClip(m.toRegion, CombineModeReplace)
		ENDIF
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION CompositingMode_ACCESS
	*********************************************************************
	** Property: CompositingMode (Access)
	**
	** Gets a value that specifies how composited images are drawn to this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.CompositingMode%28vs.80%29.aspx
	** Returns: CompositingMode
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liCompositingMode
		m.liCompositingMode = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetCompositingMode(This.Handle, @liCompositingMode))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liCompositingMode
	ENDFUNC


	*********************************************************************
	FUNCTION CompositingMode_ASSIGN
	*********************************************************************
	** Property: CompositingMode (Assign)
	**
	** Gets a value that specifies how composited images are drawn to this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiCompositingMode
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetCompositingMode(This.Handle, m.tiCompositingMode))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION CompositingQuality_ACCESS
	*********************************************************************
	** Property: CompositingQuality (Access)
	**
	** Gets or sets the rendering quality of composited images drawn to this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.CompositingQuality%28vs.80%29.aspx
	** Returns: CompositingQuality
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liCompositingQuality
		m.liCompositingQuality = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetCompositingQuality(This.Handle, @liCompositingQuality))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liCompositingQuality
	ENDFUNC


	*********************************************************************
	FUNCTION CompositingQuality_ASSIGN
	*********************************************************************
	** Property: CompositingQuality (Assign)
	**
	** Gets or sets the rendering quality of composited images drawn to this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiCompositingQuality
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetCompositingQuality(This.Handle, m.tiCompositingQuality))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DpiX_ACCESS
	*********************************************************************
	** Property: DpiX (Access)
	**
	** Gets the horizontal resolution of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DpiX%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetDpiX(This.Handle, @lnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	FUNCTION DpiY_ACCESS
	*********************************************************************
	** Property: DpiY (Access)
	**
	** Gets the vertical resolution of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DpiY%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetDpiY(This.Handle, @lnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	FUNCTION DrawArc
	*********************************************************************
	** Method: xfcGraphics.DrawArc
	**
	** Draws an arc representing a portion of an ellipse specified by a pair of coordinates,
	** a width, and a height.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawArc%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Rectangle rect, float startAngle, float sweepAngle
	**  Pen pen, RectangleF rect, float startAngle, float sweepAngle
	**  Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle
	**  Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, tnX, tnY, tnWidth, tnHeight, tnStartAngle, tnSweepAngle
	*********** toPen AS xfcPen, toRect AS xfcRectangle, tnStartAngle, tnSweepAngle
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 4	&& Pen, Rectangle, Number, Number
				m.loRect = tnX
				m.tnSweepAngle = m.tnHeight
				m.tnStartAngle = m.tnWidth
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
			CASE PCOUNT() = 7
			ENDCASE
		
			IF This.UsePrecision
				This.SetStatus(xfcGdipDrawArc(This.Handle, m.toPen.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
			ELSE
				This.SetStatus(xfcGdipDrawArcI(This.Handle, m.toPen.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawBezier
	*********************************************************************
	** Method: xfcGraphics.DrawBezier
	**
	** Draws a Bezier spline defined by four Point structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/01: BDurban - Fixed variable. Was lnX4 changed to tnX4
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawBezier%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Point pt1, Point pt2, Point pt3, Point pt4
	**  Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4
	**  Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, tnX1, tnY1, tnX2, tnY2, tnX3, tnY3, tnX4, tnY4
	*********** toPen AS xfcPen, toPt1 AS xfcPoint, toPt2 AS xfcPoint, toPt3 AS xfcPoint, toPt4 AS xfcPoint
	#IFNDEF GDIPX_SIMPLEDRAWING
		*!ToDo: Test this function
		
		LOCAL loPt1, loPt2, loPt3, loPt4
		LOCAL llPrecision
		STORE NULL TO loPt1, loPt2, loPt3, loPt4
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 5
				loPt1 = m.tnX1
				loPt2 = m.tnY1
				loPt3 = m.tnX2
				loPt4 = m.tnY2
				loPt1.GetExtent(@tnX1,@tnY1)
				loPt2.GetExtent(@tnX2,@tnY2)
				loPt3.GetExtent(@tnX3,@tnY3)
				loPt4.GetExtent(@tnX4,@tnY4)
			CASE PCOUNT() = 9
			OTHERWISE
				*! ToDo: Error ???
			ENDCASE
			
			IF This.UsePrecision
				This.SetStatus(xfcGdipDrawBezier(This.Handle, m.toPen.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2, m.tnX3, m.tnY3, m.tnX4, m.tnY4))
			ELSE
				This.SetStatus(xfcGdipDrawBezierI(This.Handle, m.toPen.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2, m.tnX3, m.tnY3, m.tnX4, m.tnY4))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	#ELSE
		ERROR "Simple Drawing has been enabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION DrawBeziers
	*********************************************************************
	** Method: xfcGraphics.DrawBeziers
	**
	** Draws a series of Bezier splines from an array of Point structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawBeziers%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Point[] points
	**  Pen pen, PointF[] points
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, taoPoints AS xfcPoint
	#IFNDEF GDIPX_SIMPLEDRAWING
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lqPoints, liCount, loPoint AS xfcPoint
			m.lqPoints = 0h
			m.liCount = 0
			IF This.UsePrecision
				m.loPoint = CREATEOBJECT("xfcPointF")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
				This.SetStatus(xfcGdipDrawBeziers(This.Handle, m.toPen.Handle, @lqPoints, m.liCount))
			ELSE
				m.loPoint = CREATEOBJECT("xfcPoint")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
				This.SetStatus(xfcGdipDrawBeziersI(This.Handle, m.toPen.Handle, @lqPoints, m.liCount))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	#ELSE
		ERROR "Simple Drawing has been enabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION DrawClosedCurve
	*********************************************************************
	** Method: xfcGraphics.DrawClosedCurve
	**
	** Draws a closed cardinal spline defined by an array of Point structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawClosedCurve%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Point[] points
	**  Pen pen, PointF[] points
	**  Pen pen, Point[] points, float tension, FillMode fillmode
	**  Pen pen, PointF[] points, float tension, FillMode fillmode
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, taoPoints AS xfcPoint
	*********** toPen AS xfcPen, taoPoints AS xfcPoint, tnTension, tiFillmode AS EnumFillMode
		
		*!ToDo: Test this function
		*!ToDo: tiFillmode is being ignored
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL lqPoints, liCount, loPoint AS xfcPoint
			m.lqPoints = 0h
			m.liCount = 0
			
			DO CASE
			CASE PCOUNT() = 2
				IF This.UsePrecision
					m.loPoint = CREATEOBJECT("xfcPointF")
					m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
					This.SetStatus(xfcGdipDrawClosedCurve(This.Handle, m.toPen.Handle, @lqPoints, m.liCount))
				ELSE
					m.loPoint = CREATEOBJECT("xfcPoint")
					m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
					This.SetStatus(xfcGdipDrawClosedCurveI(This.Handle, m.toPen.Handle, @lqPoints, m.liCount))
				ENDIF
			CASE PCOUNT() = 4
				IF This.UsePrecision
					m.loPoint = CREATEOBJECT("xfcPointF")
					m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
					This.SetStatus(xfcGdipDrawClosedCurve2(This.Handle, m.toPen.Handle, @lqPoints, m.liCount, m.lnTension))
				ELSE
					m.loPoint = CREATEOBJECT("xfcPoint")
					m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
					This.SetStatus(xfcGdipDrawClosedCurve2I(This.Handle, m.toPen.Handle, @lqPoints, m.liCount, m.lnTension))
				ENDIF
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawCurve
	*********************************************************************
	** Method: xfcGraphics.DrawCurve
	**
	** Draws a cardinal spline through a specified array of Point structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawCurve%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Point[] points
	**  Pen pen, PointF[] points
	**  Pen pen, Point[] points, float tension
	**  Pen pen, PointF[] points, float tension
	**  Pen pen, PointF[] points, int offset, int numberOfSegments
	**  Pen pen, Point[] points, int offset, int numberOfSegments, float tension
	**  Pen pen, PointF[] points, int offset, int numberOfSegments, float tension
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, taoPoints AS xfcPoint, ;
					tiOffset, tiNumberOfSegments, tnTension
	*********** toPen AS xfcPen, taoPoints AS xfcPoint, tnTension
		
		*!ToDo: Test this function
		*!ToDo: tnTension should be an optional parameter when passing offset and #ofsegments
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL lnFunctionType
			m.lnFunctionType = 0
			
			LOCAL loPoint AS xfcPoint, liCount, lcVartype
			liCount = 0
			
			lcVarType = VARTYPE(m.tiOffset)+VARTYPE(tiNumberOfSegments)+VARTYPE(tnTension)
			
			IF This.UsePrecision
				m.loPoint = CREATEOBJECT("xfcPointF")
			ELSE
				m.loPoint = CREATEOBJECT("xfcPoint")
			ENDIF	
			lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
			
			DO CASE
			CASE lcVarType == "NNN"
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawCurve3(This.Handle, m.toPen.Handle, lqPoints, m.liCount, m.tiOffset, m.tiNumberOfSegments, m.tnTension))
				ELSE
					This.SetStatus(xfcGdipDrawCurve3I(This.Handle, m.toPen.Handle, lqPoints, m.liCount, m.tiOffset, m.tiNumberOfSegments, m.tnTension))
				ENDIF
				
			CASE LEFT(lcVarType,1) == "N"
				m.tnTension = m.tiOffset
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawCurve2(This.Handle, m.toPen.Handle, lqPoints, m.liCount, m.tnTension))
				ELSE
					This.SetStatus(xfcGdipDrawCurve2I(This.Handle, m.toPen.Handle, lqPoints, m.liCount, m.tnTension))
				ENDIF
				
			OTHERWISE
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawCurve(This.Handle, m.toPen.Handle, lqPoints, m.liCount))
				ELSE
					This.SetStatus(xfcGdipDrawCurveI(This.Handle, m.toPen.Handle, lqPoints, m.liCount))
				ENDIF
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawEllipse
	*********************************************************************
	** Method: xfcGraphics.DrawEllipse
	**
	** Draws an ellipse defined by a bounding rectangle specified by a pair of coordinates,
	** a height, and a width.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawEllipse%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Rectangle rect
	**  Pen pen, RectangleF rect
	**  Pen pen, int x, int y, int width, int height
	**  Pen pen, float x, float y, float width, float height
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, tnX, tnY, tnWidth, tnHeight
	*********** toPen AS xfcPen, toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 2
				m.loRect = tnX
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
			CASE PCOUNT() = 5
			ENDCASE
			
			IF This.UsePrecision
				This.SetStatus(xfcGdipDrawEllipse(This.Handle, m.toPen.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
			ELSE
				This.SetStatus(xfcGdipDrawEllipseI(This.Handle, m.toPen.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawIcon
	*********************************************************************
	** Method: xfcGraphics.DrawIcon
	**
	** Draws the image represented by the specified Icon object at the specified coordinates.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/15: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawIcon%28vs.80%29.aspx
	** Parameters:
	**  Icon icon, Rectangle targetRect
	**  Icon icon, int x, int y
	** Returns: void
	*********************************************************************
	LPARAMETERS toIcon AS xfcIcon, tiX, tiY, tiWidth, tiHeight
	*********** toIcon AS xfcIcon, toTargetRect AS xfcRectangle
		
		*!ToDo: Test this function
		#DEFINE DI_COMPAT 4
		#DEFINE DI_DEFAULTSIZE 8
		#DEFINE DI_IMAGE 2
		#DEFINE DI_MASK 1
		#DEFINE DI_NORMAL 3
		#DEFINE DI_APPBANDING 1
		
		LOCAL loExc AS Exception, lnWidth, lnHeight
		TRY
		 LOCAL lhDC, loRect AS xfcRectangle
		
		 m.lhDC = This.GetHdc()
		 DO CASE
		 CASE VARTYPE(m.tiX) = "O"
		  m.loRect = m.tiX
		  STORE 0 TO tiWidth, tiHeight
		  m.loRect.GetExtent(@tiX, @tiY, @tiWidth, @tiHeight)
		  This.SetStatus(xfcDrawIconEx(m.lhDC, m.tiX, m.tiY, m.toIcon.Handle, tiWidth, tiHeight, 0, 0, DI_NORMAL))
		 CASE PCOUNT() = 5
		  This.SetStatus(xfcDrawIconEx(m.lhDC, m.tiX, m.tiY, m.toIcon.Handle, tiWidth, tiHeight, 0, 0, DI_NORMAL))
		 OTHERWISE
		  This.SetStatus(xfcDrawIcon(m.lhDC, m.tiX, m.tiY, m.toIcon.Handle))
		 ENDCASE
		 This.ReleaseHdc(m.lhDC)
		
		CATCH TO loExc
		 THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawIconUnstretched
	*********************************************************************
	** Method: xfcGraphics.DrawIconUnstretched
	**
	** Draws the image represented by the specified Icon object without scaling the image.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/14: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawIconUnstretched%28vs.80%29.aspx
	** Parameters:
	**  Icon icon, Rectangle targetRect
	** Returns: void
	*********************************************************************
	LPARAMETERS toIcon AS xfcIcon, toTargetRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.DrawImageUnscaled(m.toIcon, m.toTargetRect)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawImage
	*********************************************************************
	** Method: xfcGraphics.DrawImage
	**
	** Draws the specified Image object at the specified location and with the original
	** size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/09: BDurban - Coded (except array functions)
	**	2006/05/01: BDurban - Added array overloads
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawImage%28vs.80%29.aspx
	** Parameters:
	**    1 Image image, Point point
	**    2 Image image, Point[] destPoints
	**    3 Image image, PointF point
	**    4 Image image, PointF[] destPoints
	**    5 Image image, Rectangle rect
	**    6 Image image, RectangleF rect
	**    7 Image image, int x, int y
	**    8 Image image, float x, float y
	**    9 Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit
	**   10 Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit
	**   11 Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit
	**   12 Image image, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit
	**   13 Image image, int x, int y, int width, int height
	**   14 Image image, int x, int y, Rectangle srcRect, GraphicsUnit srcUnit
	**   15 Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr
	**   16 Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr
	**   17 Image image, float x, float y, RectangleF srcRect, GraphicsUnit srcUnit
	**   18 Image image, float x, float y, float width, float height
	**   19 Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback
	**   20 Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback
	**   21 Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback, int callbackData
	**   22 Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback, int callbackData
	**   23 Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit
	**   24 Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit
	**   25 Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr
	**   26 Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs
	**   27 Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback
	**   28 Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, Graphics.DrawImageAbort callback
	**   29 Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, Graphics.DrawImageAbort callback, IntPtr callbackData
	**   30 Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, Graphics.DrawImageAbort callback, IntPtr callbackData
	** Returns: void
	*********************************************************************
	LPARAMETERS toImage AS xfcImage, tnX, tnY, tnWidth, tnHeight, tnSrcX, tnSrcY, tnSrcWidth, tnSrcHeight ;
					, tiSrcUnit AS EnumGraphicsUnit, toImageAttrs AS xfcImageAttributes, thCallback AS FuncPtr, tiCallbackData AS IntPtr
	*********** toImage AS xfcImage, toDestRect AS xfcRectangle, tnSrcX, tnSrcY, tnSrcWidth, tnSrcHeight, tiSrcUnit AS EnumGraphicsUnit ;
					, toImageAttrs AS xfcImageAttributes, thCallback AS FuncPtr, tiCallbackData AS IntPtr
	*********** toImage AS xfcImage, toDestRect AS xfcRectangle, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit
	*********** toImage AS xfcImage, tnX, tnY, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit
	*********** toImage AS xfcImage, tnX, tnY, tnWidth, tnHeight
	*********** toImage AS xfcImage, toPoint AS xfcPoint
	*********** toImage AS xfcImage, toRect AS xfcRectangle
	*********** toImage AS xfcImage, taoDestPoints AS xfcPoint
	*********** toImage AS xfcImage, taoDestPoints AS xfcPoint ;
					, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit, toImageAttr AS xfcImageAttributes, thCallback AS FuncPtr, tiCallbackData
		
		*!ToDo: Test this function
		LOCAL lhImageAttrs, loRect AS xfcRectangle, loSrcRect, lhImage
		LOCAL lnFunctionType
		LOCAL lqPoints, liCount
		LOCAL loPoint AS xfcPoint
		m.lhImageAttrs = 0
		m.loRect = NULL
		m.loSrcRect = NULL
		m.lhImage = 0
		m.lqPoints = NULL
		m.liCount = 0
		m.lnFunctionType = 0
		
		LOCAL loExc AS Exception
		TRY
			m.lcVarType = VARTYPE(m.toImage)+VARTYPE(m.tnX)+VARTYPE(m.tnY)+VARTYPE(m.tnWidth)+VARTYPE(m.tnHeight)+ ;
						VARTYPE(m.tnSrcX)+VARTYPE(m.tnSrcY)+VARTYPE(m.tnSrcWidth)+VARTYPE(m.tnSrcHeight)+ ;
						VARTYPE(m.tiSrcUnit)+VARTYPE(m.toImageAttrs)+VARTYPE(m.thCallback)+VARTYPE(m.tiCallbackData)
			
			m.lhImage = m.toImage.Handle
		
			DO CASE
		** Image, Point[], Rectangle [, Unit, Attribs, Callback, CallbackData]
		** Overloads: 9,10,19,20,21,22
			CASE LIKE("O?O",LEFT(m.lcVarType,3)) AND TYPE("m.tnX[1]") = "O"
				m.tiCallbackData = m.tnSrcY
				m.thCallback = m.tnSrcX
				m.toImageAttrs = m.tnHeight
				m.tiSrcUnit = m.tnWidth
				m.loSrcRect = m.tnY
		
				m.loSrcRect.GetExtent(@tnSrcX, @tnSrcY, @tnSrcWidth, @tnSrcHeight)
				
				IF This.UsePrecision
					m.loPoint = CREATEOBJECT("xfcPointF")
				ELSE
					m.loPoint = CREATEOBJECT("xfcPoint")
				ENDIF
				m.lqPoints = m.loPoint.ToVarBinary(@tnX, @liCount)
				
				m.lnFunctionType = 6
		
		** Image, Point[]
		** Overloads: 2,4
			CASE LEFT(m.lcVarType,1) == "O" AND TYPE("m.tnX[1]") = "O"
		
				IF This.UsePrecision
					m.loPoint = CREATEOBJECT("xfcPointF")
				ELSE
					m.loPoint = CREATEOBJECT("xfcPoint")
				ENDIF
				m.lqPoints = m.loPoint.ToVarBinary(@tnX, @liCount)
				
				m.lnFunctionType = 3
			
		** Image, X, Y, Width, Height, SrcX, SrcY, SrcWidth, SrcHeight [, Unit, Attribs, Callback, CallbackData]
			CASE LEFT(m.lcVarType,9) == "ONNNNNNNN"
				m.lnFunctionType = 5
			
		** Image, Rectangle, SrcX, SrcY, SrcWidth, SrcHeight [, Unit, Attribs, Callback, CallbackData]
		** Overloads: 23,24,25,26,27,28,29,30
			CASE LEFT(m.lcVarType,6) == "OONNNN" AND INLIST(m.tnX.BaseName, "Rectangle", "RectangleF")
				m.tiCallbackData = m.tiSrcUnit
				m.thCallback = m.tnSrcHeight
				m.toImageAttrs = m.tnSrcWidth
				m.tiSrcUnit = m.tnSrcY
				m.tnSrcHeight = m.tnSrcX
				m.tnSrcWidth = m.tnHeight
				m.tnSrcY = m.tnWidth
				m.tnSrcX = m.tnY
				m.loRect = m.tnX
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
		
				m.lnFunctionType = 5
				
		** Image, Rectangle, Rectangle [, Unit] [, Attribs, Callback, CallbackData]
		** Overloads: 11,12
			CASE LEFT(m.lcVarType,3) == "OOO" AND INLIST(m.tnX.BaseName, "Rectangle", "RectangleF")
				m.tiCallbackData = m.tnSrcY
				m.thCallback = m.tnSrcX
				m.toImageAttrs = m.tnHeight
				m.tiSrcUnit = m.tnWidth
				m.loSrcRect = m.tnY
				m.loRect = m.tnX
				
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
				m.loSrcRect.GetExtent(@tnSrcX, @tnSrcY, @tnSrcWidth, @tnSrcHeight)
				
				m.lnFunctionType = 5
			
		** Image, X, Y, Rectangle [,Unit]
		** Overloads: 14,17
			CASE LEFT(m.lcVarType,4) == "ONNO" AND INLIST(m.tnWidth.BaseName, "Rectangle", "RectangleF")
				m.tiSrcUnit = m.tnHeight
				m.loSrcRect = m.tnWidth
				
				m.loSrcRect.GetExtent(@tnSrcX, @tnSrcY, @tnSrcWidth, @tnSrcHeight)
			
				m.lnFunctionType = 4
				
		** Image, X, Y, Width, Height
		** Overloads: 13,18
			CASE LEFT(m.lcVarType,5) == "ONNNN"
				m.lnFunctionType = 2
			
		** Image, X, Y
		** Overloads: 7,8
			CASE LEFT(m.lcVarType,3) == "ONN"
				m.lnFunctionType = 1
			
		** Image, Point
		** Overloads: 1,3
			CASE LEFT(m.lcVarType,2) == "OO" AND INLIST(m.tnX.BaseName, "Point", "PointF")
				m.loPoint = m.tnX
				m.loPoint.GetExtent(@tnX, @tnY)
				
				m.lnFunctionType = 1
			
		** Image, Rectangle
		** Overloads: 5,6
			CASE LEFT(m.lcVarType,2) == "OO" AND INLIST(m.tnX.BaseName, "Rectangle", "RectangleF")
				m.loRect = m.tnX
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
				
				m.lnFunctionType = 2
			
			ENDCASE
			
			
			DO CASE
			CASE m.lnFunctionType = 1
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawImage(This.Handle, m.lhImage, m.tnX, m.tnY))
				ELSE
					This.SetStatus(xfcGdipDrawImageI(This.Handle, m.lhImage, m.tnX, m.tnY))
				ENDIF
				
			CASE m.lnFunctionType = 2
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawImageRect(This.Handle, m.lhImage, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
				ELSE
					This.SetStatus(xfcGdipDrawImageRectI(This.Handle, m.lhImage, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
				ENDIF
				
			CASE m.lnFunctionType = 4
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawImagePointRect(This.Handle, m.lhImage, m.tnX, m.tnY, m.tnSrcx, m.tnSrcy, m.tnSrcwidth, m.tnSrcheight, m.tiSrcUnit))
				ELSE
					This.SetStatus(xfcGdipDrawImagePointRectI(This.Handle, m.lhImage, m.tnX, m.tnY, m.tnSrcx, m.tnSrcy, m.tnSrcwidth, m.tnSrcheight, m.tiSrcUnit))
				ENDIF
				
			CASE m.lnFunctionType = 5
			** Set default values for optional parameters
				m.tiSrcUnit = EVL(m.tiSrcUnit, 0)
				m.lhImageAttrs = 0
				IF VARTYPE(m.toImageAttrs) = "O" AND m.toImageAttrs.BaseName = "ImageAttributes"
					m.lhImageAttrs = m.toImageAttrs.Handle
				ENDIF
				m.thCallBack = EVL(m.thCallBack, 0)
				m.tiCallbackData = EVL(m.tiCallbackData, 0)
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawImageRectRect(This.Handle, m.lhImage, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnSrcx, m.tnSrcy, m.tnSrcwidth, m.tnSrcheight, m.tiSrcUnit, m.lhImageAttrs, m.thCallback, m.tiCallbackData))
				ELSE
					This.SetStatus(xfcGdipDrawImageRectRectI(This.Handle, m.lhImage, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnSrcx, m.tnSrcy, m.tnSrcwidth, m.tnSrcheight, m.tiSrcUnit, m.lhImageAttrs, m.thCallback, m.tiCallbackData))
				ENDIF
				
			CASE m.lnFunctionType = 3
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawImagePoints(This.Handle, m.lhImage, @lqPoints, m.liCount))
				ELSE
					This.SetStatus(xfcGdipDrawImagePointsI(This.Handle, m.lhImage, @lqPoints, m.liCount))
				ENDIF
				
			CASE m.lnFunctionType = 6
				IF This.UsePrecision
					This.SetStatus(xfcGdipDrawImagePointsRect(This.Handle, m.lhImage, @lqPoints, m.liCount, m.tnSrcx, m.tnSrcy, m.tnSrcwidth, m.tnSrcheight, m.tiSrcUnit, m.lhImageAttrs, m.thCallback, m.tiCallbackData))
				ELSE
					This.SetStatus(xfcGdipDrawImagePointsRectI(This.Handle, m.lhImage, @lqPoints, m.liCount, m.tnSrcx, m.tnSrcy, m.tnSrcwidth, m.tnSrcheight, m.tiSrcUnit, m.lhImageAttrs, m.thCallback, m.tiCallbackData))
				ENDIF
				
			CASE m.lnFunctionType = 7
				This.SetStatus(xfcGdipDrawImageFX(This.Handle, m.lhImage, m.lcSource, m.lhXForm, m.liEffect, m.lhImageAttrs, m.liSrcUnit))
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawImageUnscaled
	*********************************************************************
	** Method: xfcGraphics.DrawImageUnscaled
	**
	** Draws the specified image using its original physical size at the location specified
	** by a coordinate pair.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/14: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawImageUnscaled%28vs.80%29.aspx
	** Parameters:
	**  Image image, Point point
	**  Image image, Rectangle rect
	**  Image image, int x, int y
	**  Image image, int x, int y, int width, int height
	** Returns: void
	*********************************************************************
	LPARAMETERS toImage AS xfcImage, tiX, tiY, ;
					tiWidth, tiHeight
	*********** toImage AS xfcImage, toPoint AS xfcPoint
	*********** toImage AS xfcImage, toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loBmp AS xfcBitmap, loGfx AS xfcGraphics
		
		LOCAL loExc AS Exception
		TRY
			m.lcVarType = VARTYPE(m.tiX)+VARTYPE(m.tiY)+VARTYPE(m.tiWidth)+VARTYPE(m.tiHeight)
			DO CASE
			CASE m.lcVarType == "NNNN"
			** Do nothing
			CASE LEFT(m.lcVarType, 2) == "NN"
				m.tiWidth = m.toImage.Width
				m.tiHeight = m.toImage.Height
			CASE VARTYPE(m.tiX) = "O" AND INLIST(m.tiX.BaseName,"PointF","Point")
				m.loPoint = m.tiX
				m.loPoint.GetExtent(@tiX, @tiY)
				m.tiWidth = m.toImage.Width
				m.tiHeight = m.toImage.Height
			CASE VARTYPE(m.tiX) = "O" AND INLIST(m.tiX.BaseName,"RectangleF","Rectangle")
				m.loRect = m.tiX
				m.loRect.GetExtent(@tiX, @tiY, @tiWidth, @tiHeight)
			ENDCASE		
			m.loBmp = CREATEOBJECT("xfcBitmap", m.tiWidth, m.tiHeight)
			m.loGfx = This.FromImage(m.loBmp)
			m.loGfx.DrawImage(m.toImage, 0, 0, m.toImage.Width, m.toImage.Height)
			This.DrawImage(m.loBmp, m.tiX, m.tiY, m.tiWidth, m.tiHeight)
			m.loBmp = NULL
			m.loGfx = NULL
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawLine
	*********************************************************************
	** Method: xfcGraphics.DrawLine
	**
	** Draws a line connecting the two points specified by coordinate pairs.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawLine%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Point pt1, Point pt2
	**  Pen pen, PointF pt1, PointF pt2
	**  Pen pen, int x1, int y1, int x2, int y2
	**  Pen pen, float x1, float y1, float x2, float y2
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, tnX1, tnY1, tnX2, tnY2
	*********** toPen AS xfcPen, toPt1 AS xfcPoint, toPt2 AS xfcPoint
		
		*!ToDo: Test this function
		LOCAL loPoint1 AS xfcPointF
		LOCAL loPoint2 AS xfcPointF
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 3
				loPoint1 = m.tnX1
				loPoint2 = m.tnY1
				loPoint1.GetExtent(@tnX1, @tnY1)
				loPoint2.GetExtent(@tnX2, @tnY2)
			CASE PCOUNT() = 5
			ENDCASE
				
			IF This.UsePrecision
				This.SetStatus(xfcGdipDrawLine(This.Handle, m.toPen.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2))
			ELSE
				This.SetStatus(xfcGdipDrawLineI(This.Handle, m.toPen.Handle, m.tnX1, m.tnY1, m.tnX2, m.tnY2))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawLines
	*********************************************************************
	** Method: xfcGraphics.DrawLines
	**
	** Draws a series of line segments that connect an array of Point structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawLines%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Point[] points
	**  Pen pen, PointF[] points
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, taoPoints AS xfcPoint
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loPoint AS xfcPoint
			LOCAL lqPoints, liCount
			m.lqPoints = 0h
			m.liCount = 0
			
			IF This.UsePrecision
				m.loPoint = CREATEOBJECT("xfcPointF")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
				This.SetStatus(xfcGdipDrawLines(This.Handle, m.toPen.Handle, @lqPoints, m.liCount))
			ELSE
				m.loPoint = CREATEOBJECT("xfcPoint")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
				This.SetStatus(xfcGdipDrawLinesI(This.Handle, m.toPen.Handle, @lqPoints, m.liCount))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawPath
	*********************************************************************
	** Method: xfcGraphics.DrawPath
	**
	** Draws a GraphicsPath object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawPath%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, GraphicsPath path
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, toPath AS xfcGraphicsPath
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipDrawPath(This.Handle, m.toPen.Handle, m.toPath.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawPie
	*********************************************************************
	** Method: xfcGraphics.DrawPie
	**
	** Draws a pie shape defined by an ellipse specified by a coordinate pair, a width,
	** and a height and two radial lines.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawPie%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Rectangle rect, float startAngle, float sweepAngle
	**  Pen pen, RectangleF rect, float startAngle, float sweepAngle
	**  Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle
	**  Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, tnX, tnY, tnWidth, tnHeight, tnStartAngle, tnSweepAngle
	*********** toPen AS xfcPen, toRect AS xfcRectangle, tnStartAngle, tnSweepAngle
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 4	&& Pen, Rectangle, Number, Number
				m.loRect = tnX
				m.tnStartAngle = m.tnY
				m.tnSweepAngle = m.tnWidth
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
			CASE PCOUNT() = 7
			ENDCASE
			
			IF This.UsePrecision
				This.SetStatus(xfcGdipDrawPie(This.Handle, m.toPen.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
			ELSE
				This.SetStatus(xfcGdipDrawPieI(This.Handle, m.toPen.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawPolygon
	*********************************************************************
	** Method: xfcGraphics.DrawPolygon
	**
	** Draws a polygon defined by an array of Point structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawPolygon%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Point[] points
	**  Pen pen, PointF[] points
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, taoPoints AS xfcPoint
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loPoint AS xfcPoint
			LOCAL lqPoints, liCount
			m.lqPoints = 0h
			m.liCount = 0
			
			IF This.UsePrecision
				m.loPoint = CREATEOBJECT("xfcPointF")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
				This.SetStatus(xfcGdipDrawPolygon(This.Handle, m.toPen.Handle, @lqPoints, m.liCount))
			ELSE
				m.loPoint = CREATEOBJECT("xfcPoint")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
				This.SetStatus(xfcGdipDrawPolygonI(This.Handle, m.toPen.Handle, @lqPoints, m.liCount))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawRectangle
	*********************************************************************
	** Method: xfcGraphics.DrawRectangle
	**
	** Draws a rectangle specified by a coordinate pair, a width, and a height.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawRectangle%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Rectangle rect
	**  Pen pen, int x, int y, int width, int height
	**  Pen pen, float x, float y, float width, float height
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, tnX, tnY, tnWidth, tnHeight
	*********** toPen AS xfcPen, toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 2
				m.loRect = m.tnX
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
			CASE PCOUNT() = 5
			ENDCASE
			
			IF This.UsePrecision
				This.SetStatus(xfcGdipDrawRectangle(This.Handle, m.toPen.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
			ELSE
				This.SetStatus(xfcGdipDrawRectangleI(This.Handle, m.toPen.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawRectangles
	*********************************************************************
	** Method: xfcGraphics.DrawRectangles
	**
	** Draws a series of rectangles specified by Rectangle structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawRectangles%28vs.80%29.aspx
	** Parameters:
	**  Pen pen, Rectangle[] rects
	**  Pen pen, RectangleF[] rects
	** Returns: void
	*********************************************************************
	LPARAMETERS toPen AS xfcPen, taoRects AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRect AS xfcRectangle
			LOCAL lqRects, liCount
			m.lqRects = 0h
			m.liCount = 0
			
			IF This.UsePrecision
				m.loRect = CREATEOBJECT("xfcRectangleF")
				m.lqRects = m.loRect.ToVarBinary(@taoRects, @liCount)
				This.SetStatus(xfcGdipDrawRectangles(This.Handle, m.toPen.Handle, @lqRects, m.liCount))
			ELSE
				m.loRect = CREATEOBJECT("xfcRectangle")
				m.lqRects = m.loRect.ToVarBinary(@taoRects, @liCount)
				This.SetStatus(xfcGdipDrawRectanglesI(This.Handle, m.toPen.Handle, @lqRects, m.liCount))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DrawString
	*********************************************************************
	** Method: xfcGraphics.DrawString
	**
	** Draws the specified text string at the specified location with the specified Brush
	** and Font objects.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.DrawString%28vs.80%29.aspx
	** Parameters:
	**  string s, Font font, Brush brush, PointF point
	**  string s, Font font, Brush brush, RectangleF layoutRectangle
	**  string s, Font font, Brush brush, PointF point, StringFormat format
	**  string s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format
	**  string s, Font font, Brush brush, float x, float y
	**  string s, Font font, Brush brush, float x, float y, StringFormat format
	** Returns: void
	*********************************************************************
	LPARAMETERS tcString, toFont AS xfcFont, toBrush AS xfcBrush, tnX, tnY ;
					, toFormat AS xfcStringFormat
	*********** tcString, toFont AS xfcFont, toBrush AS xfcBrush, toPoint AS xfcPointF ;
					, toFormat AS xfcStringFormat
	*********** tcString, toFont AS xfcFont, toBrush AS xfcBrush, toRectangle AS xfcRectangleF ;
					, toFormat AS xfcStringFormat
		
		*!ToDo: Test this function
		
		LOCAL lqLayoutRect
		LOCAL lnWidth, lnHeight, loPoint AS xfcPointF, loRect AS xfcRectangleF
		LOCAL lhFormat
		STORE 0 TO lnWidth, lnHeight
		STORE NULL TO loPoint, loRect
		m.lqLayoutRect = 0h00
		
		LOCAL loExc AS Exception
		TRY
		** Handle overload parameters
			DO CASE
			CASE VARTYPE(tnX) = "N"
				
			CASE VARTYPE(tnX) = "O" AND INLIST(tnX.BaseName,"Point","PointF")
				m.loPoint = m.tnX
				m.toFormat = m.tnY
				m.loPoint.GetExtent(@tnX, @tnY)
		
			CASE VARTYPE(tnX) = "O" AND INLIST(tnX.BaseName,"Rectangle","RectangleF")
				m.loRect = m.tnX
				m.toFormat = m.tnY
				m.loRect.GetExtent(@tnX, @tnY, @lnWidth, @lnHeight)
			ENDCASE
			
		** Optional parameter
		** The C++ classes show this parameter as NULL if not specified
			IF VARTYPE(m.toFormat) = "O"
				m.lhFormat = m.toFormat.Handle
			ELSE
				m.lhFormat = 0
			ENDIF
			
			m.lqLayoutRect = BINTOC(m.tnX,"F")+BINTOC(m.tnY,"F")+;
						BINTOC(m.lnWidth,"F")+BINTOC(m.lnHeight,"F")
			
			This.SetStatus(xfcGdipDrawString(This.Handle, STRCONV(m.tcString+0h00,5), LENC(tcString), ;
					m.toFont.Handle, @lqLayoutRect, m.lhFormat, m.toBrush.Handle))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC
	

	*********************************************************************
	FUNCTION DrawStringJustified
	*************************************************************************************
	** Method: xfcGraphics.DrawStringJustified
	**
	** Draws the specified text string at the specified location with the specified Brush
	** and Font objects in a Full Justified format.
	**
	** History:
	**  2007/01/15: CChalom - Coded
	**  2007/02/02: CChalom - Tweaked to work with ReportListener
	**  2007/04/16: CChalom - Minor fixes for small sentences
	**  2008/06/22: CChalom - Added some tweaks to allow better drawing on reports
	**                        Added new flag - tlJustLast - that will forcely justify the last line
	*************************************************************************************
		
	LPARAMETERS tcString, ;
					toFont as xfcFont, ;
					toBrush as xfcBrush, ;
					toRectangle as xfcRectangle, ;
					tlJustLast as Boolean 
		
		*!ToDo: Add more error trapping
		*!ToDo: Add new overloads
		
		LOCAL lhFont, lhGraphics, lhBrush, lcRectF
		LOCAL N, lnSpaceWidth, lnLineHeight, lcText
		LOCAL wImg, hImg, x0, y0
		LOCAL loGfxState AS xfcGraphicsState
		LOCAL lhTempStrFormat, lhStringFormat
		LOCAL lhLeftAlignHandle
		LOCAL lhRightAlignHandle
		LOCAL lnWords, lnWordWidth, lnChars, lcCurrWord, lcCutWord, lnReduce
		LOCAL llEndOfSentence, lnWordsWidth, lnWordsinLine, lnCurrWord, lnCurrLine, lnX, lnY
		LOCAL lnWidthofBetween, lnStringFormatHandle, llLast
			
		#DEFINE TextRenderingHintAntiAlias		4
		
		LOCAL loExc AS Exception
		TRY
			
			m.X0   = m.toRectangle.Left
			m.Y0   = m.toRectangle.Top
			m.wImg = m.toRectangle.Width
			m.hImg = m.toRectangle.Height
		
			* Save the current state of the graphics handle
			m.loGfxState = This.Save()
		
			* Store Gdi+ handles for MeasureString and DrawString
			m.lhFont     = m.toFont.Handle
			m.lhGraphics = This.Handle
			m.lhBrush    = m.toBrush.Handle
			
			* Obtain the Font Height to be used as Line Height
			m.lnLineHeight = m.toFont.GetHeight(This)
	
			* Adjust the Text String to ease detection of Carriage Returns
			m.lcText = STRTRAN(m.tcString,CHR(13)+CHR(10), " <CR> ")
			m.lcText = STRTRAN(m.lcText,CHR(13), " <CR> ")
			m.lcText = STRTRAN(m.lcText,CHR(10), " <CR> ")
			m.lcText = m.lcText + " <LASTWORD> "
		
			* Ensure Measure String will bring the best measures possible
			* Set to AntiAlias
			=xfcGdipSetTextRenderingHint(m.lhGraphics, TextRenderingHintAntiAlias)
		
			* Create a String Format object with the Generic Typographic TO obtain
			*   the most accurate String measurements
			* Strange, but the recommended for this case is to use a "cloned" StringFormat
			STORE 0 TO m.lhTempStrFormat, m.lhStringFormat
			= xfcGdipStringFormatGetGenericTypographic(@lhTempStrFormat)
			= xfcGdipCloneStringFormat(m.lhTempStrFormat, @lhStringFormat)
			* Delete the Temporary StringFormat object created
			= xfcGdipDeleteStringFormat(m.lhTempStrFormat)
		
			* Allow the correct measuring of Spaces
			= xfcGdipSetStringFormatFlags(m.lhStringFormat, StringFormatFlagsMeasureTrailingSpaces)
		
			* Create a StringFormat for LeftAlignment
			m.lhLeftAlignHandle = 0
			= xfcGdipCreateStringFormat(0, 0, @lhLeftAlignHandle)
			= xfcGdipSetStringFormatAlign(m.lhLeftAlignHandle, StringAlignmentNear)
		
			* Create a StringFormat for RightAlignment
			m.lhRightAlignHandle = 0
			= xfcGdipCreateStringFormat(0, 0, @lhRightAlignHandle)
			= xfcGdipSetStringFormatAlign(m.lhRightAlignHandle, StringAlignmentFar)
		
		
			* Measure Space for the given font
			STORE EMPTY_RECTANGLE TO m.lcRectF, pcBoundingBox
			= xfcGdipMeasureString( m.lhGraphics;
				, STRCONV(" " + 0h00,5)	;
				, 1 ;
				, m.lhFont ;
				, m.lcRectF ;
				, m.lhStringFormat ;
				, @pcBoundingBox, 0, 0)
			m.lnSpaceWidth = CTOBIN(SUBSTR(pcBoundingBox, 9, 4), 'N') + 1
			
		
			m.lnWords = GETWORDCOUNT(m.lcText)
			DIMENSION laWords(lnWords,2)
		
			* Measure each word
			n = 1
		
			DO WHILE .T.
		
				laWords(N,1) = GETWORDNUM(m.lcText, N)
				m.lcCurrWord = laWords(N,1)
				STORE EMPTY_RECTANGLE TO m.lcRectF, pcBoundingBox
				= xfcGdipMeasureString(m.lhGraphics;
					, STRCONV(m.lcCurrWord + 0h00,5)	;
					, LENC(m.lcCurrWord) ;
					, m.lhFont ;
					, m.lcRectF ;
					, lhStringFormat ;
					, @pcBoundingBox, 0, 0)
				m.lnWordWidth = CTOBIN(SUBSTR(pcBoundingBox, 9, 4), 'N')
		
				IF m.lnWordWidth > m.wImg AND m.lcCurrWord <> "<CR>"
					m.lnReduce = 1
					DO WHILE .T.
						m.lnChars = ROUND((LENC(m.lcCurrWord) / (m.lnWordWidth / m.wImg)),0) - m.lnReduce
						m.lcCutWord = SUBSTR(m.lcCurrWord, 1, m.lnChars)
						STORE EMPTY_RECTANGLE TO m.lcRectF, pcBoundingBox
						= xfcGdipMeasureString(m.lhGraphics;
							, STRCONV(m.lcCutWord + 0h00,5)	;
							, LENC(m.lcCutWord) ;
							, m.lhFont ;
							, m.lcRectF ;
							, m.lhStringFormat ;
							, @pcBoundingBox, 0, 0)
						m.lnWordWidth = CTOBIN(SUBSTR(pcBoundingBox, 9, 4), 'N')
						laWords(N,1) = m.lcCutWord
		
						IF m.lnWordWidth <= m.wImg
							m.lnWords = m.lnWords + 1
							DIMENSION laWords(m.lnWords,2)
							laWords(m.lnWords,1) = ""
							laWords(m.lnWords,2) = 0
							
							m.lcText = STRTRAN(m.lcText, m.lcCurrWord, ;
								m.lcCutWord + SPACE(1) + SUBSTR(m.lcCurrWord, m.lnChars + 1), ;
								1, 1)
							EXIT
						ENDIF
						m.lnReduce = m.lnReduce + 1	
		
					ENDDO
				ENDIF
		
				laWords(N,2) = m.lnWordWidth
				N = N + 1
				IF N > m.lnWords
					EXIT
				ENDIF
			ENDDO
		
			* Before we start drawing, it's wise to restore our Graphics object to
			*    its original state.
			* Put back the state of the graphics handle
			This.Restore(loGfxState)
			
		
			* Start Drawing word by word
			m.lnCurrWord = 1
			m.lnCurrLine = 0
		
		
			LOCAL llLastLine
			m.llLastLine = .F.
		
			FOR m.N = 1 TO m.lnWords
			
				llEndOfSentence   = .F.
				m.lnWordsWidth  = 0
				m.lnWordsinLine = 0

		
				FOR m.z = m.N TO m.lnWords
			
					lcChar = LOWER(laWords(z,1))
					
					IF m.laWords(z,1) = "<CR>"
						m.llEndOfSentence = .T.
						EXIT
					ENDIF
					
					IF m.laWords(z,1) = "<LASTWORD>"
						m.llLastLine = .T.
						m.lnWordsWidth = m.lnWordsWidth - (m.lnSpaceWidth * m.lnWordsinLine) + m.lnSpaceWidth
						EXIT
					ENDIF 
		
					m.lnWordsWidth = m.lnWordsWidth + m.laWords(z,2) + m.lnSpaceWidth
					IF m.lnWordsWidth > m.wImg AND z > N
						m.lnWordsWidth = m.lnWordsWidth - m.laWords(z,2) - (m.lnSpaceWidth * m.lnWordsinLine)
						EXIT
					ENDIF
		
					m.lnWordsinLine = m.lnWordsinLine + 1
				ENDFOR

				m.lnWordsWidth = m.lnWordsWidth - m.lnSpaceWidth


		
				IF m.z >= m.lnWords
					m.llEndOfSentence = .T.
					m.llLastLine = .T.
				ENDIF
		
				IF m.llLastLine
					IF m.tlJustLast
						m.lnWidthOfBetween = (m.wImg - m.lnWordsWidth - m.lnSpaceWidth) / (m.lnWordsinLine - 1)
					ELSE 
						m.lnWidthOfBetween = m.lnSpaceWidth
					ENDIF 
					
				ELSE 
					
					IF m.llEndOfSentence
						m.lnWidthOfBetween = m.lnSpaceWidth
					ELSE
						m.lnWidthOfBetween = (m.wImg - m.lnWordsWidth - m.lnSpaceWidth) / (m.lnWordsinLine - 1)
					ENDIF
							
				ENDIF 



				m.lnY = m.Y0 + (m.lnCurrLine * m.lnLineHeight)
		
				IF m.lnY >= (m.hImg + m.Y0 - lnLineHeight)
					m.n = m.lnWords
					EXIT
				ENDIF
						
				m.lnX = m.X0
		
				FOR m.lnCurrWord = 1 TO m.lnWordsinLine
					m.llLast = .F.
					IF m.laWords(N,1) = "<CR>" && Ignore
						m.N = m.N + 1
						LOOP
					ENDIF
					
					IF m.lnCurrWord = m.lnWordsinLine AND NOT m.llEndOfSentence
						m.llLast = .T.
					ENDIF

					IF m.lnCurrWord = m.lnWordsinLine AND m.llLastLine AND tlJustLast
						m.llLast = .T.
					ENDIF

	
					IF m.lnWordsInLine = 1
						m.lnX = m.X0
						m.llLast = .F.
					ENDIF
		
					IF m.llLast
						m.lcRectF = BINTOC(m.X0,'F') + BINTOC(m.lnY,'F') + ;
							BINTOC(m.wImg,'F') + BINTOC(m.lnY + m.lnLineHeight,'F')
						m.lnStringFormatHandle = m.lhRightAlignHandle
					ELSE
						m.lcRectF = BINTOC(m.lnX,'F') + BINTOC(m.lnY,'F') + REPLICATE(CHR(0),8)
						m.lnStringFormatHandle = m.lhLeftAlignHandle
					ENDIF
		
					= xfcGdipDrawString(m.lhGraphics ;
						, STRCONV(m.laWords(N,1) + 0h00,5) ;
						, LEN(m.laWords(N,1)) ;
						, m.lhFont ;
						, m.lcRectF ;
						, m.lnStringFormatHandle ;
						, m.lhBrush)
		
					m.lnX = m.lnX + m.laWords(N,2) + m.lnWidthOfBetween
					m.N = m.N + 1 && Go to next word
				ENDFOR
		
				m.lnCurrLine = m.lnCurrLine + 1
		
				IF m.N >= m.lnWords
					EXIT
				ENDIF
		
				IF m.laWords(N,1) <> "<CR>"
					m.N = m.N - 1 && Compensate ENDFOR
				ENDIF
		
			ENDFOR
			
			* Finished Measuring, so erase the temp objects
		
			* Delete the StringFormat object created
			=xfcGdipDeleteStringFormat(m.lhStringFormat)
			=xfcGdipDeleteStringFormat(m.lhLeftAlignHandle)
			=xfcGdipDeleteStringFormat(m.lhRightAlignHandle)
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC
	

	*********************************************************************
	FUNCTION EndContainer
	*********************************************************************
	** Method: xfcGraphics.EndContainer
	**
	** Closes the current graphics container and restores the state of this Graphics object
	** to the state saved by a call to the BeginContainer method.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.EndContainer%28vs.80%29.aspx
	** Parameters:
	**  GraphicsContainer container
	** Returns: void
	*********************************************************************
	LPARAMETERS toContainer AS xfcGraphicsContainer
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipEndContainer(This.Handle, m.toContainer.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION EnumerateMetafile
	*********************************************************************
	** Method: xfcGraphics.EnumerateMetafile
	**
	** Sends the records in the specified Metafile object, one at a time, to a callback
	** method for display at a specified point.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.EnumerateMetafile%28vs.80%29.aspx
	** Parameters:
	**  Metafile metafile, Point destPoint, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, Point[] destPoints, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, PointF destPoint, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, PointF[] destPoints, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, Rectangle destRect, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, RectangleF destRect, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, Point destPoint, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, Point[] destPoints, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, PointF destPoint, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, PointF[] destPoints, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, Rectangle destRect, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, RectangleF destRect, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, Point destPoint, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, Point[] destPoints, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, PointF destPoint, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, PointF[] destPoints, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, Rectangle destRect, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, RectangleF destRect, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback
	**  Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData
	**  Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	**  Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr
	** Returns: void
	*********************************************************************
	LPARAMETERS toMetafile AS xfcMetafile, taoDestPoints AS xfcPoint, thCallback AS FuncPtr
	*********** toMetafile AS xfcMetafile, taoDestPoints AS xfcPoint, thCallback AS FuncPtr, tiCallbackData AS IntPtr
	*********** toMetafile AS xfcMetafile, taoDestPoints AS xfcPoint, thCallback AS FuncPtr, tiCallbackData AS IntPtr, toImageAttr AS xfcImageAttributes
	*********** toMetafile AS xfcMetafile, taoDestPoints AS xfcPoint, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit, thCallback AS FuncPtr
	*********** toMetafile AS xfcMetafile, taoDestPoints AS xfcPoint, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit, thCallback AS FuncPtr, tiCallbackData AS IntPtr
	*********** toMetafile AS xfcMetafile, taoDestPoints AS xfcPoint, toSrcRect AS xfcRectangle, tiUnit AS EnumGraphicsUnit, thCallback AS FuncPtr, tiCallbackData AS IntPtr, toImageAttr AS xfcImageAttributes
	*********** toMetafile AS xfcMetafile, toDestPoint AS xfcPoint, thCallback AS FuncPtr
	*********** toMetafile AS xfcMetafile, toDestPoint AS xfcPoint, thCallback AS FuncPtr, tiCallbackData AS IntPtr
	*********** toMetafile AS xfcMetafile, toDestPoint AS xfcPoint, thCallback AS FuncPtr, tiCallbackData AS IntPtr, toImageAttr AS xfcImageAttributes
	*********** toMetafile AS xfcMetafile, toDestPoint AS xfcPoint, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit, thCallback AS FuncPtr
	*********** toMetafile AS xfcMetafile, toDestPoint AS xfcPoint, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit, thCallback AS FuncPtr, tiCallbackData AS IntPtr
	*********** toMetafile AS xfcMetafile, toDestPoint AS xfcPoint, toSrcRect AS xfcRectangle, tiUnit AS EnumGraphicsUnit, thCallback AS FuncPtr, tiCallbackData AS IntPtr, toImageAttr AS xfcImageAttributes
	*********** toMetafile AS xfcMetafile, toDestRect AS xfcRectangle, thCallback AS FuncPtr
	*********** toMetafile AS xfcMetafile, toDestRect AS xfcRectangle, thCallback AS FuncPtr, tiCallbackData AS IntPtr
	*********** toMetafile AS xfcMetafile, toDestRect AS xfcRectangle, thCallback AS FuncPtr, tiCallbackData AS IntPtr, toImageAttr AS xfcImageAttributes
	*********** toMetafile AS xfcMetafile, toDestRect AS xfcRectangle, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit, thCallback AS FuncPtr
	*********** toMetafile AS xfcMetafile, toDestRect AS xfcRectangle, toSrcRect AS xfcRectangle, tiSrcUnit AS EnumGraphicsUnit, thCallback AS FuncPtr, tiCallbackData AS IntPtr
	*********** toMetafile AS xfcMetafile, toDestRect AS xfcRectangle, toSrcRect AS xfcRectangle, tiUnit AS EnumGraphicsUnit, thCallback AS FuncPtr, tiCallbackData AS IntPtr, toImageAttr AS xfcImageAttributes
	#IFDEF USECLASS_XFCMETAFILE
	 
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL lnFunctionType
			m.lnFunctionType = 0
			
			DO CASE
			CASE m.lnFunctionType = 1
				IF This.UsePrecision
					This.SetStatus(xfcGdipEnumerateMetafileDestPoint(This.Handle, m.lhMetafile, @lcDestPoint, @liCallback, m.lpCallbackData, @lhImageAttributes))
				ELSE
					This.SetStatus(xfcGdipEnumerateMetafileDestPointI(This.Handle, m.lhMetafile, @lcDestPoint, @liCallback, m.lpCallbackData, @lhImageAttributes))
				ENDIF
			CASE m.lnFunctionType = 2
				IF This.UsePrecision
					This.SetStatus(xfcGdipEnumerateMetafileDestRect(This.Handle, m.lhMetafile, @lcDestRect, @liCallback, m.lpCallbackData, @lhImageAttributes))
				ELSE
					This.SetStatus(xfcGdipEnumerateMetafileDestRectI(This.Handle, m.lhMetafile, @lcDestRect, @liCallback, m.lpCallbackData, @lhImageAttributes))
				ENDIF
			CASE m.lnFunctionType = 3
				IF This.UsePrecision
					This.SetStatus(xfcGdipEnumerateMetafileDestPoints(This.Handle, m.lhMetafile, @lcDestPoints, m.liCount, @liCallback, m.lpCallbackData, @lhImageAttributes))
				ELSE
					This.SetStatus(xfcGdipEnumerateMetafileDestPointsI(This.Handle, m.lhMetafile, @lcDestPoints, m.liCount, @liCallback, m.lpCallbackData, @lhImageAttributes))
				ENDIF
			CASE m.lnFunctionType = 4
				IF This.UsePrecision
					This.SetStatus(xfcGdipEnumerateMetafileSrcRectDestPoint(This.Handle, m.lhMetafile, @lcDestPoint, @lcSrcRect, m.liSrcUnit, m.liCallback, m.lpCallbackData, m.lhImageAttributes))
				ELSE
					This.SetStatus(xfcGdipEnumerateMetafileSrcRectDestPointI(This.Handle, m.lhMetafile, @lcDestPoint, @lcSrcRect, m.liSrcUnit, m.liCallback, m.lpCallbackData, m.lhImageAttributes))
				ENDIF
			CASE m.lnFunctionType = 5
				IF This.UsePrecision
					This.SetStatus(xfcGdipEnumerateMetafileSrcRectDestRect(This.Handle, m.lhMetafile, @lcDestRect, @lcSrcRect, m.liSrcUnit, m.liCallback, m.lpCallbackData, m.lhImageAttributes))
				ELSE
					This.SetStatus(xfcGdipEnumerateMetafileSrcRectDestRectI(This.Handle, m.lhMetafile, @lcDestRect, @lcSrcRect, m.liSrcUnit, m.liCallback, m.lpCallbackData, m.lhImageAttributes))
				ENDIF
			CASE m.lnFunctionType = 6
				IF This.UsePrecision
					This.SetStatus(xfcGdipEnumerateMetafileSrcRectDestPoints(This.Handle, m.lhMetafile, @lcDestPoints, m.liCount, @lcSrcRect, m.liSrcUnit, m.liCallback, m.lpCallbackData, m.lhImageAttributes))
				ELSE
					This.SetStatus(xfcGdipEnumerateMetafileSrcRectDestPointsI(This.Handle, m.lhMetafile, @lcDestPoints, m.liCount, @lcSrcRect, m.liSrcUnit, m.liCallback, m.lpCallbackData, m.lhImageAttributes))
				ENDIF
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	#ELSE
		ERROR "Metfile class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION ExcludeClip
	*********************************************************************
	** Method: xfcGraphics.ExcludeClip
	**
	** Updates the clip region of this Graphics object to exclude the area specified by
	** a Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/14: BDurban - Coded
	**  2013/03/10: CChalom - Fixed - Thanks to MReigler - http://vfpx.codeplex.com/workitem/26382
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.ExcludeClip%28vs.80%29.aspx
	** Parameters:
	**  Rectangle rect
	**  Region region
	** Returns: void
	*********************************************************************
	LPARAMETERS toRect AS xfcRectangle
	*********** toRegion AS xfcRegion
		
		*!ToDo: Test this function
	
		This.SetClip(m.toRect, CombineModeExclude)
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FillClosedCurve
	*********************************************************************
	** Method: xfcGraphics.FillClosedCurve
	**
	** Fills the interior a closed cardinal spline curve defined by an array of Point structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FillClosedCurve%28vs.80%29.aspx
	** Parameters:
	**  Brush brush, Point[] points
	**  Brush brush, PointF[] points
	**  Brush brush, Point[] points, FillMode fillmode
	**  Brush brush, PointF[] points, FillMode fillmode
	**  Brush brush, Point[] points, FillMode fillmode, float tension
	**  Brush brush, PointF[] points, FillMode fillmode, float tension
	** Returns: void
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush, taoPoints AS xfcPoint, ;
					tiFillmode AS EnumFillMode, ;
					tnTension
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY	
			LOCAL loPoint AS xfcPoint, lqPoints, liCount
			m.liCount = 0
			IF This.UsePrecision
				m.loPoint = CREATEOBJECT("xfcPointF")
			ELSE
				m.loPoint = CREATEOBJECT("xfcPoint")
			ENDIF
			m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
		
			DO CASE
			CASE VARTYPE(m.tiFillmode) = "N"
				m.tnTension = EVL(m.tnTension, 0.00)
				IF This.UsePrecision
					This.SetStatus(xfcGdipFillClosedCurve2(This.Handle, m.toBrush.Handle, @lqPoints, m.liCount, m.tnTension, m.tiFillMode))
				ELSE
					This.SetStatus(xfcGdipFillClosedCurve2I(This.Handle, m.toBrush.Handle, @lqPoints, m.liCount, m.tnTension, m.tiFillMode))
				ENDIF
			OTHERWISE
				IF This.UsePrecision
					This.SetStatus(xfcGdipFillClosedCurve(This.Handle, m.toBrush.Handle, @lqPoints, m.liCount))
				ELSE
					This.SetStatus(xfcGdipFillClosedCurveI(This.Handle, m.toBrush.Handle, @lqPoints, m.liCount))
				ENDIF
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FillEllipse
	*********************************************************************
	** Method: xfcGraphics.FillEllipse
	**
	** Fills the interior of an ellipse defined by a bounding rectangle specified by a
	** pair of coordinates, a width, and a height.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FillEllipse%28vs.80%29.aspx
	** Parameters:
	**  Brush brush, Rectangle rect
	**  Brush brush, RectangleF rect
	**  Brush brush, int x, int y, int width, int height
	**  Brush brush, float x, float y, float width, float height
	** Returns: void
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush, tnX, tnY, tnWidth, tnHeight
	*********** toBrush AS xfcBrush, toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 2
				m.loRect = tnX
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
			CASE PCOUNT() = 5
			ENDCASE
			
			IF This.UsePrecision
				This.SetStatus(xfcGdipFillEllipse(This.Handle, m.toBrush.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
			ELSE
				This.SetStatus(xfcGdipFillEllipseI(This.Handle, m.toBrush.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FillPath
	*********************************************************************
	** Method: xfcGraphics.FillPath
	**
	** Fills the interior of a GraphicsPath object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FillPath%28vs.80%29.aspx
	** Parameters:
	**  Brush brush, GraphicsPath path
	** Returns: void
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush, toPath AS xfcGraphicsPath
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipFillPath(This.Handle, m.toBrush.Handle, m.toPath.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FillPie
	*********************************************************************
	** Method: xfcGraphics.FillPie
	**
	** Fills the interior of a pie section defined by an ellipse specified by a pair of
	** coordinates, a width, and a height and two radial lines.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FillPie%28vs.80%29.aspx
	** Parameters:
	**  Brush brush, Rectangle rect, float startAngle, float sweepAngle
	**  Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle
	**  Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle
	** Returns: void
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush, tnX, tnY, tnWidth, tnHeight, tnStartAngle, tnSweepAngle
	*********** toBrush AS xfcBrush, toRect AS xfcRectangle, tnStartAngle, tnSweepAngle
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 4	&& Pen, Rectangle, Number, Number
				m.loRect = tnX
				m.tnStartAngle = m.tnY
				m.tnSweepAngle = m.tnWidth
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
			CASE PCOUNT() = 7
			ENDCASE
			
			IF This.UsePrecision
				This.SetStatus(xfcGdipFillPie(This.Handle, m.toBrush.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
			ELSE
				This.SetStatus(xfcGdipFillPieI(This.Handle, m.toBrush.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.tnStartAngle, m.tnSweepAngle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FillPolygon
	*********************************************************************
	** Method: xfcGraphics.FillPolygon
	**
	** Fills the interior of a polygon defined by an array of points specified by Point
	** structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FillPolygon%28vs.80%29.aspx
	** Parameters:
	**  Brush brush, Point[] points
	**  Brush brush, PointF[] points
	**  Brush brush, Point[] points, FillMode fillMode
	**  Brush brush, PointF[] points, FillMode fillMode
	** Returns: void
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush, taoPoints AS xfcPoint, ;
					tiFillMode AS EnumFillMode
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lqPoints, liCount, loPoint AS xfcPoint
			m.tiFillMode = EVL(m.tiFIllMode, FillModeAlternate)
			IF This.UsePrecision
				m.loPoint = CREATEOBJECT("xfcPointF")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
				This.SetStatus(xfcGdipFillPolygon(This.Handle, m.toBrush.Handle, lqPoints, m.liCount, m.tiFillMode))
			ELSE
				m.loPoint = CREATEOBJECT("xfcPoint")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPoints, @liCount)
				This.SetStatus(xfcGdipFillPolygonI(This.Handle, m.toBrush.Handle, lqPoints, m.liCount, m.tiFillMode))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FillRectangle
	*********************************************************************
	** Method: xfcGraphics.FillRectangle
	**
	** Fills the interior of a rectangle specified by a pair of coordinates, a width, and
	** a height.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FillRectangle%28vs.80%29.aspx
	** Parameters:
	**  Brush brush, Rectangle rect
	**  Brush brush, RectangleF rect
	**  Brush brush, int x, int y, int width, int height
	**  Brush brush, float x, float y, float width, float height
	** Returns: void
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush, tnX, tnY, tnWidth, tnHeight
	*********** toBrush AS xfcBrush, toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE PCOUNT() = 2
				m.loRect = m.tnX
				m.loRect.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
			CASE PCOUNT() = 5
			ENDCASE
			
			IF This.UsePrecision
				This.SetStatus(xfcGdipFillRectangle(This.Handle, m.toBrush.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
			ELSE
				This.SetStatus(xfcGdipFillRectangleI(This.Handle, m.toBrush.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FillRectangles
	*********************************************************************
	** Method: xfcGraphics.FillRectangles
	**
	** Fills the interiors of a series of rectangles specified by Rectangle structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FillRectangles%28vs.80%29.aspx
	** Parameters:
	**  Brush brush, Rectangle[] rects
	**  Brush brush, RectangleF[] rects
	** Returns: void
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush, taoRects AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liCount, lqRects, loRect AS xfcRectangle
			m.liCount = 0
			m.lqRects = 0h
			
			IF This.UsePrecision
				loRect = CREATEOBJECT("xfcRectangleF")
				lqRects = m.loRect.ToVarBinary(@taoRects, @liCount)
				This.SetStatus(xfcGdipFillRectangles(This.Handle, m.toBrush.Handle, lqRects, m.liCount))
			ELSE
				loRect = CREATEOBJECT("xfcRectangle")
				lqRects = m.loRect.ToVarBinary(@taoRects, @liCount)
				This.SetStatus(xfcGdipFillRectanglesI(This.Handle, m.toBrush.Handle, lqRects, m.liCount))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FillRegion
	*********************************************************************
	** Method: xfcGraphics.FillRegion
	**
	** Fills the interior of a Region object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FillRegion%28vs.80%29.aspx
	** Parameters:
	**  Brush brush, Region region
	** Returns: void
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush, toRegion AS xfcRegion
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipFillRegion(This.Handle, m.toBrush.Handle, m.toRegion.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Flush
	*********************************************************************
	** Method: xfcGraphics.Flush
	**
	** Forces execution of all pending graphics operations and returns immediately without
	** waiting for the operations to finish.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.Flush%28vs.80%29.aspx
	** Parameters:
	**  [None]
	**  FlushIntention intention
	** Returns: void
	*********************************************************************
	LPARAMETERS tiIntention AS EnumFlushIntention
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipFlush(This.Handle, m.tiIntention))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FromHdc
	*********************************************************************
	** Method: xfcGraphics.FromHdc
	**
	** Creates a new Graphics object from the specified handle to a device context.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**  2006/08/24: BDurban - Changed to call FromHDCInternal
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FromHdc%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hdc
	**  IntPtr hdc, IntPtr hdevice
	** Returns: Graphics
	*********************************************************************
	LPARAMETERS tHDc AS IntPtr, ;
					tHDevice AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lhGraphics, loGraphics AS xfcGraphics
			m.lhGraphics = 0
			m.loGraphics = NULL
			
			IF EMPTY(m.thDevice)
				m.loGraphics = This.FromHdcInternal(m.tHdc)
			ELSE
				This.SetStatus(xfcGdipCreateFromHDC2(m.tHdc, m.tHDevice, @lhGraphics))
				IF(m.lhGraphics <> 0)
					m.loGraphics = CREATEOBJECT("xfcGraphics")
					m.loGraphics.Handle = m.lhGraphics
				ENDIF
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loGraphics
	ENDFUNC


	*********************************************************************
	FUNCTION FromHdcInternal
	*********************************************************************
	** Method: xfcGraphics.FromHdcInternal
	**
	** Internal method. Do not use.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/08/24: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FromHdcInternal%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hdc
	** Returns: Graphics
	*********************************************************************
	LPARAMETERS tHDc AS IntPtr
		
		*!ToDo: Test this function
		LOCAL loGraphics AS xfcGraphics, lhGraphics
		
		LOCAL loExc AS Exception
		TRY
			m.lhGraphics = 0
			m.loGraphics = NULL
			This.SetStatus(xfcGdipCreateFromHDC(tHDc, @lhGraphics))
			IF(m.lhGraphics <> 0)
				m.loGraphics = CREATEOBJECT("xfcGraphics")
				m.loGraphics.Handle = m.lhGraphics
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loGraphics
	ENDFUNC


	*********************************************************************
	FUNCTION FromHwnd
	*********************************************************************
	** Method: xfcGraphics.FromHwnd
	**
	** Creates a new Graphics object from the specified handle to a window.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/24: BDurban - Changed to call FromHwndInternal
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FromHwnd%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hwnd
	** Returns: Graphics
	*********************************************************************
	LPARAMETERS tHWnd AS IntPtr
		
		RETURN This.FromHwndInternal(m.tHWnd)
	ENDFUNC


	*********************************************************************
	FUNCTION FromHwndInternal
	*********************************************************************
	** Method: xfcGraphics.FromHwndInternal
	**
	** Internal method. Do not use.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/08/24: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FromHwndInternal%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hwnd
	** Returns: Graphics
	*********************************************************************
	LPARAMETERS tHWnd AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loGraphics, lhGraphics
			m.lhGraphics = 0
			m.loGraphics = NULL
			
			This.SetStatus(xfcGdipCreateFromHWND(m.tHWnd, @lhGraphics))
			IF(m.lhGraphics <> 0)
				m.loGraphics = CREATEOBJECT("xfcGraphics")
				m.loGraphics.Handle = m.lhGraphics
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loGraphics
	ENDFUNC


	*********************************************************************
	FUNCTION FromImage
	*********************************************************************
	** Method: xfcGraphics.FromImage
	**
	** Creates a new Graphics object from the specified Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.FromImage%28vs.80%29.aspx
	** Parameters:
	**  Image image
	** Returns: Graphics
	*********************************************************************
	LPARAMETERS toImage AS xfcImage
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loGraphics, lhGraphics
			m.lhGraphics = 0
			m.loGraphics = NULL
			This.SetStatus(xfcGdipGetImageGraphicsContext(m.toImage.Handle, @lhGraphics))
			IF(m.lhGraphics <> 0)
				m.loGraphics = CREATEOBJECT("xfcGraphics")
				m.loGraphics.Handle = m.lhGraphics
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loGraphics
	ENDFUNC


	*********************************************************************
	FUNCTION GetHalftonePalette
	*********************************************************************
	** Method: xfcGraphics.GetHalftonePalette
	**
	** Gets a handle to the current Windows halftone palette.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/14: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.GetHalftonePalette%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: IntPtr
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liPointer
			m.liPointer = This.SetStatus(xfcGdipCreateHalftonePalette())
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liPointer
	ENDFUNC


	*********************************************************************
	FUNCTION GetHdc
	*********************************************************************
	** Method: xfcGraphics.GetHdc
	**
	** Gets the handle to the device context associated with this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.GetHdc%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: IntPtr
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liPointer
			m.liPointer = 0
			This.SetStatus(xfcGdipGetDC(This.Handle, @liPointer))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liPointer
	ENDFUNC


	*********************************************************************
	FUNCTION GetNearestColor
	*********************************************************************
	** Method: xfcGraphics.GetNearestColor
	**
	** Gets the nearest color to the specified Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.GetNearestColor%28vs.80%29.aspx
	** Parameters:
	**  Color color
	** Returns: Color
	*********************************************************************
	LPARAMETERS toColor AS xfcColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loColor, liArgb
			m.liArgb = toColor.ARGB
			m.loColor = NULL
			This.SetStatus(xfcGdipGetNearestColor(This.Handle, @liArgb))
				m.loColor = CREATEOBJECT("xfcColor")
				m.loColor.FromARGB(m.liArgb)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION InterpolationMode_ACCESS
	*********************************************************************
	** Property: InterpolationMode (Access)
	**
	** Gets or sets the interpolation mode associated with this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.InterpolationMode%28vs.80%29.aspx
	** Returns: InterpolationMode
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liInterpolationMode
		m.liInterpolationMode = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetInterpolationMode(This.Handle, @liInterpolationMode))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liInterpolationMode
	ENDFUNC


	*********************************************************************
	FUNCTION InterpolationMode_ASSIGN
	*********************************************************************
	** Property: InterpolationMode (Assign)
	**
	** Gets or sets the interpolation mode associated with this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiInterpolationMode
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetInterpolationMode(This.Handle, m.tiInterpolationMode))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION IntersectClip
	*********************************************************************
	** Method: xfcGraphics.IntersectClip
	**
	** Updates the clip region of this Graphics object to the intersection of the current
	** clip region and the specified Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.IntersectClip%28vs.80%29.aspx
	** Parameters:
	**  Rectangle rect
	**  RectangleF rect
	**  Region region
	** Returns: void
	*********************************************************************
	LPARAMETERS toRegion AS xfcRegion
	*********** toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		RETURN This.SetClip(m.toRegion, CombineModeIntersect)
	ENDFUNC


	*********************************************************************
	FUNCTION IsClipEmpty_ACCESS
	*********************************************************************
	** Property: IsClipEmpty (Access)
	**
	** Gets a value indicating whether the clipping region of this Graphics object is empty.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.IsClipEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liResult
		m.liResult = .F.
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipIsClipEmpty(This.Handle, @liResult))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liResult <> 0
	ENDFUNC


	*********************************************************************
	FUNCTION IsVisible
	*********************************************************************
	** Method: xfcGraphics.IsVisible
	**
	** Indicates whether the point specified by a pair of coordinates is contained within
	** the visible clip region of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.IsVisible%28vs.80%29.aspx
	** Parameters:
	**  Point point
	**  PointF point
	**  Rectangle rect
	**  RectangleF rect
	**  int x, int y
	**  float x, float y
	**  int x, int y, int width, int height
	**  float x, float y, float width, float height
	** Returns: bool
	*********************************************************************
	LPARAMETERS tnX, tnY, tnWidth, tnHeight
	*********** tnX, tnY
	*********** toPoint AS xfcPoint
	*********** toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue, lcVarType, loObject, liResult
			LOCAL lnFunctionType
			m.llValue = .F.
			m.lnFunctionType = 0
			m.liResult = 0
			m.loObject = NULL
			m.lcVarType = VARTYPE(m.tnX)+VARTYPE(m.tnY)+VARTYPE(m.tnWidth)+VARTYPE(m.tnHeight)
			
			DO CASE
			CASE m.lcVarType == "NNNN"
				m.lnFunctionType = 2
			CASE LEFT(m.lcVarType,2) == "NN"
				m.lnFunctionType = 1
			CASE LEFT(m.lcVarType,1) == "O" AND INLIST(m.tnX.BaseName, "Rectangle", "RectangleF")
				m.loObject = m.tnX
				m.loObject.GetExtent(@tnX, @tnY, @tnWidth, @tnHeight)
				m.lnFunctionType = 2
			CASE LEFT(m.lcVarType,1) == "O" AND INLIST(m.tnX.BaseName, "Point", "PointF")
				m.loObject = m.tnX
				m.loObject.GetExtent(@tnX, @tnY)
				m.lnFunctionType = 1
			ENDCASE
			
			DO CASE
			CASE m.lnFunctionType = 1
				IF This.UsePrecision
					This.SetStatus(xfcGdipIsVisiblePoint(This.Handle, m.lnX, m.lnY, @liResult))
				ELSE
					This.SetStatus(xfcGdipIsVisiblePointI(This.Handle, m.lnX, m.lnY, @liResult))
				ENDIF
			CASE m.lnFunctionType = 2
				IF This.UsePrecision
					This.SetStatus(xfcGdipIsVisibleRect(This.Handle, m.lnX, m.lnY, m.lnWidth, m.lnHeight, @liResult))
				ELSE
					This.SetStatus(xfcGdipIsVisibleRectI(This.Handle, m.lnX, m.lnY, m.lnWidth, m.lnHeight, @liResult))
				ENDIF
			ENDCASE
			
			m.llValue = (m.liResult=1)
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsVisibleClipEmpty_ACCESS
	*********************************************************************
	** Property: IsVisibleClipEmpty (Access)
	**
	** Gets a value indicating whether the visible clipping region of this Graphics object
	** is empty.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.IsVisibleClipEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liResult
		m.liResult = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipIsVisibleClipEmpty(This.Handle, @liResult))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liResult <> 0
	ENDFUNC


	*********************************************************************
	FUNCTION MeasureCharacterRanges
	*********************************************************************
	** Method: xfcGraphics.MeasureCharacterRanges
	**
	** Gets an array of Region objects, each of which bounds a range of character positions
	** within the specified string.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/14: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.MeasureCharacterRanges%28vs.80%29.aspx
	** Parameters:
	**  string text, Font font, RectangleF layoutRect, StringFormat stringFormat
	** Returns: Region[]
	*********************************************************************
	LPARAMETERS tcText, toFont AS xfcFont, toLayoutRect AS xfcRectangleF, toStringFormat AS xfcStringFormat
	
	*!ToDo: Test this function
	
		LOCAL loExc AS Exception
		TRY
			LOCAL loRegion AS xfcRegion, liCount, lqRegions, lnLoop, loRegion
			m.liCount = 0
			This.SetStatus(xfcGdipGetStringFormatMeasurableCharacterRangeCount(m.toStringFormat.Handle, @m.liCount))
			IF m.liCount > 0
				DIMENSION This._internalarray[m.liCount]
				m.lqRegions = 0h
				FOR m.lnLoop = 1 TO m.liCount
					m.loRegion = CREATEOBJECT("xfcRegion")
					m.lqRegions = m.lqRegions + BINTOC(m.loRegion.Handle, "4rs")
					This._internalarray[m.lnLoop] = m.loRegion
				ENDFOR
				This.SetStatus(xfcGdipMeasureCharacterRanges(This.Handle, STRCONV(m.tcText+0h00,5), LEN(m.tcText), ;
						m.toFont.Handle, m.toLayoutRect.ToVarBinary(), m.toStringFormat.Handle, m.liCount, @lqRegions))
			ELSE
				*!ToDo: Should we return NULL or an empty array here?
				DIMENSION This._internalarray[1]
				This._internalarray = EMPTY_VFPARRAY
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
	
		RETURN @This._internalarray
	ENDFUNC


	*********************************************************************
	FUNCTION MeasureString
	*********************************************************************
	** Method: xfcGraphics.MeasureString
	**
	** Measures the specified string when drawn with the specified Font object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.MeasureString%28vs.80%29.aspx
	** Parameters:
	**  string text, Font font
	**  string text, Font font, int width
	**  string text, Font font, SizeF layoutArea
	**  string text, Font font, int width, StringFormat format
	**  string text, Font font, PointF origin, StringFormat stringFormat
	**  string text, Font font, SizeF layoutArea, StringFormat stringFormat
	**  string text, Font font, SizeF layoutArea, StringFormat stringFormat, out int charactersFitted, out int linesFilled
	** Returns: SizeF
	*********************************************************************
	LPARAMETERS tcText, toFont AS xfcFont, ;
					toLayout AS xfcSizeF, ;
					toFormat AS xfcStringFormat, ;
					tiCharactersFitted, tiLinesFilled
	*********** tcText, toFont AS xfcFont [, tiWidth][, toFormat AS xfcStringFormat]
	*********** tcText, toFont AS xfcFont, toOrigin AS xfcPointF, toStringFormat AS xfcStringFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loSize AS xfcSizeF, loRect AS xfcRectangleF
			LOCAL lhFont, lhFormat, lnX, lnY, lnWidth, lnHeight, lqSize
			m.loSize = NULL
			STORE 0 TO m.lnX, m.lnY, m.lnWidth, m.lnHeight
			m.lqRect = EMPTY_RECTANGLEF
			
			m.lhFormat = IIF(VARTYPE(m.toFormat)="O",m.toFormat.Handle, 0)
			m.lhFont = IIF(VARTYPE(m.toFont)="O",m.toFont.Handle, 0)
			
			m.tiCharactersFitted = EVL(m.tiCharactersFitted, 0)
			m.tiLinesFilled = EVL(m.tiLinesFilled,0)
			
			DO CASE
			CASE VARTYPE(m.toLayout)="O" AND INLIST(m.toLayout.BaseName, "Size", "SizeF")
				m.toLayout.GetExtent(@lnWidth, @lnHeight)
				
			CASE VARTYPE(m.toLayout)="O" AND INLIST(m.toLayout.BaseName, "Point", "PointF")
				m.toLayout.GetExtent(@lnX, @lnY)
				
		** Rectangle is not part of the .NET framework, but was added for completness
			CASE VARTYPE(m.toLayout)="O" AND INLIST(m.toLayout.BaseName, "Rectangle", "RectangleF")
				m.toLayout.GetExtent(@lnX, @lnY, @lnWidth, @lnHeight)
				
			CASE VARTYPE(m.toLayout)="N"
				m.lnWidth = m.toLayout
			ENDCASE
			m.loRect = CREATEOBJECT("xfcRectangleF", m.lnX, m.lnY, m.lnWidth, m.lnHeight)
			
			This.SetStatus(xfcGdipMeasureString(This.Handle, STRCONV(m.tcText+0h00,5), LENC(m.tcText), m.lhFont, m.loRect.ToVarBinary(), m.lhFormat, @lqRect, @tiCharactersFitted, @tiLinesFilled))
			m.loSize = CREATEOBJECT("xfcSizeF", RIGHT(lqRect,8))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loSize
	ENDFUNC


	*********************************************************************
	FUNCTION MultiplyTransform
	*********************************************************************
	** Method: xfcGraphics.MultiplyTransform
	**
	** Multiplies the world transformation of this Graphics object and specified the Matrix
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.MultiplyTransform%28vs.80%29.aspx
	** Parameters:
	**  Matrix matrix
	**  Matrix matrix, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS toMatrix AS xfcMatrix, tiOrder AS EnumMatrixOrder
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			m.tiOrder = EVL(m.tiOrder, MatrixOrderPrepend)
			This.SetStatus(xfcGdipMultiplyWorldTransform(This.Handle, m.toMatrix.Handle, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION PageScale_ACCESS
	*********************************************************************
	** Property: PageScale (Access)
	**
	** Gets or sets the scaling between world units and page units for this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.PageScale%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPageScale(This.Handle, @lnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	FUNCTION PageScale_ASSIGN
	*********************************************************************
	** Property: PageScale (Assign)
	**
	** Gets or sets the scaling between world units and page units for this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetPageScale(This.Handle, m.tnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION PageUnit_ACCESS
	*********************************************************************
	** Property: PageUnit (Access)
	**
	** Gets or sets the unit of measure used for page coordinates in this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.PageUnit%28vs.80%29.aspx
	** Returns: GraphicsUnit
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liGraphicsUnit
		m.liGraphicsUnit = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPageUnit(This.Handle, @liGraphicsUnit))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liGraphicsUnit
	ENDFUNC


	*********************************************************************
	FUNCTION PageUnit_ASSIGN
	*********************************************************************
	** Property: PageUnit (Assign)
	**
	** Gets or sets the unit of measure used for page coordinates in this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiGraphicsUnit
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetPageUnit(This.Handle, m.tiGraphicsUnit))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION PixelOffsetMode_ACCESS
	*********************************************************************
	** Property: PixelOffsetMode (Access)
	**
	** Gets or set a value specifying how pixels are offset during rendering of this Graphics
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.PixelOffsetMode%28vs.80%29.aspx
	** Returns: PixelOffsetMode
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liPixelOffsetMode
		m.liPixelOffsetMode = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPixelOffsetMode(This.Handle, @liPixelOffsetMode))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liPixelOffsetMode
	ENDFUNC


	*********************************************************************
	FUNCTION PixelOffsetMode_ASSIGN
	*********************************************************************
	** Property: PixelOffsetMode (Assign)
	**
	** Gets or set a value specifying how pixels are offset during rendering of this Graphics
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiPixelOffsetMode
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetPixelOffsetMode(This.Handle, m.tiPixelOffsetMode))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ReleaseHdc
	*********************************************************************
	** Method: xfcGraphics.ReleaseHdc
	**
	** Releases a device context handle obtained by a previous call to the GetHdc method
	** of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2006/08/24: BDurban - Changed to call ReleaseHDCInternal
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.ReleaseHdc%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hdc
	** Returns: void
	*********************************************************************
	LPARAMETERS tHDc AS IntPtr
		
		RETURN This.ReleaseHdcInternal(m.tHDc)
	ENDFUNC


	*********************************************************************
	FUNCTION ReleaseHdcInternal
	*********************************************************************
	** Method: xfcGraphics.ReleaseHdcInternal
	**
	** Internal method. Do not use.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/08/24: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.ReleaseHdcInternal%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hdc
	** Returns: void
	*********************************************************************
	LPARAMETERS tHDc AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipReleaseDC(This.Handle, m.tHDc))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION RenderingOrigin_ACCESS
	*********************************************************************
	** Property: RenderingOrigin (Access)
	**
	** Gets or sets the rendering origin of this Graphics object for dithering and for
	** hatch brushes.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.RenderingOrigin%28vs.80%29.aspx
	** Returns: Point
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loPoint
		LOCAL liX, liY
		m.loPoint = NULL
		m.liX = 0
		m.liY = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetRenderingOrigin(This.Handle, @liX, @liY))
			m.loPoint = CREATEOBJECT("xfcPoint", m.liX, m.liY)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPoint
	ENDFUNC


	*********************************************************************
	FUNCTION RenderingOrigin_ASSIGN
	*********************************************************************
	** Property: RenderingOrigin (Assign)
	**
	** Gets or sets the rendering origin of this Graphics object for dithering and for
	** hatch brushes.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS toPoint
		
		*!ToDo: Test this function
		LOCAL liX, liY
		m.liX = 0
		m.liY = 0
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(m.toPoint) = "O"
				m.toPoint.GetExtent(@liX, @liY)
				This.SetStatus(xfcGdipSetRenderingOrigin(This.Handle, m.liX, m.liY))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ResetClip
	*********************************************************************
	** Method: xfcGraphics.ResetClip
	**
	** Resets the clip region of this Graphics object to an infinite region.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.ResetClip%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: void
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			This.SetStatus(xfcGdipResetClip(This.Handle))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ResetTransform
	*********************************************************************
	** Method: xfcGraphics.ResetTransform
	**
	** Resets the world transformation matrix of this Graphics object to the identity matrix.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.ResetTransform%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: void
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			This.SetStatus(xfcGdipResetWorldTransform(This.Handle))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Restore
	*********************************************************************
	** Method: xfcGraphics.Restore
	**
	** Restores the state of this Graphics object to the state represented by a GraphicsState
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.Restore%28vs.80%29.aspx
	** Parameters:
	**  GraphicsState gstate
	** Returns: void
	*********************************************************************
	LPARAMETERS toGstate AS xfcGraphicsState
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			This.SetStatus(xfcGdipRestoreGraphics(This.Handle, m.toGstate.Handle))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION RotateTransform
	*********************************************************************
	** Method: xfcGraphics.RotateTransform
	**
	** Applies the specified rotation to the transformation matrix of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.RotateTransform%28vs.80%29.aspx
	** Parameters:
	**  float angle
	**  float angle, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnAngle ;
					, tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		** Default value
			tiOrder = EVL(m.tiOrder,0)	&& MatrixOrderPrepend
			This.SetStatus(xfcGdipRotateWorldTransform(This.Handle, m.tnAngle, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Save
	*********************************************************************
	** Method: xfcGraphics.Save
	**
	** Saves the current state of this Graphics object and identifies the saved state with
	** a GraphicsState object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.Save%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: GraphicsState
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loGraphicsState AS xfcGraphicsState, lhGraphicsState
			m.lhGraphicsState = 0
			m.loGraphicsState = NULL
			This.SetStatus(xfcGdipSaveGraphics(This.Handle, @lhGraphicsState))
			IF(m.lhGraphicsState <> 0)
				m.loGraphicsState = NEWOBJECT("xfcGraphicsState",XFCCLASS_DRAWING2D)
				m.loGraphicsState.Handle = m.lhGraphicsState
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loGraphicsState
	ENDFUNC


	*********************************************************************
	FUNCTION ScaleTransform
	*********************************************************************
	** Method: xfcGraphics.ScaleTransform
	**
	** Applies the specified scaling operation to the transformation matrix of this Graphics
	** object by prepending it to the object's transformation matrix.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2006/12/17: CChalom - Fix bad variable names
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.ScaleTransform%28vs.80%29.aspx
	** Parameters:
	**  float sx, float sy
	**  float sx, float sy, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnSx, tnSy, ;
					tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			m.tiOrder = EVL(m.tiOrder,0)	&& MatrixOrderPrepend
			This.SetStatus(xfcGdipScaleWorldTransform(This.Handle, m.tnSx, m.tnSy, m.tiOrder))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION SetClip
	*********************************************************************
	** Method: xfcGraphics.SetClip
	**
	** Sets the clipping region of this Graphics object to the Clip property of the specified
	** Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.SetClip%28vs.80%29.aspx
	** Parameters:
	**  Graphics g
	**  GraphicsPath path
	**  Rectangle rect
	**  RectangleF rect
	**  Graphics g, CombineMode combineMode
	**  GraphicsPath path, CombineMode combineMode
	**  Rectangle rect, CombineMode combineMode
	**  RectangleF rect, CombineMode combineMode
	**  Region region, CombineMode combineMode
	** Returns: void
	*********************************************************************
	LPARAMETERS toRegion AS xfcRegion, tiCombineMode AS EnumCombineMode
	*********** toPath AS xfcGraphicsPath [, tiCombineMode AS EnumCombineMode]
	*********** toRect AS xfcRectangle [, tiCombineMode AS EnumCombineMode]
	*********** toG AS xfcGraphics [, tiCombineMode AS EnumCombineMode]
	
		*!ToDo: Test this function
	
		LOCAL loExc AS Exception
		TRY
			LOCAL lnX, lnY, lnWidth, lnHeight
			STORE 0.0 TO m.lnX, m.lnY, m.lnWidth, m.lnHeight
			m.tiCombineMode = EVL(m.tiCombineMode, CombineModeReplace)
		
			DO CASE
			CASE VARTYPE(m.toRegion) = "O" AND m.toRegion.BaseName == "Graphics"
				This.SetStatus(xfcGdipSetClipGraphics(This.Handle, m.toRegion.Handle, m.tiCombineMode))
	
			CASE VARTYPE(m.toRegion) = "O" AND m.toRegion.BaseName == "RectangleF"
				m.toRegion.GetExtent(@lnX, @lnY, @lnWidth, @lnHeight)
				This.SetStatus(xfcGdipSetClipRect(This.Handle, m.lnX, m.lnY, m.lnWidth, m.lnHeight, m.tiCombineMode))
			
			CASE VARTYPE(m.toRegion) = "O" AND m.toRegion.BaseName == "Rectangle"
				m.toRegion.GetExtent(@lnX, @lnY, @lnWidth, @lnHeight)
				This.SetStatus(xfcGdipSetClipRectI(This.Handle, m.lnX, m.lnY, m.lnWidth, m.lnHeight, m.tiCombineMode))
			
			CASE VARTYPE(m.toRegion) = "O" AND m.toRegion.BaseName == "Region"
				This.SetStatus(xfcGdipSetClipRegion(This.Handle, m.toRegion.Handle, m.tiCombineMode))
			
			CASE VARTYPE(m.toRegion) = "O" AND m.toRegion.BaseName == "GraphicsPath"
				This.SetStatus(xfcGdipSetClipPath(This.Handle, m.toRegion.Handle, m.tiCombineMode))
			
		*!*	CASE m.lnFunctionType = 5
		*!*		This.SetStatus(xfcGdipSetClipHrgn(This.Handle, m.lHRgn, m.tiCombineMode))
			ENDCASE
	
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC

				
	*********************************************************************
	FUNCTION SmoothingMode_ACCESS
	*********************************************************************
	** Property: SmoothingMode (Access)
	**
	** Gets or sets the rendering quality for this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.SmoothingMode%28vs.80%29.aspx
	** Returns: SmoothingMode
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liSmoothingMode
		m.liSmoothingMode = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetSmoothingMode(This.Handle, @liSmoothingMode))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liSmoothingMode
	ENDFUNC


	*********************************************************************
	FUNCTION SmoothingMode_ASSIGN
	*********************************************************************
	** Property: SmoothingMode (Assign)
	**
	** Gets or sets the rendering quality for this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiSmoothingMode
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetSmoothingMode(This.Handle, m.tiSmoothingMode))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION TextContrast_ACCESS
	*********************************************************************
	** Property: TextContrast (Access)
	**
	** Gets or sets the gamma correction value for rendering text.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.TextContrast%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liValue
		m.liValue = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetTextContrast(This.Handle, @liValue))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION TextContrast_ASSIGN
	*********************************************************************
	** Property: TextContrast (Assign)
	**
	** Gets or sets the gamma correction value for rendering text.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetTextContrast(This.Handle, m.tiValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION TextRenderingHint_ACCESS
	*********************************************************************
	** Property: TextRenderingHint (Access)
	**
	** Gets or sets the rendering mode for text associated with this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.TextRenderingHint%28vs.80%29.aspx
	** Returns: TextRenderingHint
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liTextRenderingHint
		m.liTextRenderingHint = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetTextRenderingHint(This.Handle, @liTextRenderingHint))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liTextRenderingHint
	ENDFUNC


	*********************************************************************
	FUNCTION TextRenderingHint_ASSIGN
	*********************************************************************
	** Property: TextRenderingHint (Assign)
	**
	** Gets or sets the rendering mode for text associated with this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiTextRenderingHint
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetTextRenderingHint(This.Handle, m.tiTextRenderingHint))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION TransformPoints
	*********************************************************************
	** Method: xfcGraphics.TransformPoints
	**
	** Transforms an array of points from one coordinate space to another using the current
	** world and page transformations of this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.TransformPoints%28vs.80%29.aspx
	** Parameters:
	**  CoordinateSpace destSpace, CoordinateSpace srcSpace, Point[] pts
	**  CoordinateSpace destSpace, CoordinateSpace srcSpace, PointF[] pts
	** Returns: void
	*********************************************************************
	LPARAMETERS tiDestSpace AS EnumCoordinateSpace, tiSrcSpace AS EnumCoordinateSpace, taoPts AS xfcPoint
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lqPoints, liCount, loPoint AS xfcPoint
			m.lqPoints = 0h
			m.liCount = 0
			IF This.UsePrecision
				m.loPoint = CREATEOBJECT("xfcPointF")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPts, @liCount)
				This.SetStatus(xfcGdipTransformPoints(This.Handle, m.tiDestSpace, m.tiSrcSpace, @lqPoints, m.liCount))
			ELSE
				m.loPoint = CREATEOBJECT("xfcPoint")
				m.lqPoints = m.loPoint.ToVarBinary(@taoPts, @liCount)
				This.SetStatus(xfcGdipTransformPointsI(This.Handle, m.tiDestSpace, m.tiSrcSpace, @lqPoints, m.liCount))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Transform_ACCESS
	*********************************************************************
	** Property: Transform (Access)
	**
	** Gets or sets the world transformation for this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.Transform%28vs.80%29.aspx
	** Returns: Matrix
	*********************************************************************
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		LOCAL loMatrix
		m.loMatrix = NULL
	
		LOCAL loExc AS Exception
		TRY
			m.loMatrix = NEWOBJECT("xfcMatrix", XFCCLASS_DRAWING2D)
			This.SetStatus(xfcGdipGetWorldTransform(This.Handle, m.loMatrix.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loMatrix
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION Transform_ASSIGN
	*********************************************************************
	** Property: Transform (Assign)
	**
	** Gets or sets the world transformation for this Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2006/08/03: CChalom - Check the parameter type. A null is passed when this object is released
	*********************************************************************
	LPARAMETERS toMatrix
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(toMatrix) = "O"
				This.SetStatus(xfcGdipSetWorldTransform(This.Handle, m.toMatrix.Handle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION TranslateClip
	*********************************************************************
	** Method: xfcGraphics.TranslateClip
	**
	** Translates the clipping region of this Graphics object by specified amounts in the
	** horizontal and vertical directions.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.TranslateClip%28vs.80%29.aspx
	** Parameters:
	**  int dx, int dy
	**  float dx, float dy
	** Returns: void
	*********************************************************************
	LPARAMETERS tnDx, tnDy
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			IF This.UsePrecision
				This.SetStatus(xfcGdipTranslateClip(This.Handle, m.lnDx, m.lnDy))
			ELSE
				This.SetStatus(xfcGdipTranslateClipI(This.Handle, m.lnDx, m.lnDy))
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION TranslateTransform
	*********************************************************************
	** Method: xfcGraphics.TranslateTransform
	**
	** Prepends the specified translation to the transformation matrix of this Graphics
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.TranslateTransform%28vs.80%29.aspx
	** Parameters:
	**  float dx, float dy
	**  float dx, float dy, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnDx, tnDy ;
					, tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			m.tiOrder = EVL(m.tiOrder,0)	&& MatrixOrderPrepend
			This.SetStatus(xfcGdipTranslateWorldTransform(This.Handle, m.tnDx, m.tnDy, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION VisibleClipBounds_ACCESS
	*********************************************************************
	** Property: VisibleClipBounds (Access)
	**
	** Gets the bounding rectangle of the visible clipping region of this Graphics
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Graphics.VisibleClipBounds%28vs.80%29.aspx
	** Returns: RectangleF
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loRectangle
		LOCAL lcRect
		m.loRectangle = NULL
		
		LOCAL loExc AS Exception
		TRY
			IF This.UsePrecision
				m.lcRect = EMPTY_RECTANGLEF
				This.SetStatus(xfcGdipGetVisibleClipBounds(This.Handle, @lcRect))
				m.loRectangle = CREATEOBJECT("xfcRectangleF", lcRect)
			ELSE
				m.lcRect = EMPTY_RECTANGLE
				This.SetStatus(xfcGdipGetVisibleClipBoundsI(This.Handle, @lcRect))
				m.loRectangle = CREATEOBJECT("xfcRectangle", lcRect)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loRectangle
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="addmetafilecomment" type="method" display="AddMetafileComment"/>]+;
		[<memberdata name="begincontainer" type="method" display="BeginContainer"/>]+;
		[<memberdata name="clear" type="method" display="Clear"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="drawarc" type="method" display="DrawArc"/>]+;
		[<memberdata name="drawbezier" type="method" display="DrawBezier"/>]+;
		[<memberdata name="drawbeziers" type="method" display="DrawBeziers"/>]+;
		[<memberdata name="drawclosedcurve" type="method" display="DrawClosedCurve"/>]+;
		[<memberdata name="drawcurve" type="method" display="DrawCurve"/>]+;
		[<memberdata name="drawellipse" type="method" display="DrawEllipse"/>]+;
		[<memberdata name="drawicon" type="method" display="DrawIcon"/>]+;
		[<memberdata name="drawiconunstretched" type="method" display="DrawIconUnstretched"/>]+;
		[<memberdata name="drawimage" type="method" display="DrawImage"/>]+;
		[<memberdata name="drawimageunscaled" type="method" display="DrawImageUnscaled"/>]+;
		[<memberdata name="drawline" type="method" display="DrawLine"/>]+;
		[<memberdata name="drawlines" type="method" display="DrawLines"/>]+;
		[<memberdata name="drawpath" type="method" display="DrawPath"/>]+;
		[<memberdata name="drawpie" type="method" display="DrawPie"/>]+;
		[<memberdata name="drawpolygon" type="method" display="DrawPolygon"/>]+;
		[<memberdata name="drawrectangle" type="method" display="DrawRectangle"/>]+;
		[<memberdata name="drawrectangles" type="method" display="DrawRectangles"/>]+;
		[<memberdata name="drawstring" type="method" display="DrawString"/>]+;
		[<memberdata name="endcontainer" type="method" display="EndContainer"/>]+;
		[<memberdata name="enumeratemetafile" type="method" display="EnumerateMetafile"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="excludeclip" type="method" display="ExcludeClip"/>]+;
		[<memberdata name="fillclosedcurve" type="method" display="FillClosedCurve"/>]+;
		[<memberdata name="fillellipse" type="method" display="FillEllipse"/>]+;
		[<memberdata name="fillpath" type="method" display="FillPath"/>]+;
		[<memberdata name="fillpie" type="method" display="FillPie"/>]+;
		[<memberdata name="fillpolygon" type="method" display="FillPolygon"/>]+;
		[<memberdata name="fillrectangle" type="method" display="FillRectangle"/>]+;
		[<memberdata name="fillrectangles" type="method" display="FillRectangles"/>]+;
		[<memberdata name="fillregion" type="method" display="FillRegion"/>]+;
		[<memberdata name="flush" type="method" display="Flush"/>]+;
		[<memberdata name="fromhdc" type="method" display="FromHdc"/>]+;
		[<memberdata name="fromhdcinternal" type="method" display="FromHdcInternal"/>]+;
		[<memberdata name="fromhwnd" type="method" display="FromHwnd"/>]+;
		[<memberdata name="fromhwndinternal" type="method" display="FromHwndInternal"/>]+;
		[<memberdata name="fromimage" type="method" display="FromImage"/>]+;
		[<memberdata name="gethalftonepalette" type="method" display="GetHalftonePalette"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gethdc" type="method" display="GetHdc"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="getnearestcolor" type="method" display="GetNearestColor"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="intersectclip" type="method" display="IntersectClip"/>]+;
		[<memberdata name="isvisible" type="method" display="IsVisible"/>]+;
		[<memberdata name="measurecharacterranges" type="method" display="MeasureCharacterRanges"/>]+;
		[<memberdata name="measurestring" type="method" display="MeasureString"/>]+;
		[<memberdata name="multiplytransform" type="method" display="MultiplyTransform"/>]+;
		[<memberdata name="releasehdc" type="method" display="ReleaseHdc"/>]+;
		[<memberdata name="releasehdcinternal" type="method" display="ReleaseHdcInternal"/>]+;
		[<memberdata name="resetclip" type="method" display="ResetClip"/>]+;
		[<memberdata name="resettransform" type="method" display="ResetTransform"/>]+;
		[<memberdata name="restore" type="method" display="Restore"/>]+;
		[<memberdata name="rotatetransform" type="method" display="RotateTransform"/>]+;
		[<memberdata name="save" type="method" display="Save"/>]+;
		[<memberdata name="scaletransform" type="method" display="ScaleTransform"/>]+;
		[<memberdata name="setclip" type="method" display="SetClip"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="transformpoints" type="method" display="TransformPoints"/>]+;
		[<memberdata name="translateclip" type="method" display="TranslateClip"/>]+;
		[<memberdata name="translatetransform" type="method" display="TranslateTransform"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="clip" type="property" display="Clip"/>]+;
		[<memberdata name="clipbounds" type="property" display="ClipBounds"/>]+;
		[<memberdata name="compositingmode" type="property" display="CompositingMode"/>]+;
		[<memberdata name="compositingquality" type="property" display="CompositingQuality"/>]+;
		[<memberdata name="dpix" type="property" display="DpiX"/>]+;
		[<memberdata name="dpiy" type="property" display="DpiY"/>]+;
		[<memberdata name="interpolationmode" type="property" display="InterpolationMode"/>]+;
		[<memberdata name="isclipempty" type="property" display="IsClipEmpty"/>]+;
		[<memberdata name="isvisibleclipempty" type="property" display="IsVisibleClipEmpty"/>]+;
		[<memberdata name="pagescale" type="property" display="PageScale"/>]+;
		[<memberdata name="pageunit" type="property" display="PageUnit"/>]+;
		[<memberdata name="pixeloffsetmode" type="property" display="PixelOffsetMode"/>]+;
		[<memberdata name="renderingorigin" type="property" display="RenderingOrigin"/>]+;
		[<memberdata name="smoothingmode" type="property" display="SmoothingMode"/>]+;
		[<memberdata name="textcontrast" type="property" display="TextContrast"/>]+;
		[<memberdata name="textrenderinghint" type="property" display="TextRenderingHint"/>]+;
		[<memberdata name="transform" type="property" display="Transform"/>]+;
		[<memberdata name="visibleclipbounds" type="property" display="VisibleClipBounds"/>]+;
		[<memberdata name="drawstringjustified" type="method" display="DrawStringJustified"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCICON
DEFINE CLASS xfcIcon AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Icon"
	Handle = 0	&& Gets the Windows handle for this Icon object. This is not a copy of the handle; do not free it.
	icondata = .NULL.
	Size = 0	&& Gets the size of this Icon object.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcIcon.Icon
	**
	** Initializes a new instance of the Icon class from the specified file name.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Partial
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.Icon%28vs.80%29.aspx
	** Parameters:
	**  Stream stream
	**  string fileName
	**  Icon original, Size size
	**  Type type, string resource
	**  Icon original, int width, int height
	**  Stream stream, int width, int height
	*********************************************************************
	LPARAMETERS toOriginal, tiWidth, tiHeight
	*********** tcFileName [, tiWidth, tiHeight]
	*********** tcFileName [, toSize AS xfcSize]
	*********** toOriginal AS xfcIcon [, tiWidth, tiHeight]
	*********** toOriginal AS xfcIcon [, toSize AS xfcSize]
	*********** toStream AS xfcStream [, tiWidth, tiHeight]
	*********** toType AS xfcType, tcResource
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			LOCAL loSize AS xfcSize
			
			DO CASE
		** Overload: 3,5
			CASE VARTYPE(toOriginal)="O" AND toOriginal.BaseName == "Icon"
				DO CASE
				CASE VARTYPE(m.tiWidth) = "O" AND INLIST(m.tiWidth.BaseName, "Size", "SizeF")
					m.loSize = m.tiWidth
					m.loSize.GetExtent(@tiWidth, @tiHeight)
				CASE VARTYPE(m.tiWidth)+VARTYPE(m.tiHeight) == "NN"
				OTHERWISE
					m.tiWidth = 0
					m.tiHeight = 0
				ENDCASE
				
				This.iconData = 0h+m.toOriginal.iconData
				IF ISNULL(m.toOriginal.iconData)
					WITH m.toOriginal
						This.Handle = xfcCopyImage(.Handle, 1, .Width, .Height, 0)
					ENDWITH
				ELSE
					This.Initialize(m.tiWidth, m.tiHeight)
				ENDIF
				
		** Overload: 2
			CASE VARTYPE(m.toOriginal)="C"
				DO CASE
				CASE VARTYPE(m.tiWidth) = "O" AND INLIST(m.tiWidth.BaseName, "Size", "SizeF")
					m.loSize = m.tiWidth
					m.loSize.GetExtent(@tiWidth, @tiHeight)
				CASE VARTYPE(m.tiWidth)+VARTYPE(m.tiHeight) == "NN"
				OTHERWISE
					m.tiWidth = 0
					m.tiHeight = 0
				ENDCASE
				
				This.iconData = 0h+FILETOSTR(m.toOriginal)
				This.Initialize(m.tiWidth, m.tiHeight)
			
		** Overload: 1,6
			CASE VARTYPE(m.toOriginal)="O" AND m.toOriginal.BaseName="Stream"
				ERROR 1999
				
			ENDCASE
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION initialize
	*********************************************************************
	** Property: Initialize
	**
	** History:
	**  2006/07/08: BDurban - Partial
	*********************************************************************
	LPARAMETERS tiWidth, tiHeight
		
		ERROR 1999
		
		LOCAL loExc AS Exception
		TRY
		
			IF ISNULL(This.iconData) OR This.Handle != 0
				THROW "Illegal State"
			ENDIF
			IF LEN(This.iconData) < 6
				THROW "Invlid Picture Type"
			ENDIF
			IF m.tiWidth = 0
				m.tiWidth = SYSMETRIC(16)	&& GetSystemMetrics(11)
			ENDIF
			IF m.tiHeight = 0
				m.tiHeight = SYSMETRIC(17)	&& GetSystemMetrics(12)
			ENDIF
			
		CATCH TO loExc
			THROW loExc
		FINALLY
		
		ENDTRY
		
		
		*!*	*!*	Private Sub Initialize(ByVal width As Integer, ByVal height As Integer)
		*!*	*!*	      If ((Me.iconData Is Nothing) OrElse (Me.handle <> IntPtr.Zero)) Then
		*!*	*!*	            Throw New InvalidOperationException(SR.GetString("IllegalState", New Object() { MyBase.GetType.Name }))
		*!*	*!*	      End If
		*!*	*!*	      If (Me.iconData.Length < Marshal.SizeOf(GetType(ICONDIR))) Then
		*!*	*!*	            Throw New ArgumentException(SR.GetString("InvalidPictureType", New Object() { "picture", "Icon" }))
		*!*	*!*	      End If
		*!*	*!*	      If (width = 0) Then
		*!*	*!*	            width = UnsafeNativeMethods.GetSystemMetrics(11)
		*!*	*!*	      End If
		*!*	*!*	      If (height = 0) Then
		*!*	*!*	            height = UnsafeNativeMethods.GetSystemMetrics(12)
		*!*	*!*	      End If
		*!*	      If (Icon.bitDepth = 0) Then
		*!*	            Dim ptr1 As IntPtr = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef)
		*!*	            Icon.bitDepth = UnsafeNativeMethods.GetDeviceCaps(New HandleRef(Nothing, ptr1), 12)
		*!*	            Icon.bitDepth = (Icon.bitDepth * UnsafeNativeMethods.GetDeviceCaps(New HandleRef(Nothing, ptr1), 14))
		*!*	            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, New HandleRef(Nothing, ptr1))
		*!*	            If (Icon.bitDepth = 8) Then
		*!*	                  Icon.bitDepth = 4
		*!*	            End If
		*!*	      End If
		*!*	      Dim numRef1 As Byte*
		*!*	      Fixed numRef1 = Me.iconData
		*!*	            Dim num1 As Short = Me.GetShort(numRef1)
		*!*	            Dim num2 As Short = Me.GetShort((numRef1 + 2))
		*!*	            Dim num3 As Short = Me.GetShort((numRef1 + 4))
		*!*	            If (((num1 <> 0) OrElse (num2 <> 1)) OrElse (num3 = 0)) Then
		*!*	                  Throw New ArgumentException(SR.GetString("InvalidPictureType", New Object() { "picture", "Icon" }))
		*!*	            End If
		*!*	            Dim num4 As Byte = 0
		*!*	            Dim num5 As Byte = 0
		*!*	            Dim num6 As Integer = 0
		*!*	            Dim numPtr1 As Byte* = (numRef1 + 6)
		*!*	            Dim num7 As Integer = Marshal.SizeOf(GetType(ICONDIRENTRY))
		*!*	            If ((num7 * num3) >= Me.iconData.Length) Then
		*!*	                  Throw New ArgumentException(SR.GetString("InvalidPictureType", New Object() { "picture", "Icon" }))
		*!*	            End If
		*!*	            Dim num8 As Integer = 0
		*!*	            Do While (num8 < num3)
		*!*	                  Dim icondirentry1 As ICONDIRENTRY
		*!*	                  icondirentry1.bWidth = numPtr1(0)
		*!*	                  icondirentry1.bHeight = numPtr1(1)
		*!*	                  icondirentry1.bColorCount = numPtr1(2)
		*!*	                  icondirentry1.bReserved = numPtr1(3)
		*!*	                  icondirentry1.wPlanes = Me.GetShort((numPtr1 + 4))
		*!*	                  icondirentry1.wBitCount = Me.GetShort((numPtr1 + 6))
		*!*	                  icondirentry1.dwBytesInRes = Me.GetInt((numPtr1 + 8))
		*!*	                  icondirentry1.dwImageOffset = Me.GetInt((numPtr1 + 12))
		*!*	                  Dim flag1 As Boolean = False
		*!*	                  Dim num9 As Integer = 0
		*!*	                  If (icondirentry1.bColorCount <> 0) Then
		*!*	                        num9 = 4
		*!*	                        If (icondirentry1.bColorCount < 16) Then
		*!*	                              num9 = 1
		*!*	                        End If
		*!*	                  Else
		*!*	                        num9 = icondirentry1.wBitCount
		*!*	                  End If
		*!*	                  If (num9 = 0) Then
		*!*	                        num9 = 8
		*!*	                  End If
		*!*	                  If (num6 = 0) Then
		*!*	                        flag1 = True
		*!*	                  Else
		*!*	                        Dim num10 As Integer = (Math.Abs(CInt((num4 - width))) + Math.Abs(CInt((num5 - height))))
		*!*	                        Dim num11 As Integer = (Math.Abs(CInt((icondirentry1.bWidth - width))) + Math.Abs(CInt((icondirentry1.bHeight - height))))
		*!*	                        If ((num11 < num10) OrElse ((num11 = num10) AndAlso (((num9 <= Icon.bitDepth) AndAlso (num9 > Me.bestBitDepth)) OrElse ((Me.bestBitDepth > Icon.bitDepth) AndAlso (num9 < Me.bestBitDepth))))) Then
		*!*	                              flag1 = True
		*!*	                        End If
		*!*	                  End If
		*!*	                  If flag1 Then
		*!*	                        num4 = icondirentry1.bWidth
		*!*	                        num5 = icondirentry1.bHeight
		*!*	                        Me.bestImageOffset = icondirentry1.dwImageOffset
		*!*	                        num6 = icondirentry1.dwBytesInRes
		*!*	                        Me.bestBitDepth = num9
		*!*	                  End If
		*!*	                  numPtr1 = (numPtr1 + num7)
		*!*	                  num8 += 1
		*!*	            Loop
		*!*	            If ((Me.bestImageOffset < 0) OrElse ((Me.bestImageOffset + num6) > Me.iconData.Length)) Then
		*!*	                  Throw New ArgumentException(SR.GetString("InvalidPictureType", New Object() { "picture", "Icon" }))
		*!*	            End If
		*!*	            Me.handle = SafeNativeMethods.CreateIconFromResourceEx((numRef1 + Me.bestImageOffset), num6, True, 196608, 0, 0, 0)
		*!*	            If (Me.handle = IntPtr.Zero) Then
		*!*	                  Throw New Win32Exception
		*!*	            End If
		*!*	      End Fixed
		*!*	End Sub
		
		*!*	
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcIcon.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This.Handle <> 0
				xfcDestroyIcon(This.Handle)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcIcon.Clone
	**
	** Clones the Icon object, creating a duplicate image.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.Clone%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: object
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			m.loObject = CREATEOBJECT(This.Class, This, This.Width, This.Height)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loObject
	ENDFUNC


	*********************************************************************
	FUNCTION Dispose
	*********************************************************************
	** Method: xfcIcon.Dispose
	**
	** Releases all resources used by this Icon object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.Dispose%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: void
	*********************************************************************
		
		RELEASE This
	ENDFUNC


	*********************************************************************
	FUNCTION ExtractAssociatedIcon
	*********************************************************************
	** Method: xfcIcon.ExtractAssociatedIcon
	**
	** Returns an icon representation of an image contained in the specified file.
	**
	** History:
	**  2006/12/15: CChalom: Coded
	*********************************************************************
	LPARAMETERS tcFilePath, tiIndex, liReturnedIndex
		
		*!ToDo: Test this function
		
		#DEFINE MAX_PATH 260
		
		LOCAL loExc AS Exception
		TRY
			m.tcFilePath = FULLPATH(m.tcFilePath) + REPLICATE(CHR(0), MAX_PATH - LENC(FULLPATH(m.tcFilePath)))
		
			LOCAL loIcon AS xfcIcon, lhIcon, lnTotalIcons
			m.lhIcon = 0
			m.loIcon = NULL
			m.tiIndex = EVL(m.tiIndex,0)
		
			m.TotIcons = xfcExtractIcon(0,m.tcFilePath,-1)
		
			m.lhIcon = xfcExtractAssociatedIcon(0, m.tcFilePath, @m.tiIndex)
		
			IF m.tiIndex < m.TotIcons
				m.loIcon = CREATEOBJECT("xfcIcon")
				m.loIcon.Handle = m.lhIcon
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION FromHandle
	*********************************************************************
	** Method: xfcIcon.FromHandle
	**
	** Creates a GDI+ Icon object from the specified Windows handle to an icon (HICON).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2008/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.FromHandle%28vs.80%29.aspx
	** Parameters:
	**  IntPtr handle
	** Returns: Icon
	*********************************************************************
	LPARAMETERS tHAndle AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loIcon, lhIcon
			m.lhIcon = 0
			m.loIcon = CREATEOBJECT(This.Class)
			m.loIcon.Handle = m.tHandle
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION Handle_ACCESS
	*********************************************************************
	** Property: Handle (Access)
	**
	** Gets the Windows handle for this Icon object. This is not a copy of the handle;
	** do not free it.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.Handle%28vs.80%29.aspx
	** Returns: IntPtr
	*********************************************************************
		RETURN This.Handle
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ACCESS
	*********************************************************************
	** Property: Height (Access)
	**
	** Gets the height of this Icon object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.Height%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liValue
		m.liValue = 0
		
		LOCAL loExc AS Exception
		TRY
			m.liValue = This.Size.Height
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION Save
	*********************************************************************
	** Method: xfcIcon.Save
	**
	** Saves this Icon object to the specified output Stream object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2007/09/06: CChalom Coded - Partial - missing tlQuality
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.Save%28vs.80%29.aspx
	** Parameters:
	**  Stream outputStream
	** Returns: void
	*********************************************************************
	LPARAMETERS toOutputStreamortcFile, tlQuality
	*********** tcFileName [, tlQuality]

	*!Todo: Allow users to work with high quality icons

		LOCAL lnFunctionType
		DO CASE 

		CASE VARTYPE(toOutputStreamortcFile) = "O"
			LOCAL loStream as xfcMemoryStream
			m.loStream = m.toOutputStreamortcFile
			m.lnFunctionType = 1 && Stream

		CASE VARTYPE(toOutputStreamortcFile) = "C"
			LOCAL lcDestFile
			m.lcDestFile = m.toOutputStreamortcFile
			m.lnFunctionType = 2 && Save to File

		ENDCASE
		
		LOCAL loExc AS Exception
		TRY

			LOCAL lhIcon
			m.lhIcon = This.Handle
		
				*!* typedef struct tagPICTDESC 
				*!* { 
				*!* UINT cbSizeofstruct; 
				*!* UINT picType; 
				*!* HICON hicon; 
				*!* } icon; 
				*!* struct 
				*!* { 
				*!* HENHMETAFILE hemf; 
				*!* } emf; 
				*!* } ; 
				*!* } PICTDESC
			   
			IF NOT m.tlQuality && Use Original .NET bad quality Icons (16 colors)

				#DEFINE PICTYPE_ICON 3
				#DEFINE IPERSISTSTREAM 	"{00000109-0000-0000-C000-000000000046}"
				#DEFINE GUID_IPicture 0h8109F87B32BF1A108BBB00AA00300CAB

				LOCAL lcPictDesc, lqGuid, loIconObj
				m.lcPictDesc = BINTOC(16,"4RS") + ; && Size of Structure
					BINTOC(PICTYPE_ICON, "4RS") + ; && Type of Image
					BINTOC(m.lhIcon, "4RS") + ; && Image Handle
					BINTOC(0, "4RS")

				*!* http://msdn2.microsoft.com/en-us/library/ms694511.aspx
				*!* STDAPI OleCreatePictureIndirect( 
				*!* PICTDESC* pPictDesc, //Pointer to the structure of parameters for picture
				*!* REFIID riid, //Reference to the identifier of the interface
				*!* BOOL fOwn, //Whether the picture is to be destroyed
				*!* If TRUE, the picture object is to destroy its picture when the object is destroyed. If FALSE, the caller is responsible for destroying the picture.
				*!* VOID** ppvObj //Address of output variable that receives the 
				*!* // interface pointer requested in riid


				LOCAL loGuid as xfcGuid
				m.loGuid = NEWOBJECT("xfcGuid", XFCCLASS_SYSTEM, "", IPictureGuid)
				m.lqGuid = loGuid.ToVarbinary()


				LOCAL loImg
				m.loImg = 0
				DECLARE LONG OleCreatePictureIndirect IN oleaut32 STRING @PictDesc , STRING @riid , LONG Own , OBJECT @Obj
				OleCreatePictureIndirect(@lcPictDesc, @lqGuid, 0, @loImg)


				DO CASE 
				CASE m.lnFunctionType = 1 && Stream
					LOCAL lcTempFile, lnSize
					m.lcTempFile = FORCEEXT(ADDBS(SYS(2023)) + SYS(2015), "ICO")
					SAVEPICTURE(m.loImg, m.lcTempFile)
					m.lcBinary = FILETOSTR(lcTempFile)
					CLEAR RESOURCES (m.lcTempFile)
					DELETE FILE (m.lcTempFile)
					lnSize = LEN(m.lcBinary)
					loStream.Capacity = lnSize
					loStream.Write(m.lcBinary,0,lnSize)

				CASE m.lnFunctionType = 2 && FileName
					SAVEPICTURE(m.loImg, m.lcDestFile)
			
				ENDCASE
			
			ENDIF
						
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Size_ACCESS
	*********************************************************************
	** Property: Size (Access)
	**
	** Gets the size of this Icon object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.Size%28vs.80%29.aspx
	** Returns: Size
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loSize AS xfcSize
		LOCAL lqIconInfo, lqBitmap, lhBMColor, lhBMMask, liWidth, liHeight
		m.loSize = NULL
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(This.Size) <> "O"
				m.lqIconInfo = EMPTY_ICONINFO
				m.lqBitmap = EMPTY_BITMAP
				m.liWidth = 0
				m.liHeight = 0
				
				xfcGetIconInfo(This.Handle, @lqIconInfo)
				
				m.lhBMMask = CTOBIN(SUBSTR(m.lqIconInfo, 13, 4 ), "4rs")
				m.lhBMColor = CTOBIN(SUBSTR(m.lqIconInfo, 17, 4 ), "4rs")
				IF m.lhBMColor != 0
					GetObject1(m.lhBMColor, LEN(m.lqBitmap), @lqBitmap)
					m.liWidth = CTOBIN(SUBSTR(m.lqBitmap, 5, 4), "4rs")
					m.liHeight = CTOBIN(SUBSTR(m.lqBitmap, 9, 4), "4rs")
					
					xfcDeleteObject(m.lhBMColor)
				ELSE
					IF m.lhBMMask != 0
						GetObject1(m.lhBMMask, LEN(m.lqBitmap), @lqBitmap)
						m.liWidth = CTOBIN(SUBSTR(m.lqBitmap, 5, 4), "4rs")
						m.liHeight = CTOBIN(SUBSTR(m.lqBitmap, 9, 4), "4rs")
					ENDIF
				ENDIF
				
				IF m.lhBMMask != 0
					xfcDeleteObject(m.lhBMMask)
				ENDIF
				
			** This.SetStatus(GdipSomeFunction???())
				This.Size = CREATEOBJECT("xfcSize", m.liWidth, m.liHeight)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.Size
	ENDFUNC


	*********************************************************************
	FUNCTION ToBitmap
	*********************************************************************
	** Method: xfcIcon.ToBitmap
	**
	** Converts this Icon object to a GDI+ Bitmap object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.ToBitmap%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: Bitmap
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loBitmap AS xfcBitmap
			m.loBitmap = CREATEOBJECT("xfcBitmap")
			m.loBitmap = m.loBitmap.FromHicon(This.Handle)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBitmap
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcIcon.ToString
	**
	** Gets a human-readable string that describes the Icon object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		*!*	ERROR 1999	&& Function not implemented
		RETURN "[Icon]"
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lcValue
			m.lcValue = ""
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lcValue
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ACCESS
	*********************************************************************
	** Property: Width (Access)
	**
	** Gets the width of this Icon object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Icon.Width%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liValue
		m.liValue = 0
		
		LOCAL loExc AS Exception
		TRY
			m.liValue = This.Size.Width
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liValue
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="fromhandle" type="method" display="FromHandle"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="save" type="method" display="Save"/>]+;
		[<memberdata name="tobitmap" type="method" display="ToBitmap"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="handle" type="property" display="Handle"/>]+;
		[<memberdata name="height" type="property" display="Height"/>]+;
		[<memberdata name="size" type="property" display="Size"/>]+;
		[<memberdata name="width" type="property" display="Width"/>]+;
		[<memberdata name="extractassociatedicon" type="method" display="ExtractAssociatedIcon"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************


*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCIMAGE
DEFINE CLASS xfcImage AS xfcgpobject
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Image"
	Flags = 0	&& Gets attribute flags for this Image object.
	HorizontalResolution = 0	&& Gets the horizontal resolution, in pixels-per-inch, of this Image object.
	lastresult = 0
	Palette = 0	&& Gets or sets the color palette used for this Image object.
	PhysicalDimension = 0	&& Gets the width and height of this image.
	PixelFormat = 0	&& Gets the pixel format for this Image object.
	RawFormat = 0	&& Gets the format of this Image object.
	Size = 0	&& Gets the width and height, in pixels, of this image.
	streamptr = 0
	VerticalResolution = 0	&& Gets the vertical resolution, in pixels-per-inch, of this Image object.
	Width = 0
	Height = 0

	PROTECTED _oStream
	_oStream = NULL && Stores the MemoryStream Object used for the method "FromVarBinary"
	
	DIMENSION FrameDimensionsList[1]
	** Gets an array of GUIDs that represent the dimensions of frames within this Image object.

	DIMENSION PropertyIdList[1]

	PropertyItems = NULL	&& Gets all the property items (pieces of metadata) stored in this Image object.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcImage.Image
	**
	** An abstract base class that provides functionality for the Bitmap and Metafile descended
	** classes.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image%28vs.80%29.aspx
	** Parameters:
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcImage.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This.Handle <> 0
				This.SetStatus(xfcGdipDisposeImage(This.Handle))
				This.Handle = 0
			ENDIF
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
		
		RETURN CREATEOBJECT(This.Class)
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcImage.Clone
	**
	** Creates an exact copy of this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.Clone%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: object
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loobject, lhobject
			m.lhobject = 0
			m.loobject = NULL
			This.SetStatus(xfcGdipCloneImage(This.Handle, @lhobject))
				IF(m.lhobject <> 0)
					m.loobject = CREATEOBJECT(This.Class)
					m.loobject.Handle = m.lhobject
				ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loobject
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Flags_ACCESS
	*********************************************************************
	** Property: Flags (Access)
	**
	** Gets attribute flags for this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.Flags%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liValue
		m.liValue = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetImageFlags(This.Handle, @liValue))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION FrameDimensionsList_ACCESS
	*********************************************************************
	** Property: FrameDimensionsList (Access)
	**
	** Gets an array of GUIDs that represent the dimensions of frames within this Image
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/15: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.FrameDimensionsList%28vs.80%29.aspx
	** Returns: Guid[]
	*********************************************************************
	LPARAMETERS tiIndex
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liCount, lqBinary, loGuid
			m.liCount = 0
			m.tiIndex = EVL(m.tiIndex, 1)
			m.loGuid = NULL
			This.SetStatus(xfcGdipImageGetFrameDimensionsCount(This.Handle, @liCount))
			IF m.liCount = 0
				DIMENSION This.FrameDimensionsList[1]
				This.FrameDimensionsList = NULL
			ELSE
				IF m.tiIndex <= m.liCount
					DIMENSION This.FrameDimensionsList[m.liCount]
					m.lqBinary = REPLICATE(EMPTY_GUID, m.liCount)
					This.SetStatus(xfcGdipImageGetFrameDimensionsList(This.Handle, @lqBinary, m.liCount))
					m.loGuid = NEWOBJECT("xfcGuid", XFCCLASS_SYSTEM, "", SUBSTR(m.lqBinary, (m.tiIndex-1)*LEN(EMPTY_GUID)+1, LEN(EMPTY_GUID)))
				ENDIF
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loGuid
	ENDFUNC


	*********************************************************************
	FUNCTION FromFile
	*********************************************************************
	** Method: xfcImage.FromFile
	**
	** Creates an Image object from the specified file.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**  2006/12/09: CChalom - Fixed CreateNew(This.Class)
	**	2007/08/31: BDurban - Added support for embedded reource files
	**  2013/03/10: Daveaswj - http://vfpx.codeplex.com/workitem/30616
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.FromFile%28vs.80%29.aspx
	** Parameters:
	**  string filename
	**  string filename, bool useEmbeddedColorManagement
	** Returns: Image
	*********************************************************************
	LPARAMETERS tcFilename, ;
				tlUseEmbeddedColorManagement
		
		*!ToDo: Test this function
		LOCAL loImage, lhImage, loStream AS xfcMemoryStream
		m.lhImage = 0
		m.loImage = NULL
		
		LOCAL loExc AS Exception
		TRY

			m.tcFileName = FULLPATH(m.tcFileName)

			** [workitem:10185]
			** If this is an embedded resource, we need load from stream
			IF FILE(m.tcFileName) AND EMPTY(SYS(2000,m.tcFileName))
				** File is an embedded resource
				m.loStream = NEWOBJECT("xfcMemoryStream", XFCCLASS_IO, "", FILETOSTR(m.tcFileName), .T.)
				* m.loImage = This.FromStream(m.loStream, m.tlUseEmbeddedColorManagement)
				This._oStream = m.loStream
				m.loImage = This.FromStream(m.loStream.Handle, m.tlUseEmbeddedColorManagement)

				EXIT
			ENDIF
			
			IF m.tlUseEmbeddedColorManagement
				This.SetStatus(xfcGdipLoadImageFromFileICM(STRCONV(m.tcFilename+0h00,5), @lhImage))
			ELSE
				This.SetStatus(xfcGdipLoadImageFromFile(STRCONV(m.tcFilename+0h00,5), @lhImage))
			ENDIF
			IF m.lhImage <> 0
				m.loImage = CREATEOBJECT(This.Class)
				m.loImage.Handle = m.lhImage
			ENDIF
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loImage
	ENDFUNC


	*********************************************************************
	FUNCTION FromHbitmap
	*********************************************************************
	** Method: xfcImage.FromHbitmap
	**
	** Creates a Bitmap object from a Windows handle.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/07/15: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.FromHbitmap%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hbitmap
	**  IntPtr hbitmap, IntPtr hpalette
	** Returns: Bitmap
	*********************************************************************
	LPARAMETERS tHBitmap AS IntPtr, ;
					tHPalette AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loBitmap AS xfcBitmap, lhBitmap
			m.lhBitmap = 0
			m.loBitmap = NULL
			m.tHPalette = EVL(m.tHPalette,0)
			This.SetStatus(xfcGdipCreateBitmapFromHBITMAP(m.tHBitmap, m.tHPalette, @lhBitmap))
			IF(m.lhBitmap <> 0)
				m.loBitmap = CREATEOBJECT("xfcBitmap")
				m.loBitmap.Handle = m.lhBitmap
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBitmap
	ENDFUNC


	*********************************************************************
	FUNCTION FromStream
	*********************************************************************
	** Method: xfcImage.FromStream
	**
	** Creates an Image object from the specified data stream.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2007/04/15: CChalom - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.FromStream%28vs.80%29.aspx
	** Parameters:
	**  Stream stream
	**  Stream stream, bool useEmbeddedColorManagement
	** Returns: Image
	*********************************************************************
	LPARAMETERS toStream AS xfcStream, ;
				tlUseEmbeddedColorManagement
	*********** toStream AS xfcStream [, tlUseEmbeddedColorManagement]
	*********** toStream AS LongPtr [, tlUseEmbeddedColorManagement]

		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loImage, lhImage, lhStream, loStream AS xfcStream
			m.lhImage = 0
			m.loImage = NULL
		
			DO CASE 
			CASE VARTYPE(m.toStream) == "O"
				m.lhStream = m.toStream.Handle
			CASE VARTYPE(m.toStream) == "N"
				m.lhStream = m.toStream
			ENDCASE
			
			IF m.tlUseEmbeddedColorManagement
				This.SetStatus(xfcGdipLoadImageFromStreamICM(m.lhStream, @lhImage))
			ELSE
				This.SetStatus(xfcGdipLoadImageFromStream(m.lhStream, @lhImage))
			ENDIF
		
			IF m.lhImage <> 0
				m.loImage = CREATEOBJECT(This.Class)
				m.loImage.Handle = m.lhImage
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loImage
	ENDFUNC


	*********************************************************************
	FUNCTION FromVarBinary
	*********************************************************************
	** Method: xfcImage.FromVarBinary
	**
	** Creates an Image object from the specified VarBinary string.
	**
	** History:
	**  2007/09/02: BDurban - Coded
	**  2007/11/24: CAlloatti / CChalom - Added _oStream Property to store the temp Stream during the existance of this Image object
	**
	** Returns: Image
	*********************************************************************
	LPARAMETERS tqBinary, ;
				tlUseEmbeddedColorManagement

		LOCAL loStream AS xfcMemoryStream
		LOCAL loExc AS Exception
		TRY
			m.loStream = NEWOBJECT("xfcMemoryStream", XFCCLASS_IO, "", m.tqBinary, .T.)
			This._oStream = m.loSTream
			m.loImage = This.FromStream(m.loStream.Handle, m.tlUseEmbeddedColorManagement)

		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loImage
	
	ENDFUNC
	

	*********************************************************************
	FUNCTION GetBounds
	*********************************************************************
	** Method: xfcImage.GetBounds
	**
	** Gets a bounding rectangle in the specified units for this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.GetBounds%28vs.80%29.aspx
	** Parameters:
	**  ref GraphicsUnit pageUnit
	** Returns: RectangleF
	*********************************************************************
	LPARAMETERS tiPageUnit AS @EnumGraphicsUnit
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRectangleF, lcStruct
			m.loRectangleF = NULL
			lcStruct = EMPTY_RECTANGLEF
			This.SetStatus(xfcGdipGetImageBounds(This.Handle, @lcStruct, @tiPageUnit))
			m.loRectangleF = CREATEOBJECT("xfcRectangleF", m.lcStruct)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRectangleF
	ENDFUNC


	*********************************************************************
	FUNCTION GetEncoderParameterList
	*********************************************************************
	** Method: xfcImage.GetEncoderParameterList
	**
	** Returns information about the parameters supported by the specified image encoder.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/07/15: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.GetEncoderParameterList%28vs.80%29.aspx
	** Parameters:
	**  Guid encoder
	** Returns: EncoderParameters
	*********************************************************************
	LPARAMETERS toEncoder AS xfcGuid
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loParams AS xfcEncoderParameters
			LOCAL loParam AS xfcEncoderParameter
			LOCAL liSize, lcClsidEncoder, lhBuffer, liCount, liPos, liLength, liType, lhValue
			
			m.liSize = 0
			m.lcClsidEncoder = m.toEncoder.Guid.ToByteArray()
			m.loParams = NULL
			
			This.SetStatus(xfcGdipGetEncoderParameterListSize(This.Handle, @lcClsidEncoder, @liSize))
			IF m.liSize <= 0
				EXIT
			ELSE
				m.lhBuffer = xfcLocalAlloc(0x0040,m.liSize)
				IF This.SetStatus(xfcGdipGetEncoderParameterList(This.Handle, @lcClsidEncoder, m.liSize, lhBuffer)) = 0
					m.loParams = NEWOBJECT("xfcEncoderParameters", XFCCLASS_IMAGING, "", m.lhBuffer, .T.)
				ENDIF
				xfcLocalFree(m.lhBuffer)
			ENDIF	
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loParams
	ENDFUNC


	*********************************************************************
	FUNCTION GetFrameCount
	*********************************************************************
	** Method: xfcImage.GetFrameCount
	**
	** Returns the number of frames of the specified dimension.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/05/09: CBoyd - Coded
	**	2006/05/15: BDurban - Added code to make toDimension parameter optional
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.GetFrameCount%28vs.80%29.aspx
	** Parameters:
	**  FrameDimension dimension
	** Returns: int
	*********************************************************************
	LPARAMETERS toDimension AS xfcFrameDimension
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lnCount
			m.lnCount = 0
			m.toDimension = IIF(VARTYPE(m.toDimension)="O", m.toDimension, This.FrameDimensionsList[1])
			IF NOT ISNULL(m.toDimension)
				This.SetStatus(xfcGdipImageGetFrameCount(This.Handle, toDimension.ToVarBinary(), @lnCount))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lnCount
	ENDFUNC


	*********************************************************************
	FUNCTION GetMonochrome
	*********************************************************************
	** Method: xfcImage.GetMonochrome
	**
	** Returns a monochrome bitmap (1bpp) of this Image object.
	**
	** Remarks:
	**
	** History:
	**	2006/08/22: CChalom - Coded as PRG
	**  2006/08/22: BDurban - Converted to method code
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loBmp AS xfcBitmap
		LOCAL hBitmap, hReturnBmp
		
		LOCAL loExc AS Exception
		TRY
			#DEFINE image_bitmap        0
			#DEFINE dst_bitmap          0x0004
			#DEFINE lr_defaultcolor     0x0000
			#DEFINE lr_monochrome       0x0001
			#DEFINE lr_color            0x0002
			#DEFINE lr_copyreturnorg    0x0004
			#DEFINE lr_copydeleteorg    0x0008
			#DEFINE lr_loadfromfile     0x0010
			#DEFINE lr_loadtransparent  0x0020
			#DEFINE lr_defaultsize      0x0040
			#DEFINE lr_vgacolor         0x0080
			#DEFINE lr_loadmap3dcolors  0x1000
			#DEFINE lr_createdibsection 0x2000
			#DEFINE lr_copyfromresource 0x4000
			#DEFINE lr_shared           0x8000
		
			* Load the temp image as Monochrome
		
			m.hReturnBmp = 0
			m.loBmp = NULL
		
			IF This.SetStatus(xfcGdipCreateHBITMAPFromBitmap(This.Handle, @m.hReturnBmp, 0xFFFFFFFF)) = StatusOk
				m.hBitmap = xfcCopyImage(m.hReturnBmp, 0, 0, 0, lr_monochrome)
				xfcDeleteObject(m.hReturnBmp)
		
				IF m.hBitmap <> 0 && If the function CopyImage fails, the return value is NULL. To get extended error information, call GetLastError.
					* Load the just converted image to Gdi+
					m.loBmp = CREATEOBJECT("xfcBitmap")
					m.loBmp = m.loBmp.FromHBitmap(m.hBitmap)
					* We are responsible for calling the GDIDeleteObject method to free the memory used by the GDI bitmap object.
				    xfcDeleteObject(m.hBitmap)
				ENDIF
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBmp
		
		
		*!* The COPYIMAGE function creates a new image (icon, cursor, or bitmap)
		*!* and copies the attributes of the specified image to the new one.
		*!* If necessary, the function stretches the bits to fit the desired size of the new image.
		*!* COPYIMAGE Function Reference
		*!* http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/resources/introductiontoresources/resourcereference/resourcefunctions/copyimage.asp
		
		*!*	HANDLE xfcCopyImage(          HANDLE hImage,
		*!*	    UINT uType,
		*!*	    int cxDesired,
		*!*	    int cyDesired,
		*!*	    UINT fuFlags
		*!*	);
		
		*!*	Parameters
		
		*!*	hImage		[in] Handle to the image to be copied.
		*!*	uType		[in] Specifies the type of image to be copied. This parameter can be one of the following values.
		*!*						IMAGE_BITMAP  Copies a bitmap.
		*!*						IMAGE_CURSOR  Copies a cursor.
		*!*						IMAGE_ICON    Copies an icon.
		*!*	cxDesired	[in] Specifies the desired width, in pixels, of the image. If zero, then the returned image will have the same width as the original hImage.
		*!*	cyDesired	[in] Specifies the desired height, in pixels, of the image. If this is zero, then the returned image will have the same height as the original hImage.
		*!*	fuFlags		[in] This parameter can be one or more of the following values.
		*!*					LR_COPYDELETEORG     Deletes the original image after creating the copy.
		*!*					LR_COPYFROMRESOURCE  Tries to reload an icon or cursor resource from the original resource file rather than simply copying the current image. This is useful for creating a different-sized copy when the resource file contains multiple sizes of the resource. Without this flag, CopyImage stretches the original image to the new size. If this flag is set, CopyImage uses the size in the resource file closest to the desired size. This will succeed only if hImage was loaded by LoadIcon or LoadCursor, or by LoadImage with the LR_SHARED flag.
		*!*					LR_COPYRETURNORG     Returns original hImage if it satisfies the criteria for the copythat is, correct dimensions and color depthin which case the LR_COPYDELETEORG flag is ignored. If this flag is not specified, a new object is always created.
		*!*					LR_CREATEDIBSECTION  If this is set and a new bitmap is created, the bitmap is created as a device-independent bitmap (DIB) section. Otherwise, the bitmap image is created as a device-dependent bitmap. This flag is only valid if uType is IMAGE_BITMAP.
		*!*					LR_MONOCHROME        Creates a new monochrome image.
	ENDFUNC


	*********************************************************************
	FUNCTION GetPictureVal
	*********************************************************************
	** Method: xfcImage.GetPictureVal
	**
	** Returns a String containing the PictureVal of this Image object
	**
	** Remarks:
	**
	** History:
	**	2007/04/15: CChalom - Coded
	*********************************************************************
		
	LPARAMETERS toEncoder AS xfcImageCodecInfo, toEncoderParams AS xfcEncoderParameters
		
		*!*	*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL lqClsidEncoder, lhEncoderParams
		
			IF VARTYPE(m.toEncoder) + VARTYPE(m.toEncoderParams) == "QN" && CLSID ENcoder and EncoderParams - no need more parameter checking
		
				lqClsidEncoder = m.toEncoder
				lhEncoderParams = m.toEncoderParams
		
			ELSE
				m.toEncoder = This._GetCodec(m.toEncoder)

				LOCAL loImage AS Image
				lqClsidEncoder = EMPTY_GUID
				lhEncoderParams = 0
			
				IF PCOUNT() = 0		&& No ImageFormat or ImageCodecInfo specified
				** Use RawFormat as default
					m.toEncoder = This.RawFormat
				ENDIF
			
				IF VARTYPE(m.toEncoder) = "O" AND m.toEncoder.BaseName = "ImageCodecInfo"
					lqClsidEncoder = m.toEncoder.Clsid.ToByteArray()
				ENDIF
			
				IF VARTYPE(m.toEncoderParams) = "O" AND m.toEncoderParams.BaseName = "EncoderParameters"
					lhEncoderParams = toEncoderParams.ToMemoryHandle()
				ENDIF	
			
			ENDIF
			
			LOCAL lqBinary
			LOCAL loStream as xfcMemoryStream
			m.loStream = NEWOBJECT("xfcMemoryStream", XFCCLASS_IO)
			This.SetStatus(xfcGdipSaveImageToStream_I(This.Handle, m.loStream.Handle, @lqClsidEncoder, lhEncoderParams))
			m.lqBinary = loStream.Getbuffer()
			loStream.Dispose()
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lqBinary
	ENDFUNC


	*********************************************************************
	FUNCTION GetPictureValfromHBitmap
	*********************************************************************
	** Method: xfcImage.GetPictureVal
	**
	** Returns a String containing the PictureVal of this Image object using the HBitmap GDI technique
	**
	** Remarks:
	**
	** History:
	**	2007/04/15: CChalom - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		#DEFINE RGBQUAD_SIZE     4
		#DEFINE DIB_RGB_COLORS   0
		#DEFINE BFHDR_SIZE      14
		#DEFINE BHDR_SIZE       40
		* #DEFINE GMEM_FIXED     0
		* #DEFINE BI_RGB         0
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL lhBitmap, lnWidth, lnHeight, lnBitsPerPixel
		
			LOCAL loBackground as xfcColor
			m.lhBitmap = 0
			This.SetStatus(xfcGdipCreateHBITMAPFromBitmap(This.Handle, @lhBitmap, ARGB_LightGray))
		
			m.lnWidth  = This.Width
			m.lnHeight = This.Height
			m.lnBitsPerPixel = This.GetPixelFormatSize(This.PixelFormat)
		
			LOCAL lnBytesPerScan, lnBitsSize, lnRgbQuadSize
			STORE 0 TO m.lnBytesPerScan, m.lnBitsSize, m.lnRgbQuadSize
		
			m.lnBytesPerScan = INT((m.lnWidth * m.lnBitsPerPixel)/8)
			IF MOD(m.lnBytesPerScan, 4) # 0
				m.lnBytesPerScan = m.lnBytesPerScan + 4 - MOD(m.lnBytesPerScan, 4)
			ENDIF
		
			LOCAL lcBIHdr, lcRgbQuad, lcBInfo
			LOCAL lpBitsArray
		
			m.lcBIHdr = BINTOC(BHDR_SIZE ,"4RS") + BINTOC(m.lnWidth,"4RS") + BINTOC(m.lnHeight, "4RS") + ;
				(CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(m.lnBitsPerPixel,256))+ CHR(INT(m.lnBitsPerPixel/256))) +;
				BINTOC(BI_RGB, "4RS") + REPLI(0h00, 20)
		
			IF m.lnBitsPerPixel <= 8
				m.lnRgbQuadSize = (2^m.lnBitsPerPixel) * RGBQUAD_SIZE
				m.lcRgbQuad = REPLI(CHR(0), m.lnRgbQuadSize)
			ELSE
				m.lcRgbQuad = ""
			ENDIF
			m.lcBInfo = m.lcBIHdr + m.lcRgbQuad
			m.lnBitsSize = m.lnHeight * m.lnBytesPerScan
			m.lpBitsArray = xfcGlobalAlloc (GMEM_FIXED, m.lnBitsSize)
			= ZeroMemory (m.lpBitsArray, m.lnBitsSize)
		
			LOCAL hdc, hMemDC, lnFileSize, lnOffBits, m.lcBFileHdr
			m.lhDC = xfcGetWindowDC(_SCREEN.HWnd)
			m.lhMemDC = xfcCreateCompatibleDC (m.lhDC)
			=xfcReleaseDC(_SCREEN.HWnd, m.lhDC)
			=xfcGetDIBits (m.lhMemDC, m.lhBitmap, 0, m.lnHeight, m.lpBitsArray, @lcBInfo, DIB_RGB_COLORS)
		
			m.lnFileSize = BFHDR_SIZE + BHDR_SIZE + m.lnRgbQuadSize + m.lnBitsSize
			m.lnOffBits  = BFHDR_SIZE + BHDR_SIZE + m.lnRgbQuadSize
			m.lcBFileHdr = "BM" + BINTOC(m.lnFileSize, "4RS") + BINTOC(0, "4RS") + BINTOC(m.lnOffBits, "4RS")
		
			LOCAL lqBinary
			m.lqBinary = m.lcBFileHdr + m.lcBInfo + SYS(2600, m.lpBitsArray, m.lnBitsSize)
		
			=xfcGlobalFree(m.lpBitsArray)
			=xfcDeleteDC(m.lhMemDC)
			=xfcDeleteObject(m.lhBitmap)
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lqBinary
	ENDFUNC




	*********************************************************************
	FUNCTION GetPixelFormatSize
	*********************************************************************
	** Method: xfcImage.GetPixelFormatSize
	**
	** Returns the color depth (number of bits per pixel) of the specified pixel format.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/23: BDurban - Coded
	**  2007/04/13: CChalom - Fixed
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.GetPixelFormatSize%28vs.80%29.aspx
	** Parameters:
	**  PixelFormat pixfmt
	** Returns: int
	*********************************************************************
	LPARAMETERS tiPixfmt AS EnumPixelFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = BITAND(BITRSHIFT(tiPixFmt,8),0xff)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetPropertyItem
	*********************************************************************
	** Method: xfcImage.GetPropertyItem
	**
	** Gets the specified property item from this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/18: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.GetPropertyItem%28vs.80%29.aspx
	** Parameters:
	**  int propid
	** Returns: PropertyItem
	*********************************************************************
	LPARAMETERS tiPropid
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loPropertyItem AS xfcPropertyItem
			LOCAL liSize, lhMem
			m.loPropertyItem = NEWOBJECT("xfcPropertyItem",XFCCLASS_IMAGING)
			m.liSize = 0
			m.lhMem = 0
			This.SetStatus(xfcGdipGetPropertyItemSize(This.Handle, m.tiPropid, @liSize))
			m.lhMem = xfcGlobalAlloc(GMEM_FIXED, liSize)
			IF This.SetStatus(xfcGdipGetPropertyItem(This.Handle, m.tiPropid, m.liSize, lhMem)) = 0
				m.loPropertyItem = m.loPropertyItem.FromMemPtr(m.lhMem)
			ENDIF
			xfcGlobalFree(m.lhMem)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loPropertyItem
	ENDFUNC


	*********************************************************************
	FUNCTION GetThumbnailImage
	*********************************************************************
	** Method: xfcImage.GetThumbnailImage
	**
	** Returns a thumbnail for this Image object.
	**
	** History:
	** 2006/03/07: Auto Generated
	** 2006/03/08: BDurban - Coded
	** 2006/08/24: CChalom - Fixed some variable names
	**                     - thCallback and tiCallbackData DEFAULTs to ZERO instead of NULL
	** 2006/08/24: CChalom - Tested
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.GetThumbnailImage%28vs.80%29.aspx
	** Parameters:
	** int thumbWidth, int thumbHeight, Image.GetThumbnailImageAbort callback, IntPtr callbackData
	** Returns: Image
	*********************************************************************
	LPARAMETERS tiThumbWidth, tiThumbHeight, ;
					thCallback AS FuncPtr, tiCallbackData AS IntPtr
		
		LOCAL loThumbImage, lhThumbImage
		m.lhThumbImage = 0
		m.loThumbImage = NULL
		
		LOCAL loExc AS Exception
		
		TRY
		   m.thCallback = EVL(NVL(m.thCallback,0),0)
		   m.tiCallbackData = EVL(NVL(tiCallbackData,0),0)
		   This.SetStatus(xfcGdipGetImageThumbnail(This.Handle, m.tiThumbWidth, m.tiThumbHeight, @lhThumbImage, m.thCallback, m.tiCallbackData))
		   IF(m.lhThumbImage <> 0)
		      m.loThumbImage = CREATEOBJECT("xfcImage")
		      m.loThumbImage.Handle = m.lhThumbImage
		   ENDIF
		CATCH TO loExc
		   THROW_EXCEPTION
		ENDTRY
		RETURN m.loThumbImage
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Height_ACCESS
	*********************************************************************
	** Property: Height (Access)
	**
	** Gets the height of this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.Height%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		LOCAL liValue
		m.liValue = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetImageHeight(This.Handle, @liValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION HorizontalResolution_ACCESS
	*********************************************************************
	** Property: HorizontalResolution (Access)
	**
	** Gets the horizontal resolution, in pixels-per-inch, of this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.HorizontalResolution%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetImageHorizontalResolution(This.Handle, @lnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsAlphaPixelFormat
	*********************************************************************
	** Method: xfcImage.IsAlphaPixelFormat
	**
	** Returns a value that indicates whether the pixel format for this Image object contains
	** alpha information.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/23: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.IsAlphaPixelFormat%28vs.80%29.aspx
	** Parameters:
	**  PixelFormat pixfmt
	** Returns: bool
	*********************************************************************
	LPARAMETERS tiPixfmt AS EnumPixelFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue
			m.llValue = (BITAND(m.tiPixfmt, 0x00040000) = 0x00040000)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsCanonicalPixelFormat
	*********************************************************************
	** Method: xfcImage.IsCanonicalPixelFormat
	**
	** Returns a value that indicates whether the pixel format is canonical.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/23: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.IsCanonicalPixelFormat%28vs.80%29.aspx
	** Parameters:
	**  PixelFormat pixfmt
	** Returns: bool
	*********************************************************************
	LPARAMETERS tiPixfmt AS EnumPixelFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue
			m.llValue = (BITAND(m.tiPixfmt, 0x00200000) = 0x00200000)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsExtendedPixelFormat
	*********************************************************************
	** Method: xfcImage.IsExtendedPixelFormat
	**
	** Returns a value that indicates whether the pixel format is extended.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/23: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.IsExtendedPixelFormat%28vs.80%29.aspx
	** Parameters:
	**  PixelFormat pixfmt
	** Returns: bool
	*********************************************************************
	LPARAMETERS tiPixfmt AS EnumPixelFormat
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue
			m.llValue = (BITAND(m.tiPixfmt, 0x4000) = 0x4000)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Palette_ACCESS
	*********************************************************************
	** Property: Palette (Access)
	**
	** Gets or sets the color palette used for this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/06/28: CChalom - Coded Updated and tested
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.Palette%28vs.80%29.aspx
	** Returns: ColorPalette
	*********************************************************************
		*!ToDo: Test this function
		LOCAL loColorPalette, lnSize, lqBuffer
		m.loColorPalette = NULL
		LOCAL loExc AS Exception
		TRY
			m.lnSize = 0
			This.SetStatus(xfcGdipGetImagePaletteSize(This.Handle, @lnSize))
			m.lqBuffer = REPLICATE(0h00, lnSize)
			This.SetStatus(xfcGdipGetImagePalette(This.Handle, @lqBuffer, lnSize))
			m.loColorPalette = NEWOBJECT("xfcColorPalette", XFCCLASS_IMAGING, "", m.lqBuffer)
		CATCH TO loExc
		   THROW_EXCEPTION
		ENDTRY
		RETURN m.loColorPalette
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Palette_ASSIGN
	*********************************************************************
	** Property: Palette (Assign)
	**
	** Gets or sets the color palette used for this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/07/12: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toColorPalette AS xfcColorPalette
		*!ToDo: Test this function
		LOCAL lqPalette
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(m.toColorPalette) = "O"
				m.lqPalette = m.toColorPalette.ToVarBinary()
				This.SetStatus(xfcGdipSetImagePalette(This.Handle, @lqPalette))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION PhysicalDimension_ACCESS
	*********************************************************************
	** Property: PhysicalDimension (Access)
	**
	** Gets the width and height of this image.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/12: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.PhysicalDimension%28vs.80%29.aspx
	** Returns: SizeF
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loSizeF
		m.loSizeF = NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lnWidth, lnHeight
			m.lnWidth = 0
			m.lnHeight = 0
			This.SetStatus(xfcGdipGetImageDimension(This.Handle, @lnWidth, @lnHeight))
			m.loSizeF = CREATEOBJECT("xfcSizeF", m.lnWidth, m.lnHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loSizeF
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION PixelFormat_ACCESS
	*********************************************************************
	** Property: PixelFormat (Access)
	**
	** Gets the pixel format for this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.PixelFormat%28vs.80%29.aspx
	** Returns: PixelFormat
	*********************************************************************
		LOCAL liPixelFormat
		m.liPixelFormat = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetImagePixelFormat(This.Handle, @liPixelFormat))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liPixelFormat
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION PropertyIdList_ACCESS
	*********************************************************************
	** Property: PropertyIdList (Access)
	**
	** Gets IDs of the property items stored in this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/18: BDurban - Needs more work
	**	2006/05/15: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.PropertyIdList%28vs.80%29.aspx
	** Returns: int[]
	*********************************************************************
	LPARAMETERS tnIndex
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liPropCnt, lqBuffer, liValue
			m.liValue = NULL
			m.liPropCnt = 0
			m.tnIndex = EVL(m.tnIndex,1)
			This.SetStatus(xfcGdipGetPropertyCount(This.Handle, @liPropCnt))
			IF m.liPropCnt > 0
				IF m.tnIndex <= m.liPropCnt
					m.lqBuffer = REPLICATE(0h00000000, m.liPropCnt)
					This.SetStatus(xfcGdipGetPropertyIdList(This.Handle, m.liPropCnt, @lqBuffer))
					DIMENSION This.PropertyIdList[liPropCnt]
				ENDIF
				
				liValue = CTOBIN(SUBSTR(lqBuffer,(tnIndex-1)*4+1,4),"4rs")
			ELSE
				DIMENSION This.PropertyIdList[1]
				This.PropertyIdList = NULL
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN liValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION PropertyItems_ACCESS
	*********************************************************************
	** Property: PropertyItems (Access)
	**
	** Gets all the property items (pieces of metadata) stored in this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2007/09/01: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.PropertyItems%28vs.80%29.aspx
	** Returns: PropertyItem[]
	*********************************************************************
		*!ToDo: Test this function
		LOCAL liPropCnt, loColl AS Collection, lnPropID, loProp
		
		LOCAL loExc AS Exception
		TRY
			m.liPropCnt = 0
			This.SetStatus(xfcGdipGetPropertyCount(This.Handle, @liPropCnt))
			IF VARTYPE(This.PropertyItems) <> "O" OR This.PropertyItems.Count <> m.liPropCnt
				m.loColl = CREATEOBJECT("Collection")
				m.lnPropID = This.PropertyIDList[1]	&& Initialize array
				IF VARTYPE(m.lnPropID) == "N" && a NULL is returned when no properties are found
					FOR EACH m.lnPropID IN This.PropertyIdList
						m.loProp = This.GetPropertyItem(m.lnPropID)
						m.loColl.Add(m.loProp, ALLTRIM(STR(m.lnPropID)))
					ENDFOR
				ENDIF
				This.PropertyItems = m.loColl
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.PropertyItems
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION RawFormat_ACCESS
	*********************************************************************
	** Property: RawFormat (Access)
	**
	** Gets the format of this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/04/23: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.RawFormat%28vs.80%29.aspx
	** Returns: ImageFormat
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lcFormat
		m.lcFormat = 0h00000000000000000000000000000000
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetImageRawFormat(This.Handle, @lcFormat))
			m.loImageFormat = NEWOBJECT("xfcImageFormat", XFCCLASS_IMAGING, "", lcFormat)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loImageFormat
	ENDFUNC


	*********************************************************************
	FUNCTION RemovePropertyItem
	*********************************************************************
	** Method: xfcImage.RemovePropertyItem
	**
	** Removes the specified property item from this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.RemovePropertyItem%28vs.80%29.aspx
	** Parameters:
	**  int propid
	** Returns: void
	*********************************************************************
	LPARAMETERS tiPropid
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipRemovePropertyItem(This.Handle, m.tiPropid))
			This.PropertyItems = NULL
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION RotateFlip
	*********************************************************************
	** Method: xfcImage.RotateFlip
	**
	** This method either rotates, flips, or rotates and flips the Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.RotateFlip%28vs.80%29.aspx
	** Parameters:
	**  RotateFlipType rotateFlipType
	** Returns: void
	*********************************************************************
	LPARAMETERS tiRotateFlipType AS EnumRotateFlipType
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipImageRotateFlip(This.Handle, m.tiRotateFlipType))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC

	*********************************************************************
	PROTECTED FUNCTION _GetCodec
	*********************************************************************
	LPARAMETERS m.toEncoder
		
		LOCAL loFormat AS xfcImageFormat
		LOCAL lcMime
		
		TRY 
		** MIME format was specified
			IF VARTYPE(m.toEncoder) = "C"
				m.lcMime = m.toEncoder
				m.toEncoder = NEWOBJECT("xfcImageFormat", XFCCLASS_IMAGING, "", m.lcMime)
			ENDIF
			
			DO CASE
		** ImageFormat was specified
			CASE VARTYPE(m.toEncoder) = "O" AND m.toEncoder.BaseName = "ImageFormat"
				m.loFormat = m.toEncoder
				m.toEncoder = m.loFormat.FindEncoder()
				IF ISNULL(m.toEncoder)
					m.loFormat = NEWOBJECT("xfcImageFormat", XFCCLASS_IMAGING)
					m.toEncoder = m.loFormat.Png.FindEncoder()
				ENDIF
				
		** ImageCodecInfo was specified
			CASE VARTYPE(m.toEncoder) = "O" AND m.toEncoder.BaseName = "ImageCodecInfo"
			ENDCASE
		CATCH
		ENDTRY

		RETURN m.toEncoder
	
	ENDFUNC
	
	*********************************************************************
	FUNCTION Save
	*********************************************************************
	** Method: xfcImage.Save
	**
	** Saves this image to the specified stream in the specified format.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/10: BDurban - Coded, partial
	**	2006/06/11: BDurban - Added support for ImageCodecInfo and EncoderParameters
	**  2006/07/19: BDurban - Added call to FindEncoder
	**  2006/08/16: BDurban - Added default value for 2nd parameter
	**  2006/08/23: BDurban/CChalom - Modified ImageFormat parameter to use PNG if Encoder could not be found
	**  2007/03/15: CChalom - Allow to receive a handle as the 1st parameter to use Streams
	**  2007/04/15: CChalom - Allow to receive new stream class as parameter, modified Save to Image object to use streams
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.Save%28vs.80%29.aspx
	** Parameters:
	**  string filename
	**  Stream stream, ImageFormat format
	**  string filename, ImageFormat format
	**  Stream stream, ImageCodecInfo encoder, EncoderParameters encoderParams
	**  string filename, ImageCodecInfo encoder, EncoderParameters encoderParams
	** Returns: void
	*********************************************************************
	LPARAMETERS tcFilename ;
					, toEncoder AS xfcImageCodecInfo, toEncoderParams AS xfcEncoderParameters
	*********** tcFilename, toFormat AS xfcImageFormat
	*********** toStream AS xfcMemoryStream, toEncoder AS xfcImageCodecInfo, toEncoderParams AS xfcEncoderParameters
	*********** toStream AS xfcMemoryStream, toFormat AS xfcImageFormat
	*********** toImage AS Image [, toFormat AS xfcImageFormat]
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			LOCAL lqClsidEncoder, lhEncoderParamsm
			LOCAL loImage AS Image
			m.lqClsidEncoder = EMPTY_GUID
			m.lhEncoderParams = 0
			
			
			IF PCOUNT() = 1		&& No ImageFormat or ImageCodecInfo specified
			** Use RawFormat as default
				m.toEncoder = This.RawFormat
			ENDIF
			
			m.toEncoder = This._GetCodec(m.toEncoder)
			
			IF VARTYPE(m.toEncoder) = "O" AND m.toEncoder.BaseName = "ImageCodecInfo"
				lqClsidEncoder = m.toEncoder.Clsid.ToByteArray()
			ENDIF
			
			IF VARTYPE(m.toEncoderParams) = "O" AND m.toEncoderParams.BaseName = "EncoderParameters"
				lhEncoderParams = toEncoderParams.ToMemoryHandle()
			ENDIF	
			
			DO CASE
			CASE VARTYPE(m.tcFileName) = "C"
				This.SetStatus(xfcGdipSaveImageToFile_I(This.Handle, STRCONV(m.tcFileName+0h00,5), @lqClsidEncoder, lhEncoderParams))
				
			CASE VARTYPE(m.tcFileName) = "O" AND m.tcFileName.BaseClass == "Image"
				m.loImage = m.tcFilename
				m.loImage.PictureVal = This.GetPictureVal(lqClsidEncoder, lhEncoderParams)
		
			CASE VARTYPE(m.tcFileName) = "O" AND "Stream" $ m.tcFileName.BaseName
				m.loStream = m.tcFileName
				This.SetStatus(xfcGdipSaveImageToStream_I(This.Handle, m.loStream.Handle, @lqClsidEncoder, lhEncoderParams))
				
			CASE VARTYPE(m.tcFileName) = "N" && Stream Handle
				LOCAL lhStream
				lhStream = m.tcFileName
				This.SetStatus(xfcGdipSaveImageToStream_I(This.Handle, m.lhStream, @lqClsidEncoder, lhEncoderParams))
		
			ENDCASE
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION SaveAdd
	*********************************************************************
	** Method: xfcImage.SaveAdd
	**
	** Adds the information in the specified Image object to this Image object. The specified
	** EncoderParameters object determines how the new information is incorporated into
	** the existing image.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/15: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.SaveAdd%28vs.80%29.aspx
	** Parameters:
	**  EncoderParameters encoderParams
	**  Image image, EncoderParameters encoderParams
	** Returns: void
	*********************************************************************
	LPARAMETERS toImage AS xfcImage, ;
					toEncoderParams AS xfcEncoderParameters
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE VARTYPE(m.toImage)+VARTYPE(m.toEncoderParams)=="OO" AND m.toEncoderParams.BaseName == "EncoderParameters"
				This.SetStatus(xfcGdipSaveAddImage_S(This.Handle, m.toImage.Handle, m.toEncoderParams.ToVarbinary()))
			CASE VARTYPE(m.toImage)=="O" AND m.toImage.BaseName == "EncoderParameters"
				m.toEncoderParams = m.toImage
				This.SetStatus(xfcGdipSaveAdd_S(This.Handle, m.toEncoderParams.ToVarbinary()))
			OTHERWISE
				*! ToDo: Error, invalid params
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC



	*********************************************************************
	FUNCTION SelectActiveFrame
	*********************************************************************
	** Method: xfcImage.SelectActiveFrame
	**
	** Selects the frame specified by the dimension and index.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/23: BDurban - Coded
	**	2006/05/15: BDurban - Added code to make toDimension parameter optional
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.SelectActiveFrame%28vs.80%29.aspx
	** Parameters:
	**  FrameDimension dimension, int frameIndex
	** Returns: int
	*********************************************************************
	LPARAMETERS toDimension AS xfcFrameDimension, tiFrameIndex
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DO CASE
			CASE VARTYPE(m.toDimension) = "O"
			** Do nothing
			CASE VARTYPE(m.toDimension) = "N"
				m.tiFrameIndex = m.toDimension
				m.toDimension = This.FrameDimensionsList[1]
			OTHERWISE
				m.tiFrameIndex = 0
				m.toDimension = This.FrameDimensionsList[1]
			ENDCASE
			
			This.SetStatus(xfcGdipImageSelectActiveFrame(This.Handle, m.toDimension.ToVarBinary(), m.tiFrameIndex))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN 0	&& Always return 0
	ENDFUNC


	*********************************************************************
	FUNCTION SetPropertyItem
	*********************************************************************
	** Method: xfcImage.SetPropertyItem
	**
	** Stores a property item (piece of metadata) in this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/12: BDurban - Coded partial
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.SetPropertyItem%28vs.80%29.aspx
	** Parameters:
	**  PropertyItem propitem
	** Returns: void
	*********************************************************************
	LPARAMETERS toPropitem AS xfcPropertyItem
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lcItem
			m.lcItem = toPropItem.ToVarBinary()
			This.SetStatus(xfcGdipSetPropertyItem(This.Handle, @lcItem))
			This.PropertyItems = NULL
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Size_ACCESS
	*********************************************************************
	** Property: Size (Access)
	**
	** Gets the width and height, in pixels, of this image.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/22: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.Size%28vs.80%29.aspx
	** Returns: Size
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loSize AS xfcSize
		m.loSize = NULL
		
		LOCAL loExc AS Exception
		TRY
			m.loSize = CREATEOBJECT("xfcSize")
			m.loSize.Width = This.Width
			m.loSize.Height = This.Height
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loSize
	ENDFUNC


	*********************************************************************
	FUNCTION ToPrinter
	*********************************************************************
	** Method: xfcImage.ToPrinter
	**
	** Sends the image object to the Printer
	**
	** History:
	**  2007/17/01: CBoyd / CChalom - Coded
	**  2007/02/02: CChalom - added parameter for orientation
	**  2007/04/28: CChalom / SBerezniker - added code to determine Width and Height when PRTINFO() returns -1
	**  2007/04/29: CChalom - added Stretch and Alignment parameters
	**  2007/11/28: CChalom - fixed to allow printing images of all resolutions
	**  2007/11/29: CChalom / SBerezniker - added code to determine Margins
	*********************************************************************
	LPARAMETERS tnStretch, tcPrinterName, tnOrientation, tnAlignment
		
		* tnStretch
		*   Specifies how an image is sized to fit inside a control. Available at design time and run time.
		*   0 - Clip. The image is clipped to fit the page. (Default)
		*   1 - Isometric. The image resizes to fit the page while maintaining its original proportions.
		*   2 - Stretch. The image resizes to fit the page, but does not maintain its original proportions.
		
		* tcPrinterName
		*   Specifies the name of the printer, the same of GETPRINTER()
		
		* tnOrientation:
		*   0 - Portrait
		*   1 - Landscape
		
		* tnAlignment
		*   Specifies a numerical value representing the alignment of the image in the page.
		*   0 - Vertically Centered Left.
		*   1 - Vertically Centered Right.
		*   2 - Centered. Centers image vertically and horizontally.
		*   4 - Top Left. Aligns image in top left corner of the page.
		*   5 - Top Right. Aligns image in top right corner of the page.
		*   6 - Top Center. Aligns image at the top and horizontally centered on the page.
		*   7 - Bottom Left. Aligns image in the bottom left corner of the page.
		*   8 - Bottom Right. Aligns image in bottom right corner of the page.
		*   9 - Bottom Center. Aligns image at the bottom and vertically centered on the page.
		
		
		
		* API declarations for Basic Printing
		DECLARE INTEGER StartPage IN GDI32 INTEGER hdc
		DECLARE INTEGER EndPage IN GDI32 INTEGER hdc
		DECLARE INTEGER EndDoc IN GDI32 INTEGER hdc
		DECLARE INTEGER StartDoc IN GDI32 INTEGER hdc, STRING lpdi
		
		DECLARE INTEGER OpenPrinter IN winspool.drv STRING  @pPrinterName, INTEGER @phPrinter, INTEGER pDefault
		DECLARE INTEGER ClosePrinter IN winspool.drv INTEGER hPrinter
		DECLARE LONG EnumForms IN winspool.drv AS EnumForms LONG hPrinter, LONG Level, LONG pForm, LONG cbBuf, LONG @pcbNeeded, LONG @ pcReturned
		DECLARE INTEGER HeapCreate IN WIN32API INTEGER dwOptions, INTEGER dwInitialSize, INTEGER dwMaxSize
		DECLARE INTEGER HeapAlloc IN WIN32API INTEGER hHeap, INTEGER dwFlags, INTEGER dwBytes
		DECLARE INTEGER HeapFree IN WIN32API INTEGER hHeap, INTEGER dwFlags, INTEGER lpMem
		DECLARE HeapDestroy IN WIN32API INTEGER hHeap

		DECLARE INTEGER GetDeviceCaps IN gdi32 INTEGER hdc, INTEGER nIndex 

		#DEFINE PHYSICALOFFSETX 112 
		#DEFINE PHYSICALOFFSETY 113 	
		
		
		LOCAL lnPrinterDC, lcDocInfo
		
		LOCAL loExc AS Exception
		TRY
		
			* Confirm Page Orientation
			IF VARTYPE(m.tnOrientation) <> "N"
				m.tnOrientation = PRTINFO(1) && If not passed, retrieve from the printer
				m.tnOrientation = IIF(m.tnOrientation = -1, 0, m.tnOrientation)
			ENDIF
		
		
			* Clone the original Image to ensure that changes will not
			*   be aplied to source
			LOCAL loImg, lhobject
			m.lhobject = 0
			m.loImg = NULL
			This.SetStatus(xfcGdipCloneImage(This.Handle, @lhobject))
			IF(m.lhobject <> 0)
				m.loImg = CREATEOBJECT("xfcImage")
				m.loImg.Handle = m.lhobject
			ENDIF
		
		
			* Values for tnOrientation:
			*   0 - Portrait
			*   1 - Landscape
			IF m.tnOrientation = 1 && Landscape
				loImg.RotateFlip(Rotate90FlipNone)
			ENDIF
		
			* Confirm Alignment
			IF VARTYPE(m.tnAlignment) <> "N"
				m.tnAlignment = 2 && Centered
			ENDIF
		
			* Get Printer name
			IF VARTYPE(tcPrinterName) <> "C" OR EMPTY(tcPrinterName)
				m.tcPrinterName = SET("Printer",3)
			ENDIF
		
			IF VARTYPE(m.tnStretch) <> "N"
				m.tnStretch = 0 && Clip
			ENDIF
		
		
			LOCAL lnImgWidth, lnImgHeight
			m.lnImgWidth = loImg.Width
			m.lnImgHeight = loImg.Height
	
		
			* Get the dimensions of the Paper
			LOCAL lnPaperWidth, lnPaperHeight
			m.lnPageWidth = PRTINFO(4)
			m.lnPageHeight = PRTINFO(3)
		
			IF m.lnPageWidth = -1 OR m.lnPageHeight = -1
				* API declarations for Getting Paper Size
		
				LOCAL lhHeap
				* Allocate a heap
				m.lhHeap = HeapCreate(0, 4096*10, 0)
		
				* Enumerate forms for default VFP printer
				LOCAL lhPrinter, lnNeeded, lnBuffer
		
				* Open a printer
				m.lhPrinter = 0
				m.lnResult = OpenPrinter(@tcPrinterName, @lhPrinter, 0)
		
				* Get the size of the buffer required to fit all forms in lnNeeded
				m.lnNeeded = 0
				=EnumForms(m.lhPrinter, 1,  0, 0, @lnNeeded, 0)
		
				* Get the list of forms
				m.lnBuffer = HeapAlloc(m.lhHeap, 0, m.lnNeeded)
				=EnumForms(m.lhPrinter, 1, m.lnBuffer, @lnNeeded, @lnNeeded, 0)
		
				* Get the information for the desired Paper ID obtained from PRTINFO(2)
				* The form attributes are stored in in thousandths of millimeters
				m.lnPointer = m.lnBuffer + (PRTINFO(2) - 1) * 32
				m.lnPageWidth  = CTOBIN(SYS(2600, (m.lnPointer+ 8), 4),"4RS") / 100
				m.lnPageHeight = CTOBIN(SYS(2600, (m.lnPointer+12), 4),"4RS") / 100
		
				= HeapFree(m.lhHeap, 0, m.lnBuffer )
				= ClosePrinter(m.lhPrinter)
		
				* Clear the Heap
				IF m.lhHeap <> 0
					HeapDestroy(m.lhHeap)
				ENDIF
		
			ENDIF
		

			* Adjust page Width and Height
			m.lnPageWidth = (m.lnPageWidth / 2.54)
			m.lnPageHeight = (m.lnPageHeight / 2.54)
		
			* Get Printer DC for the selected Printer
			m.lnPrinterDC = xfcCreateDC(NULL, m.tcPrinterName+0h00, NULL, NULL)

			* Get the margins
			LOCAL lnHorOffSet, lnVertOffSet
			lnHorOffset = GetDeviceCaps(lnPrinterDC, PHYSICALOFFSETX) 
			lnVertOffSet = GetDeviceCaps(lnPrinterDC, PHYSICALOFFSETY) 


			* Adjust paper size
			lnPageWidth  = lnPageWidth  - (2 * lnHorOffSet)
			lnPageHeight = lnPageHeight - (2 * lnVertOffSet)
	

		
			* Get the dimensions of the Image
			IF m.tnStretch = 0 && Clip
				m.lnWidth = m.lnImgWidth
				m.lnHeight = m.lnImgHeight
		
			ELSE
		
				DO CASE
				CASE m.tnStretch = 1 && Isometric
					* Isometric Adjustment
					LOCAL lnHorFactor, lnVertFactor, lnResizeFactor
					m.lnHorFactor = m.lnPageWidth / m.lnImgWidth
					m.lnVertFactor = m.lnPageHeight / m.lnImgHeight
					m.lnResizeFactor = MIN(m.lnHorFactor, m.lnVertFactor)
					m.lnWidth = m.lnImgWidth * m.lnResizeFactor
					m.lnHeight = m.lnImgHeight * m.lnResizeFactor
		
				CASE m.tnStretch = 2 && Stretch
					m.lnWidth = m.lnPageWidth
					m.lnHeight = m.lnPageHeight
		
				OTHERWISE
		
				ENDCASE
		
			ENDIF
		

		
			LOCAL x, y
			DO CASE
				CASE m.tnAlignment = 0
					x = 0
					y = (m.lnPageHeight - m.lnHeight) / 2
		
				CASE m.tnAlignment = 1
					x = m.lnPageWidth - m.lnWidth
					y = (m.lnPageHeight - m.lnHeight) / 2
		
				CASE m.tnAlignment = 2
					x = (m.lnPageWidth - m.lnWidth) / 2
					y = (m.lnPageHeight - m.lnHeight) / 2
		
				CASE m.tnAlignment = 4
					x = 0
					y = 0
		
				CASE m.tnAlignment = 5
					x = m.lnPageWidth - m.lnWidth
					y = 0
		
				CASE m.tnAlignment = 6
					x = (m.lnPageWidth - m.lnWidth) / 2
					y = 0
		
				CASE m.tnAlignment = 7
					x = 0
					y = m.lnPageHeight - m.lnHeight
		
				CASE m.tnAlignment = 8
					x = m.lnPageWidth - m.lnWidth
					y = m.lnPageHeight - m.lnHeight
		
				CASE m.tnAlignment = 9
					x = (m.lnPageWidth - m.lnWidth) / 2
					y = m.lnPageHeight - m.lnHeight
		
				OTHERWISE
					x = 0
					y = 0
		
			ENDCASE
		
			* Adjust coordinates to start after the TopLeft margin
			x = x + lnHorOffSet
			y = y + lnHorOffSet		
	
			* Start Printing
			IF m.lnPrinterDC <> 0
				m.lcDocInfo = PADR(CHR(20), 20, CHR(0)) && Fake DocInfo Struct
				StartDoc(m.lnPrinterDC, m.lcDocInfo)
				StartPage(m.lnPrinterDC)
		
				LOCAL loGraphics AS xfcGraphics
				m.lhGraphics = 0
				m.loGraphics = NULL
				m.loGraphics = CREATEOBJECT("xfcGraphics")
				m.loGraphics = m.loGraphics.FromHdc(m.lnPrinterDC)
		
				* Draw the image to the printer
				loGraphics.DrawImage(loImg, x, y, m.lnWidth, m.lnHeight)
		
				EndPage(m.lnPrinterDC)
				EndDoc(m.lnPrinterDC)
				xfcDeleteDC(m.lnPrinterDC)
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION VerticalResolution_ACCESS
	*********************************************************************
	** Property: VerticalResolution (Access)
	**
	** Gets the vertical resolution, in pixels-per-inch, of this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.VerticalResolution%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetImageVerticalResolution(This.Handle, @lnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Width_ACCESS
	*********************************************************************
	** Property: Width (Access)
	**
	** Gets the width of this Image object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Image.Width%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		LOCAL liValue
		m.liValue = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetImageWidth(This.Handle, @liValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liValue
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="fromfile" type="method" display="FromFile"/>]+;
		[<memberdata name="fromhbitmap" type="method" display="FromHbitmap"/>]+;
		[<memberdata name="fromstream" type="method" display="FromStream"/>]+;
		[<memberdata name="getbounds" type="method" display="GetBounds"/>]+;
		[<memberdata name="getencoderparameterlist" type="method" display="GetEncoderParameterList"/>]+;
		[<memberdata name="getframecount" type="method" display="GetFrameCount"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="getpixelformatsize" type="method" display="GetPixelFormatSize"/>]+;
		[<memberdata name="getpropertyitem" type="method" display="GetPropertyItem"/>]+;
		[<memberdata name="getthumbnailimage" type="method" display="GetThumbnailImage"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="isalphapixelformat" type="method" display="IsAlphaPixelFormat"/>]+;
		[<memberdata name="iscanonicalpixelformat" type="method" display="IsCanonicalPixelFormat"/>]+;
		[<memberdata name="isextendedpixelformat" type="method" display="IsExtendedPixelFormat"/>]+;
		[<memberdata name="removepropertyitem" type="method" display="RemovePropertyItem"/>]+;
		[<memberdata name="rotateflip" type="method" display="RotateFlip"/>]+;
		[<memberdata name="save" type="method" display="Save"/>]+;
		[<memberdata name="saveadd" type="method" display="SaveAdd"/>]+;
		[<memberdata name="selectactiveframe" type="method" display="SelectActiveFrame"/>]+;
		[<memberdata name="setpropertyitem" type="method" display="SetPropertyItem"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="flags" type="property" display="Flags"/>]+;
		[<memberdata name="framedimensionslist" type="property" display="FrameDimensionsList"/>]+;
		[<memberdata name="height" type="property" display="Height"/>]+;
		[<memberdata name="horizontalresolution" type="property" display="HorizontalResolution"/>]+;
		[<memberdata name="palette" type="property" display="Palette"/>]+;
		[<memberdata name="physicaldimension" type="property" display="PhysicalDimension"/>]+;
		[<memberdata name="pixelformat" type="property" display="PixelFormat"/>]+;
		[<memberdata name="propertyidlist" type="property" display="PropertyIdList"/>]+;
		[<memberdata name="propertyitems" type="property" display="PropertyItems"/>]+;
		[<memberdata name="rawformat" type="property" display="RawFormat"/>]+;
		[<memberdata name="size" type="property" display="Size"/>]+;
		[<memberdata name="verticalresolution" type="property" display="VerticalResolution"/>]+;
		[<memberdata name="width" type="property" display="Width"/>]+;
		[<memberdata name="getmonochrome" type="method" display="GetMonochrome"/>]+;
		[<memberdata name="toprinter" type="method" display="ToPrinter"/>]+;
		[<memberdata name="getpictureval" type="method" display="GetPictureVal"/>]+;
		[<memberdata name="getpicturevalfromhbitmap" type="method" display="GetPictureValfromHBitmap"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCIMAGEANIMATOR
DEFINE CLASS xfcImageAnimator AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "ImageAnimator"
	framechangedhandler = ""
	oimage = .NULL.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcImageAnimator.ImageAnimator
	**
	** Animates an image that has time-based frames.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/05/09" CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ImageAnimator%28vs.80%29.aspx
	** Parameters:
		
	*********************************************************************
		
		LOCAL loExc AS EXCEPTION
		TRY
			DODEFAULT()
			THIS.ADDOBJECT("ImageAnimatorTimers", "Collection")
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcImageAnimator.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/13: CBoyd - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		This.ImageAnimatorTimers.Remove(-1)
	**This.ImageAnimatorTimers = NULL
		
		LOCAL loExc AS Exception
		TRY
	** This.SetStatus(GdipSomeFunction???())
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Animate
	*********************************************************************
	** Method: xfcImageAnimator.Animate
	**
	** Displays a multiple-frame image as an animation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ImageAnimator.Animate%28vs.80%29.aspx
	** Parameters:
	**  Image image, EventHandler onFrameChangedHandler
	** Returns: void
	*********************************************************************
	LPARAMETERS toImage AS xfcImage, toOnFrameChangedHandler AS xfcEventHandler
		
		LOCAL loExc AS Exception
		TRY
			This.ImageAnimatorTimers.Add(CREATEOBJECT("_xfcImageAnimatorTimer", m.toImage, m.toOnFrameChangedHandler), TRANSFORM(toImage.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION CanAnimate
	*********************************************************************
	** Method: xfcImageAnimator.CanAnimate
	**
	** Returns a Boolean value indicating whether the specified image contains time-based
	** frames.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ImageAnimator.CanAnimate%28vs.80%29.aspx
	** Parameters:
	**  Image image
	** Returns: bool
	*********************************************************************
	LPARAMETERS toImage AS xfcImage
		
		LOCAL loExc AS Exception, llValue
		TRY
			m.llValue = toImage.GetFrameCount() > 0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION StopAnimate
	*********************************************************************
	** Method: xfcImageAnimator.StopAnimate
	**
	** Terminates a running animation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ImageAnimator.StopAnimate%28vs.80%29.aspx
	** Parameters:
	**  Image image, EventHandler onFrameChangedHandler
	** Returns: void
	*********************************************************************
	LPARAMETERS toImage AS xfcImage, thOnFrameChangedHandler AS FuncPtr
		
		IF VARTYPE(m.toImage) = "O"
			IF This.ImageAnimatorTimers.GetKey(TRANSFORM(toImage.Handle)) > 0
				This.ImageAnimatorTimers.Remove(TRANSFORM(toImage.Handle))
			ENDIF
		ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION UpdateFrames
	*********************************************************************
	** Method: xfcImageAnimator.UpdateFrames
	**
	** Overloaded.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.ImageAnimator.UpdateFrames%28vs.80%29.aspx
	** Parameters:
	**  [None]
	**  Image image
	** Returns: void
	*********************************************************************
	LPARAMETERS toImage AS xfcImage
		
		LOCAL lcHandleKey, loImage AS xfcImage
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(toImage) = "O" && Update just specified image
				lcHandleKey = TRANSFORM(toImage.Handle)
				This.ImageAnimatorTimers.Item(lcHandleKey).UpdateFrame()
			ELSE && Update all images being animated
				FOR EACH loImage IN This.ImageAnimatorTimers
					loImage.UpdateFrame()
				ENDFOR
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="animate" type="method" display="Animate"/>]+;
		[<memberdata name="cananimate" type="method" display="CanAnimate"/>]+;
		[<memberdata name="stopanimate" type="method" display="StopAnimate"/>]+;
		[<memberdata name="updateframes" type="method" display="UpdateFrames"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS__XFCIMAGEANIMATORTIMER
DEFINE CLASS _xfcimageanimatortimer AS timer
*************************************************************************
*************************************************************************
*************************************************************************
	Height = 24
	oArgs = .NULL.
	oEventHandler = .NULL.	&& Eventhandler to use whenever timer event fires
	oImage = .NULL.	&& xfcImage instance that this timer subclass animates.
	Width = 171
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: _xfcimageanimatortimer.Init
	**
	** Creates a new ImageAnimator timer for the specified image
	**
	** History:
	**  2006/05/09: CBoyd - Coded
	**	2006/05/15: BDurban - Added support for frame delay array
	*********************************************************************
	LPARAMETERS toImage as xfcImage, toEventHandler as xfcEventHandler
		
		LOCAL loProp AS xfcPropertyItem
		LOCAL lnStep, lqProp, lnFrameCount
		
		LOCAL loExc AS EXCEPTION
		TRY
			IF VARTYPE(toImage) = "O" AND VARTYPE(toEventHandler) = "O"
				This.oImage = m.toImage
				This.oEventHandler = m.toEventHandler.Bind(This, "FrameRefresh")
				
				This.oArgs = CREATEOBJECT("Empty")
				ADDPROPERTY(This.oArgs, "CurrentFrame", -1)
				ADDPROPERTY(This.oArgs, "FrameCount", m.toImage.GetFrameCount())
				ADDPROPERTY(This.oArgs, "CurrentLoop", 0)
				ADDPROPERTY(This.oArgs, "LoopCount", 0)
				ADDPROPERTY(This.oArgs, "FrameDelays[1]", 0)
				
				WITH This.oArgs
					DIMENSION .FrameDelays[MAX(.FrameCount,1)]
					.FrameDelays = 250	&& Default to 1/4 second
					
				** Get the frame delays for this image
					m.loProp = m.toImage.GetPropertyItem( PropertyTagFrameDelay )
					IF m.loProp.Len > 0
						m.lnFrameCnt = MIN(.FrameCount, m.loProp.Len/4)
						
						FOR lnStep = 1 TO m.lnFrameCnt
							m.lqProp = SUBSTR(m.loProp.Value, (m.lnStep-1)*4+1, 4)
							.FrameDelays[m.lnStep] = 10*CTOBIN(m.lqProp, "4rs")
						ENDFOR
					ENDIF
					
				** Get the loop count
					m.loProp = m.toImage.GetPropertyItem( PropertyTagLoopCount )
					IF m.loProp.Len = 4
						.LoopCount = CTOBIN(m.loProp.Value, "4rs")
					ENDIF			
				ENDWITH
				
				This.Interval=30
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
		LOCAL loExc AS EXCEPTION
		TRY
			DODEFAULT()
			This.oEventHandler = NULL
			This.oImage = NULL
			This.oArgs = NULL
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION FrameRefresh
	*********************************************************************
	LPARAMETERS toSource, toArgs
		
	** This is a place holder method. We bind to this method in the init
	ENDFUNC


	*********************************************************************
	FUNCTION Timer
	*********************************************************************
	** Method: _xfcimageanimatortimer.Timer
	**
	** Occurs when the frame time has expired for the current frame
	**
	** History:
	**  2006/05/09: CBoyd - Coded
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.FrameRefresh(This.oImage, This.oArgs)
		CATCH TO loExc
			THROW loExc
		ENDTRY
	ENDFUNC


	*********************************************************************
	FUNCTION UpdateFrame
	*********************************************************************
	** Method: _xfcimageanimatortimer.UpdateFrame
	**
	** Called from the ImageAnimator's UpdateFrame method, updates the frame
	** for the linked image object and keeps track of our current frame and loop count
	**
	** History:
	**  2006/05/09: CBoyd - Coded
	**	2006/05/15: BDurban - Added support for frame delay array
	*********************************************************************
		LOCAL loExc AS EXCEPTION, loGuid as xfcGuid
		TRY
			WITH This.oArgs
				.CurrentFrame = .CurrentFrame + 1
				IF .CurrentFrame > .FrameCount-1
					.CurrentFrame = 0
					.CurrentLoop = .CurrentLoop + 1
					IF .LoopCount > 0 AND .LoopCount =< .CurrentLoop
						This.Interval = 0
						*!ToDo: What else do we need to do to remove it from the collection of xfcImageAnimator
						EXIT
					ENDIF
				ENDIF
			** Set the current frame
				This.oImage.SelectActiveFrame(.CurrentFrame)
			** Set the interval for the current frame
				This.Interval = .FrameDelays[.CurrentFrame+1]
			ENDWITH
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="framerefresh" type="method" display="FrameRefresh"/>]+;
		[<memberdata name="oargs" type="property" display="oArgs"/>]+;
		[<memberdata name="oeventhandler" type="property" display="oEventHandler"/>]+;
		[<memberdata name="oimage" type="property" display="oImage"/>]+;
		[<memberdata name="updateframe" type="method" display="UpdateFrame"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************


*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS__XFCKNOWNCOLORTABLE
DEFINE CLASS _xfcknowncolortable AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	DIMENSION _colornametable[1]

	DIMENSION _colortable[1]

 
	*********************************************************************
	FUNCTION ArgbToKnownColor
	*********************************************************************
	LPARAMETERS tiArgb, tlEnumOnly
		
			LOCAL loColor AS xfcColor, liNum, liNum2
			
			m.loColor = NULL
		
			This._EnsureColorTable()
			FOR m.liNum = 1 TO 0xae
				m.liNum2 = This._ColorTable(m.liNum)
				IF m.liNum2 = m.tiArgb
				** Argb found...
					IF BETWEEN(m.liNum,0x1a,0xa7)	&& Ignore System Colors
						IF m.tlEnumOnly
							m.loColor = m.liNum
						ELSE
							m.loColor = CREATEOBJECT("xfcColor",m.tiArgb,1+2,NULL,m.liNum)
						ENDIF
					ENDIF
				ENDIF
			ENDFOR
			
			IF ISNULL(m.loColor)
				m.loColor = IIF(m.tlEnumOnly,0,CREATEOBJECT("xfcColor",m.tiArgb,1+2+8,NULL,0))
			ENDIF
			
			RETURN m.loColor
	ENDFUNC


	*********************************************************************
	FUNCTION KnownColorToArgb
	*********************************************************************
	LPARAMETERS tiColor
		
			LOCAL m.liArgb
			m.liArgb = 0
		
			This._EnsureColorTable()
			IF (m.tiColor <= 0xae)
				m.liArgb = This._ColorTable[m.tiColor]
			ENDIF
			
		return m.liArgb
	ENDFUNC


	*********************************************************************
	FUNCTION knowncolortoname
	*********************************************************************
	LPARAMETERS tiColor
		
			LOCAL m.lcName
			m.lcName = NULL
		
			This._EnsureColorNameTable()
			IF (m.tiColor <= 0xae)
				m.lcName = This._ColorNameTable[m.tiColor]
			ENDIF
			
		return m.lcName
	ENDFUNC


	*********************************************************************
	FUNCTION NameToKnownColor
	*********************************************************************
	LPARAMETERS tcColor, tlEnumOnly
		
			LOCAL loColor AS xfcColor, liNum, lcName
			
			m.loColor = NULL
		
			This._EnsureColorNameTable()
			This._EnsureColorTable()
			FOR m.liNum = 1 TO 0xae
				m.lcName = This._ColorNameTable(m.liNum)
				IF LOWER(m.lcName) == LOWER(m.tcColor)
					IF tlEnumOnly
						m.loColor = m.liNum
					ELSE
						m.loColor = CREATEOBJECT("xfcColor",This._ColorTable[m.liNum],1+2+8,m.lcName,m.liNum)
					ENDIF
					EXIT
				ENDIF
			ENDFOR
			
			IF ISNULL(m.loColor)
				m.loColor = IIF(m.tlEnumOnly,0,CREATEOBJECT("xfcColor"))
			ENDIF
			
			RETURN m.loColor
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION _encode
	*********************************************************************
	LPARAMETERS tiA, tiR, tiG, tiB
		
		RETURN	BITLSHIFT(m.tiA,0x18)+BITLSHIFT(m.tiR,0x10)+BITLSHIFT(m.tiG,0x08)+m.tiB
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION _ensurecolornametable
	*********************************************************************
		
		
			IF VARTYPE(This._ColorNameTable) <> "C"
				This._InitColorNameTable()
			ENDIF
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION _ensurecolortable
	*********************************************************************
		
		
			IF VARTYPE(This._ColorTable) <> "N"
				This._InitColorTable()
			ENDIF
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION _initcolornametable
	** 2008/12/10 : CChalom - fixed, checking for "SET COMPATIBLE"
	** 2013/03/10 : Rick Schummer - fixed DarkSalmon color issue - http://vfpx.codeplex.com/workitem/32673
	*********************************************************************

			LOCAL lcSetCompatible
			m.lcSetCompatible = SET("Compatible")
			SET COMPATIBLE OFF
				
			LOCAL laColorNameTable[0xaf]
			m.laColorNameTable = ""
			m.laColorNameTable[0x01] = "ActiveBorder"
			m.laColorNameTable[0x02] = "ActiveCaption"
			m.laColorNameTable[0x03] = "ActiveCaptionText"
			m.laColorNameTable[0x04] = "AppWorkspace"
			m.laColorNameTable[0xa8] = "ButtonFace"
			m.laColorNameTable[0xa9] = "ButtonHighlight"
			m.laColorNameTable[0xaa] = "ButtonShadow"
			m.laColorNameTable[0x05] = "Control"
			m.laColorNameTable[0x06] = "ControlDark"
			m.laColorNameTable[0x07] = "ControlDarkDark"
			m.laColorNameTable[0x08] = "ControlLight"
			m.laColorNameTable[0x09] = "ControlLightLight"
			m.laColorNameTable[0x0a] = "ControlText"
			m.laColorNameTable[0x0b] = "Desktop"
			m.laColorNameTable[0xab] = "GradientActiveCaption"
			m.laColorNameTable[0xac] = "GradientInactiveCaption"
			m.laColorNameTable[0x0c] = "GrayText"
			m.laColorNameTable[0x0d] = "Highlight"
			m.laColorNameTable[0x0e] = "HighlightText"
			m.laColorNameTable[0x0f] = "HotTrack"
			m.laColorNameTable[0x10] = "InactiveBorder"
			m.laColorNameTable[0x11] = "InactiveCaption"
			m.laColorNameTable[0x12] = "InactiveCaptionText"
			m.laColorNameTable[0x13] = "Info"
			m.laColorNameTable[0x14] = "InfoText"
			m.laColorNameTable[0x15] = "Menu"
			m.laColorNameTable[0xad] = "MenuBar"
			m.laColorNameTable[0xae] = "MenuHighlight"
			m.laColorNameTable[0x16] = "MenuText"
			m.laColorNameTable[0x17] = "ScrollBar"
			m.laColorNameTable[0x18] = "Window"
			m.laColorNameTable[0x19] = "WindowFrame"
			m.laColorNameTable[0x1a] = "WindowText"
			m.laColorNameTable[0x1b] = "Transparent"
			m.laColorNameTable[0x1c] = "AliceBlue"
			m.laColorNameTable[0x1d] = "AntiqueWhite"
			m.laColorNameTable[0x1e] = "Aqua"
			m.laColorNameTable[0x1f] = "Aquamarine"
			m.laColorNameTable[0x20] = "Azure"
			m.laColorNameTable[0x21] = "Beige"
			m.laColorNameTable[0x22] = "Bisque"
			m.laColorNameTable[0x23] = "Black"
			m.laColorNameTable[0x24] = "BlanchedAlmond"
			m.laColorNameTable[0x25] = "Blue"
			m.laColorNameTable[0x26] = "BlueViolet"
			m.laColorNameTable[0x27] = "Brown"
			m.laColorNameTable[0x28] = "BurlyWood"
			m.laColorNameTable[0x29] = "CadetBlue"
			m.laColorNameTable[0x2a] = "Chartreuse"
			m.laColorNameTable[0x2b] = "Chocolate"
			m.laColorNameTable[0x2c] = "Coral"
			m.laColorNameTable[0x2d] = "CornflowerBlue"
			m.laColorNameTable[0x2e] = "Cornsilk"
			m.laColorNameTable[0x2f] = "Crimson"
			m.laColorNameTable[0x30] = "Cyan"
			m.laColorNameTable[0x31] = "DarkBlue"
			m.laColorNameTable[0x32] = "DarkCyan"
			m.laColorNameTable[0x33] = "DarkGoldenrod"
			m.laColorNameTable[0x34] = "DarkGray"
			m.laColorNameTable[0x35] = "DarkGreen"
			m.laColorNameTable[0x36] = "DarkKhaki"
			m.laColorNameTable[0x37] = "DarkMagenta"
			m.laColorNameTable[0x38] = "DarkOliveGreen"
			m.laColorNameTable[0x39] = "DarkOrange"
			m.laColorNameTable[0x3a] = "DarkOrchid"
			m.laColorNameTable[0x3b] = "DarkRed"
			m.laColorNameTable[0x3c] = "DarkSalmon"
			m.laColorNameTable[0x3d] = "DarkSeaGreen"
			m.laColorNameTable[0x3e] = "DarkSlateBlue"
			m.laColorNameTable[0x3f] = "DarkSlateGray"
			m.laColorNameTable[0x40] = "DarkTurquoise"
			m.laColorNameTable[0x41] = "DarkViolet"
			m.laColorNameTable[0x42] = "DeepPink"
			m.laColorNameTable[0x43] = "DeepSkyBlue"
			m.laColorNameTable[0x44] = "DimGray"
			m.laColorNameTable[0x45] = "DodgerBlue"
			m.laColorNameTable[0x46] = "Firebrick"
			m.laColorNameTable[0x47] = "FloralWhite"
			m.laColorNameTable[0x48] = "ForestGreen"
			m.laColorNameTable[0x49] = "Fuchsia"
			m.laColorNameTable[0x4a] = "Gainsboro"
			m.laColorNameTable[0x4b] = "GhostWhite"
			m.laColorNameTable[0x4c] = "Gold"
			m.laColorNameTable[0x4d] = "Goldenrod"
			m.laColorNameTable[0x4e] = "Gray"
			m.laColorNameTable[0x4f] = "Green"
			m.laColorNameTable[0x50] = "GreenYellow"
			m.laColorNameTable[0x51] = "Honeydew"
			m.laColorNameTable[0x52] = "HotPink"
			m.laColorNameTable[0x53] = "IndianRed"
			m.laColorNameTable[0x54] = "Indigo"
			m.laColorNameTable[0x55] = "Ivory"
			m.laColorNameTable[0x56] = "Khaki"
			m.laColorNameTable[0x57] = "Lavender"
			m.laColorNameTable[0x58] = "LavenderBlush"
			m.laColorNameTable[0x59] = "LawnGreen"
			m.laColorNameTable[90] = "LemonChiffon"
			m.laColorNameTable[0x5b] = "LightBlue"
			m.laColorNameTable[0x5c] = "LightCoral"
			m.laColorNameTable[0x5d] = "LightCyan"
			m.laColorNameTable[0x5e] = "LightGoldenrodYellow"
			m.laColorNameTable[0x5f] = "LightGray"
			m.laColorNameTable[0x60] = "LightGreen"
			m.laColorNameTable[0x61] = "LightPink"
			m.laColorNameTable[0x62] = "LightSalmon"
			m.laColorNameTable[0x63] = "LightSeaGreen"
			m.laColorNameTable[100] = "LightSkyBlue"
			m.laColorNameTable[0x65] = "LightSlateGray"
			m.laColorNameTable[0x66] = "LightSteelBlue"
			m.laColorNameTable[0x67] = "LightYellow"
			m.laColorNameTable[0x68] = "Lime"
			m.laColorNameTable[0x69] = "LimeGreen"
			m.laColorNameTable[0x6a] = "Linen"
			m.laColorNameTable[0x6b] = "Magenta"
			m.laColorNameTable[0x6c] = "Maroon"
			m.laColorNameTable[0x6d] = "MediumAquamarine"
			m.laColorNameTable[110] = "MediumBlue"
			m.laColorNameTable[0x6f] = "MediumOrchid"
			m.laColorNameTable[0x70] = "MediumPurple"
			m.laColorNameTable[0x71] = "MediumSeaGreen"
			m.laColorNameTable[0x72] = "MediumSlateBlue"
			m.laColorNameTable[0x73] = "MediumSpringGreen"
			m.laColorNameTable[0x74] = "MediumTurquoise"
			m.laColorNameTable[0x75] = "MediumVioletRed"
			m.laColorNameTable[0x76] = "MidnightBlue"
			m.laColorNameTable[0x77] = "MintCream"
			m.laColorNameTable[120] = "MistyRose"
			m.laColorNameTable[0x79] = "Moccasin"
			m.laColorNameTable[0x7a] = "NavajoWhite"
			m.laColorNameTable[0x7b] = "Navy"
			m.laColorNameTable[0x7c] = "OldLace"
			m.laColorNameTable[0x7d] = "Olive"
			m.laColorNameTable[0x7e] = "OliveDrab"
			m.laColorNameTable[0x7f] = "Orange"
			m.laColorNameTable[0x80] = "OrangeRed"
			m.laColorNameTable[0x81] = "Orchid"
			m.laColorNameTable[130] = "PaleGoldenrod"
			m.laColorNameTable[0x83] = "PaleGreen"
			m.laColorNameTable[0x84] = "PaleTurquoise"
			m.laColorNameTable[0x85] = "PaleVioletRed"
			m.laColorNameTable[0x86] = "PapayaWhip"
			m.laColorNameTable[0x87] = "PeachPuff"
			m.laColorNameTable[0x88] = "Peru"
			m.laColorNameTable[0x89] = "Pink"
			m.laColorNameTable[0x8a] = "Plum"
			m.laColorNameTable[0x8b] = "PowderBlue"
			m.laColorNameTable[140] = "Purple"
			m.laColorNameTable[0x8d] = "Red"
			m.laColorNameTable[0x8e] = "RosyBrown"
			m.laColorNameTable[0x8f] = "RoyalBlue"
			m.laColorNameTable[0x90] = "SaddleBrown"
			m.laColorNameTable[0x91] = "Salmon"
			m.laColorNameTable[0x92] = "SandyBrown"
			m.laColorNameTable[0x93] = "SeaGreen"
			m.laColorNameTable[0x94] = "SeaShell"
			m.laColorNameTable[0x95] = "Sienna"
			m.laColorNameTable[150] = "Silver"
			m.laColorNameTable[0x97] = "SkyBlue"
			m.laColorNameTable[0x98] = "SlateBlue"
			m.laColorNameTable[0x99] = "SlateGray"
			m.laColorNameTable[0x9a] = "Snow"
			m.laColorNameTable[0x9b] = "SpringGreen"
			m.laColorNameTable[0x9c] = "SteelBlue"
			m.laColorNameTable[0x9d] = "Tan"
			m.laColorNameTable[0x9e] = "Teal"
			m.laColorNameTable[0x9f] = "Thistle"
			m.laColorNameTable[160] = "Tomato"
			m.laColorNameTable[0xa1] = "Turquoise"
			m.laColorNameTable[0xa2] = "Violet"
			m.laColorNameTable[0xa3] = "Wheat"
			m.laColorNameTable[0xa4] = "White"
			m.laColorNameTable[0xa5] = "WhiteSmoke"
			m.laColorNameTable[0xa6] = "Yellow"
			m.laColorNameTable[0xa7] = "YellowGreen"
			
			DIMENSION This._ColorNameTable[ALEN(m.laColorNameTable)]
			ACOPY(m.laColorNameTable, This._ColorNameTable)

			SET COMPATIBLE &lcSetCompatible.
		
		RETURN
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION _initcolortable
	*********************************************************************
		
			DIMENSION laColorTable[0xaf]
			This._UpdateSystemColors(@m.laColorTable)
			m.laColorTable[0x1b] = 0xffffff
			m.laColorTable[0x1c] = -984833
			m.laColorTable[0x1d] = -332841
			m.laColorTable[0x1e] = -16711681
			m.laColorTable[0x1f] = -8388652
			m.laColorTable[0x20] = -983041
			m.laColorTable[0x21] = -657956
			m.laColorTable[0x22] = -6972
			m.laColorTable[0x23] = -16777216
			m.laColorTable[0x24] = -5171
			m.laColorTable[0x25] = -16776961
			m.laColorTable[0x26] = -7722014
			m.laColorTable[0x27] = -5952982
			m.laColorTable[0x28] = -2180985
			m.laColorTable[0x29] = -10510688
			m.laColorTable[0x2a] = -8388864
			m.laColorTable[0x2b] = -2987746
			m.laColorTable[0x2c] = -32944
			m.laColorTable[0x2d] = -10185235
			m.laColorTable[0x2e] = -1828
			m.laColorTable[0x2f] = -2354116
			m.laColorTable[0x30] = -16711681
			m.laColorTable[0x31] = -16777077
			m.laColorTable[0x32] = -16741493
			m.laColorTable[0x33] = -4684277
			m.laColorTable[0x34] = -5658199
			m.laColorTable[0x35] = -16751616
			m.laColorTable[0x36] = -4343957
			m.laColorTable[0x37] = -7667573
			m.laColorTable[0x38] = -11179217
			m.laColorTable[0x39] = -29696
			m.laColorTable[0x3a] = -6737204
			m.laColorTable[0x3b] = -7667712
			m.laColorTable[0x3c] = -1468806
			m.laColorTable[0x3d] = -7357301
			m.laColorTable[0x3e] = -12042869
			m.laColorTable[0x3f] = -13676721
			m.laColorTable[0x40] = -16724271
			m.laColorTable[0x41] = -7077677
			m.laColorTable[0x42] = -60269
			m.laColorTable[0x43] = -16728065
			m.laColorTable[0x44] = -9868951
			m.laColorTable[0x45] = -14774017
			m.laColorTable[0x46] = -5103070
			m.laColorTable[0x47] = -1296
			m.laColorTable[0x48] = -14513374
			m.laColorTable[0x49] = -65281
			m.laColorTable[0x4a] = -2302756
			m.laColorTable[0x4b] = -460545
			m.laColorTable[0x4c] = -10496
			m.laColorTable[0x4d] = -2448096
			m.laColorTable[0x4e] = -8355712
			m.laColorTable[0x4f] = -16744448
			m.laColorTable[0x50] = -5374161
			m.laColorTable[0x51] = -983056
			m.laColorTable[0x52] = -38476
			m.laColorTable[0x53] = -3318692
			m.laColorTable[0x54] = -11861886
			m.laColorTable[0x55] = -16
			m.laColorTable[0x56] = -989556
			m.laColorTable[0x57] = -1644806
			m.laColorTable[0x58] = -3851
			m.laColorTable[0x59] = -8586240
			m.laColorTable[0x5a] = -1331
			m.laColorTable[0x5b] = -5383962
			m.laColorTable[0x5c] = -1015680
			m.laColorTable[0x5d] = -2031617
			m.laColorTable[0x5e] = -329006
			m.laColorTable[0x5f] = -2894893
			m.laColorTable[0x60] = -7278960
			m.laColorTable[0x61] = -18751
			m.laColorTable[0x62] = -24454
			m.laColorTable[0x63] = -14634326
			m.laColorTable[0x64] = -7876870
			m.laColorTable[0x65] = -8943463
			m.laColorTable[0x66] = -5192482
			m.laColorTable[0x67] = -32
			m.laColorTable[0x68] = -16711936
			m.laColorTable[0x69] = -13447886
			m.laColorTable[0x6a] = -331546
			m.laColorTable[0x6b] = -65281
			m.laColorTable[0x6c] = -8388608
			m.laColorTable[0x6d] = -10039894
			m.laColorTable[0x6e] = -16777011
			m.laColorTable[0x6f] = -4565549
			m.laColorTable[0x70] = -7114533
			m.laColorTable[0x71] = -12799119
			m.laColorTable[0x72] = -8689426
			m.laColorTable[0x73] = -16713062
			m.laColorTable[0x74] = -12004916
			m.laColorTable[0x75] = -3730043
			m.laColorTable[0x76] = -15132304
			m.laColorTable[0x77] = -655366
			m.laColorTable[0x78] = -6943
			m.laColorTable[0x79] = -6987
			m.laColorTable[0x7a] = -8531
			m.laColorTable[0x7b] = -16777088
			m.laColorTable[0x7c] = -133658
			m.laColorTable[0x7d] = -8355840
			m.laColorTable[0x7e] = -9728477
			m.laColorTable[0x7f] = -23296
			m.laColorTable[0x80] = -47872
			m.laColorTable[0x81] = -2461482
			m.laColorTable[0x82] = -1120086
			m.laColorTable[0x83] = -6751336
			m.laColorTable[0x84] = -5247250
			m.laColorTable[0x85] = -2396013
			m.laColorTable[0x86] = -4139
			m.laColorTable[0x87] = -9543
			m.laColorTable[0x88] = -3308225
			m.laColorTable[0x89] = -16181
			m.laColorTable[0x8a] = -2252579
			m.laColorTable[0x8b] = -5185306
			m.laColorTable[0x8c] = -8388480
			m.laColorTable[0x8d] = -65536
			m.laColorTable[0x8e] = -4419697
			m.laColorTable[0x8f] = -12490271
			m.laColorTable[0x90] = -7650029
			m.laColorTable[0x91] = -360334
			m.laColorTable[0x92] = -744352
			m.laColorTable[0x93] = -13726889
			m.laColorTable[0x94] = -2578
			m.laColorTable[0x95] = -6270419
			m.laColorTable[0x96] = -4144960
			m.laColorTable[0x97] = -7876885
			m.laColorTable[0x98] = -9807155
			m.laColorTable[0x99] = -9404272
			m.laColorTable[0x9a] = -1286
			m.laColorTable[0x9b] = -16711809
			m.laColorTable[0x9c] = -12156236
			m.laColorTable[0x9d] = -2968436
			m.laColorTable[0x9e] = -16744320
			m.laColorTable[0x9f] = -2572328
			m.laColorTable[0xa0] = -40121
			m.laColorTable[0xa1] = -12525360
			m.laColorTable[0xa2] = -1146130
			m.laColorTable[0xa3] = -663885
			m.laColorTable[0xa4] = -1
			m.laColorTable[0xa5] = -657931
			m.laColorTable[0xa6] = -256
			m.laColorTable[0xa7] = -6632142
			DIMENSION This._ColorTable[ALEN(m.laColorTable)]
			ACOPY(m.laColorTable,This._ColorTable)
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION _systemcolortoargb
	*********************************************************************
	LPARAMETERS tiIndex
		
			LOCAL liRgb, liArgb
			m.liRgb = xfcGetSysColor(m.tiIndex)
			
			RETURN This._Encode(0xff, ;
							BITAND(m.liRgb,0xff), ;
							BITAND(BITRSHIFT(m.liRgb,0x08),0xff), ;
							BITAND(BITRSHIFT(m.liRgb,0x10),0xff))
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION _updatesystemcolors
	*********************************************************************
	LPARAMETERS laColorTable
		
			m.laColorTable[0x01] = This._SystemColorToArgb(10)
			m.laColorTable[0x02] = This._SystemColorToArgb(2)
			m.laColorTable[0x03] = This._SystemColorToArgb(9)
			m.laColorTable[0x04] = This._SystemColorToArgb(12)
			m.laColorTable[0xa8] = This._SystemColorToArgb(15)
			m.laColorTable[0xa9] = This._SystemColorToArgb(20)
			m.laColorTable[0xaa] = This._SystemColorToArgb(0x10)
			m.laColorTable[0x05] = This._SystemColorToArgb(15)
			m.laColorTable[0x06] = This._SystemColorToArgb(0x10)
			m.laColorTable[0x07] = This._SystemColorToArgb(0x15)
			m.laColorTable[0x08] = This._SystemColorToArgb(0x16)
			m.laColorTable[0x09] = This._SystemColorToArgb(20)
			m.laColorTable[0x0a] = This._SystemColorToArgb(0x12)
			m.laColorTable[0x0b] = This._SystemColorToArgb(1)
			m.laColorTable[0xab] = This._SystemColorToArgb(0x1b)
			m.laColorTable[0xac] = This._SystemColorToArgb(0x1c)
			m.laColorTable[0x0c] = This._SystemColorToArgb(0x11)
			m.laColorTable[0x0d] = This._SystemColorToArgb(13)
			m.laColorTable[0x0e] = This._SystemColorToArgb(14)
			m.laColorTable[0x0f] = This._SystemColorToArgb(0x1a)
			m.laColorTable[0x10] = This._SystemColorToArgb(11)
			m.laColorTable[0x11] = This._SystemColorToArgb(3)
			m.laColorTable[0x12] = This._SystemColorToArgb(0x13)
			m.laColorTable[0x13] = This._SystemColorToArgb(0x18)
			m.laColorTable[0x14] = This._SystemColorToArgb(0x17)
			m.laColorTable[0x15] = This._SystemColorToArgb(4)
			m.laColorTable[0xad] = This._SystemColorToArgb(30)
			m.laColorTable[0xae] = This._SystemColorToArgb(0x1d)
			m.laColorTable[0x16] = This._SystemColorToArgb(7)
			m.laColorTable[0x17] = This._SystemColorToArgb(0)
			m.laColorTable[0x18] = This._SystemColorToArgb(5)
			m.laColorTable[0x19] = This._SystemColorToArgb(6)
			m.laColorTable[0x1a] = This._SystemColorToArgb(8)
	ENDFUNC

ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCPEN
DEFINE CLASS xfcPen AS xfcgpobject
*************************************************************************
*************************************************************************
*************************************************************************
	Alignment = 0	&& Gets or sets the alignment for this Pen object.
	BaseName = "Pen"
	Brush = 0	&& Gets or sets the Brush object that determines attributes of this Pen object.
	Color = 0	&& Gets or sets the color of this Pen object.
	CustomEndCap = 0	&& Gets or sets a custom cap to use at the end of lines drawn with this Pen object.
	CustomStartCap = 0	&& Gets or sets a custom cap to use at the beginning of lines drawn with this Pen object.
	DashCap = 0	&& Gets or sets the cap style used at the end of the dashes that make up dashed lines drawn with this Pen object.
	DashOffset = 0	&& Gets or sets the distance from the start of a line to the beginning of a dash pattern.
	DashStyle = 0	&& Gets or sets the style used for dashed lines drawn with this Pen object.
	EndCap = 0	&& Gets or sets the cap style used at the end of lines drawn with this Pen object.
	lastresult = 0
	LineJoin = 0	&& Gets or sets the join style for the ends of two consecutive lines drawn with this Pen object.
	MiterLimit = 0	&& Gets or sets the limit of the thickness of the join on a mitered corner.
	PenType = 0	&& Gets the style of lines drawn with this Pen object.
	StartCap = 0	&& Gets or sets the cap style used at the beginning of lines drawn with this Pen object.
	Transform = 0	&& Gets or sets the geometric transformation for this Pen object.
	PROTECTED _brush
	_brush = .NULL.
	PROTECTED _color
	_color = .NULL.
	PROTECTED _compoundarray
	_compoundarray = (0h)
	PROTECTED _immutable
	_immutable = .F.
	DIMENSION CompoundArray[1]
	** Gets or sets an array values that specify a compound pen. A compound pen draws a compound line made up of parallel lines and spaces.

	DIMENSION DashPattern[1]
	** Gets or sets an array of custom dashes and spaces.

 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcPen.Pen
	**
	** Initializes a new instance of the Pen class with the specified color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**	2006/05/04: BDurban - Modified to accept a number for the color
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.Pen%28vs.80%29.aspx
	** Parameters:
	**  Brush brush
	**  Color color
	**  Brush brush, float width
	**  Color color, float width
	*********************************************************************
	LPARAMETERS toColor AS xfcColor, ;
					tnWidth
	*********** toColor AS xfcColor, tlImmutable
	*********** toBrush AS xfcPen [,tnWidth]
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lhPen, llImmutable
			m.lhPen = 0
		
			DODEFAULT()
			
			IF VARTYPE(m.tnWidth) = "L"
				This._immutable = m.tnWidth
				m.tnWidth = 1.0		&& default to a pen width of 1.0
			ELSE
				m.tnWidth = m.tnWidth+0.0
			ENDIF
			
			DO CASE
			CASE VARTYPE(m.toColor) = "O" AND m.toColor.BaseName = "Color"
				This.SetStatus(xfcGdipCreatePen1(m.toColor.Argb, m.tnWidth, UnitWorld, @lhPen))
				This._color = m.toColor
				
			CASE VARTYPE(m.toColor) = "O" AND "Brush" $ m.toColor.BaseName
				This.SetStatus(xfcGdipCreatePen2(m.toColor.Handle, m.tnWidth, UnitWorld, @lhPen))
				
			OTHERWISE
				This.SetStatus(xfcGdipCreatePen1( EVL(m.toColor,ARGB_Black), m.tnWidth, UnitWorld, @lhPen))
			ENDCASE
			
			This.Handle = m.lhPen
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcPen.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipDeletePen(This.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS toColorOrBrush AS xfcBrush, tnWidth
		
		RETURN CREATEOBJECT(This.Class, m.toColorOrBrush, m.tnWidth)
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Alignment_ACCESS
	*********************************************************************
	** Property: Alignment (Access)
	**
	** Gets or sets the alignment for this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.Alignment%28vs.80%29.aspx
	** Returns: PenAlignment
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liPenAlignment
		m.liPenAlignment = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenMode(This.Handle, @liPenAlignment))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liPenAlignment
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Alignment_ASSIGN
	*********************************************************************
	** Property: Alignment (Assign)
	**
	** Gets or sets the alignment for this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiPenAlignment
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipSetPenMode(This.Handle, m.tiPenAlignment))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Brush_ACCESS
	*********************************************************************
	** Property: Brush (Access)
	**
	** Gets or sets the Brush object that determines attributes of this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/26: BDurban - Modified to check for brush type and to use Brush property
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.Brush%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lhBrush, liPenType
		m.lhBrush = 0
		This._brush = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenBrushFill(This.Handle, @lhBrush))
			
			IF(m.lhBrush <> 0)
				m.liPenType = This.PenType
				DO CASE
				CASE m.liPenType = PenTypeSolidColor
					This._brush = CREATEOBJECT("xfcSolidBrush")
				CASE m.liPenType = PenTypeHatchFill
					This._brush = CREATEOBJECT("xfcHatchBrush")
				CASE m.liPenType = PenTypeTextureFill
					This._brush = CREATEOBJECT("xfcTextureBrush")
				CASE m.liPenType = PenTypePathGradient
					This._brush = CREATEOBJECT("xfcPathGradientBrush")
				CASE m.liPenType = PenTypeLinearGradient
					This._brush = CREATEOBJECT("xfcLinearGradientBrush")
				OTHERWISE
					This._brush = CREATEOBJECT("xfcBrush")
				ENDCASE
				This._brush.Handle = m.lhBrush
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN This._brush
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Brush_ASSIGN
	*********************************************************************
	** Property: Brush (Assign)
	**
	** Gets or sets the Brush object that determines attributes of this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toBrush AS xfcBrush
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			IF VARTYPE(m.toBrush) = "O"
				This.SetStatus(xfcGdipSetPenBrushFill(This.Handle, m.toBrush.Handle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcPen.Clone
	**
	** Creates an exact copy of this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.Clone%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: object
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loPen AS xfcPen, lhPen
		m.lhPen = 0
		m.loPen = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipClonePen(This.Handle, @lhPen))
			IF(m.lhobject <> 0)
				m.loobject = CREATEOBJECT("xfcPen")
				m.loPen.Handle = m.lhPen
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION Color_ACCESS
	*********************************************************************
	** Property: Color (Access)
	**
	** Gets or sets the color of this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/26: BDurban - Changed to use Color property
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.Color%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liArgb
		m.liArgb = 0
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(This._color) <> "O"
				This.SetStatus(xfcGdipGetPenColor(This.Handle, @liArgb))
				This._color = CREATEOBJECT("xfcColor", m.liArgb)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This._color
	ENDFUNC


	*********************************************************************
	FUNCTION Color_ASSIGN
	*********************************************************************
	** Property: Color (Assign)
	**
	** Gets or sets the color of this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
			
			IF VARTYPE(m.toColor) = "O"
				This.SetStatus(xfcGdipSetPenColor(This.Handle, toColor.Argb))
				This._color = m.toColor
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION CompoundArray_ACCESS
	*********************************************************************
	** Property: CompoundArray (Access)
	**
	** Gets or sets an array values that specify a compound pen. A compound pen draws a
	** compound line made up of parallel lines and spaces.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/13: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.CompoundArray%28vs.80%29.aspx
	** Returns: float[]
	*********************************************************************
	LPARAMETERS tiIndex
		
		*!ToDo: Test this function
		
		LOCAL leValue, liCount, lqCompoundArray
		m.leValue = 0.0
		m.liCount = 0
		
		LOCAL loExc AS Exception
		TRY
			m.tiIndex = NVL(m.tiIndex,1)
			
			This.SetStatus(xfcGdipGetPenCompoundCount(This.Handle, @liCount))
			m.lqCompoundArray = REPLICATE(EMPTY_FLOAT, m.liCount)	
			This.SetStatus(xfcGdipGetPenCompoundArray(This.Handle, @lqCompoundArray, m.liCount))
			
			DO CASE
			CASE VARTYPE(m.tiIndex) = "N"
				IF m.tiIndex > m.liCount
					*!ToDo: Handle Error
					EXIT
				ENDIF
				m.leValue = CTOBIN(SUBSTR(lqCompoundArray, (m.tiIndex-1)*4+1, 4), "N")
				
		** Special case, return the binary structure if we receive a VarBinary parameter
			CASE VARTYPE(m.tiIndex) = "Q"
				m.leValue = m.lqCompoundArray
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.leValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION CompoundArray_ASSIGN
	*********************************************************************
	** Property: CompoundArray (Assign)
	**
	** Gets or sets an array values that specify a compound pen. A compound pen draws a
	** compound line made up of parallel lines and spaces.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/13: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue, tiIndex
		
		*!ToDo: Test this function
		
		LOCAL lqCompoundArray, liCount, liSize
		m.liCount = -1
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			DO CASE
		** If VarBinary was passed. Use it as the entire array
			CASE VARTYPE(m.tnValue) = "Q"
				*!ToDo: Check the length of this binary string
				m.lqCompoundArray = m.tnValue
				m.liCount = INT(LEN(m.lqCompoundArray) / SIZEOF_FLOAT)
				DIMENSION This.CompoundArray[MAX(m.liCount,1)]
				This.CompoundArray = IIF(m.liCount=0, EMPTY_VFPARRAY, 0.0)
			
		** If numeric, set the individual element
			CASE VARTYPE(m.tnValue) = "N"
				m.tiIndex = NVL(m.tiIndex, 1)
				m.liCount = 0
				This.SetStatus(xfcGdipGetPenCompoundCount(This.Handle, @liCount))
				m.lqCompoundArray = REPLICATE(EMPTY_FLOAT, m.liCount)
				This.SetStatus(xfcGdipGetPenCompoundArray(This.Handle, @lqCompoundArray, m.liCount))
				
			** Resize the array if needed
				m.liSize = MAX(ALEN(This.CompoundArray,1), m.tiIndex)
				DIMENSION This.CompoundArray[m.liSize]
				IF m.liSize <> m.liCount
					m.liCount = m.liSize
					m.lqCompoundArray = PADR(m.lqCompoundArray, m.liCount*SIZEOF_FLOAT, EMPTY_FLOAT)
				ENDIF
				
			** Update the individual element
				m.lqCompoundArray = STUFF(m.lqCompoundArray, (m.tiIndex-1)*SIZEOF_FLOAT+1, SIZEOF_FLOAT, BINTOC(m.tnValue,"F"))
				
			OTHERWISE
				*!ToDo: Error
				EXIT
			ENDCASE
		
			This.SetStatus(xfcGdipSetPenCompoundArray(This.Handle, @lqCompoundArray, m.liCount))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION CustomEndCap_ACCESS
	*********************************************************************
	** Property: CustomEndCap (Access)
	**
	** Gets or sets a custom cap to use at the end of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.CustomEndCap%28vs.80%29.aspx
	** Returns: CustomLineCap
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loCustomLineCap, lhCustomLineCap
		m.lhCustomLineCap = 0
		m.loCustomLineCap = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenCustomEndCap(This.Handle, @lhCustomLineCap))
			IF(m.lhCustomLineCap <> 0)
				m.loCustomLineCap = NEWOBJECT("xfcCustomLineCap", XFCCLASS_DRAWING2D)
				m.loCustomLineCap.Handle = m.lhCustomLineCap
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loCustomLineCap
	ENDFUNC


	*********************************************************************
	FUNCTION CustomEndCap_ASSIGN
	*********************************************************************
	** Property: CustomEndCap (Assign)
	**
	** Gets or sets a custom cap to use at the end of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**  2006/08/01: BDurban - Added support for NULLS
	**  2008/09/30: BDurban/CChalom - Passing a zero to "SetCustom...Cap" creates a GDI+ error. Ignoring NULLs for now
	*********************************************************************
	LPARAMETERS toCustomLineCap AS xfcCustomLineCap
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF ISNULL(m.toCustomLineCap)
				EXIT
			ENDIF
			
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			LOCAL lhLineCap
			m.lhLineCap = m.toCustomLineCap.Handle
			This.SetStatus(xfcGdipSetPenCustomEndCap(This.Handle, m.lhLineCap))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION CustomStartCap_ACCESS
	*********************************************************************
	** Property: CustomStartCap (Access)
	**
	** Gets or sets a custom cap to use at the beginning of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.CustomStartCap%28vs.80%29.aspx
	** Returns: CustomLineCap
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loCustomLineCap, lhCustomLineCap
		m.lhCustomLineCap = 0
		m.loCustomLineCap = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenCustomStartCap(This.Handle, @lhCustomLineCap))
			IF(m.lhCustomLineCap <> 0)
				m.loCustomLineCap = NEWOBJECT("xfcCustomLineCap", XFCCLASS_DRAWING2D)
				m.loCustomLineCap.Handle = m.lhCustomLineCap
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loCustomLineCap
	ENDFUNC


	*********************************************************************
	FUNCTION CustomStartCap_ASSIGN
	*********************************************************************
	** Property: CustomStartCap (Assign)
	**
	** Gets or sets a custom cap to use at the beginning of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**  2006/08/01: BDurban - Added support for NULL
	**  2008/09/30: BDurban/CChalom - Passing a zero to "SetCustom...Cap" creates a GDI+ error. Ignoring NULLs for now
	*********************************************************************
	LPARAMETERS toCustomLineCap AS xfcCustomLineCap
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF ISNULL(m.toCustomLineCap)
				EXIT
			ENDIF
			
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			LOCAL lhLineCap
			m.lhLineCap = m.toCustomLineCap.Handle
			This.SetStatus(xfcGdipSetPenCustomStartCap(This.Handle, m.lhLineCap))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION DashCap_ACCESS
	*********************************************************************
	** Property: DashCap (Access)
	**
	** Gets or sets the cap style used at the end of the dashes that make up dashed lines
	** drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.DashCap%28vs.80%29.aspx
	** Returns: DashCap
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liDashCap
		m.liDashCap = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenDashCap197819(This.Handle, @liDashCap))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liDashCap
	ENDFUNC


	*********************************************************************
	FUNCTION DashCap_ASSIGN
	*********************************************************************
	** Property: DashCap (Assign)
	**
	** Gets or sets the cap style used at the end of the dashes that make up dashed lines
	** drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiDashCap
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipSetPenDashCap197819(This.Handle, m.tiDashCap))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION DashOffset_ACCESS
	*********************************************************************
	** Property: DashOffset (Access)
	**
	** Gets or sets the distance from the start of a line to the beginning of a dash pattern.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.DashOffset%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenDashOffset(This.Handle, @lnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION DashOffset_ASSIGN
	*********************************************************************
	** Property: DashOffset (Assign)
	**
	** Gets or sets the distance from the start of a line to the beginning of a dash pattern.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipSetPenDashOffset(This.Handle, m.tnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION DashPattern_ACCESS
	*********************************************************************
	** Property: DashPattern (Access)
	**
	** Gets or sets an array of custom dashes and spaces.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.DashPattern%28vs.80%29.aspx
	** Returns: float[]
	*********************************************************************
	LPARAMETERS tnIndex
		
		*!ToDo: Test this function
		
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lqDashes, liCount
			m.liCount = 0
			
			This.SetStatus(xfcGdipGetPenDashCount(This.Handle, @liCount))
			m.lqDashes = REPLICATE(EMPTY_FLOAT,m.liCount)
			This.SetStatus(xfcGdipGetPenDashArray(This.Handle, @lqDashes, m.liCount))
			
			DIMENSION This.DashPattern[MAX(m.liCount,1)]
			This.DashPattern = 0.0
			
			IF m.liCount > 0
				IF VARTYPE(m.tnIndex) = "Q"
					m.lnValue = m.lqDashes
				ELSE
					m.tnIndex = NVL(m.tnIndex, 1)
					IF m.tnIndex > m.liCount
						*! ToDo: Error
					ENDIF
					m.lnValue = CTOBIN(SUBSTR(m.lqDashes, (m.tnIndex-1)*4+1, 4), "n")
				ENDIF
			ELSE
				m.lnValue = NULL
			ENDIF
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION DashPattern_ASSIGN
	*********************************************************************
	** Property: DashPattern (Assign)
	**
	** Gets or sets an array of custom dashes and spaces.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue, tnIndex
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			LOCAL lqDashes, liCount
			m.lqDashes = 0h
			m.liCount = 0
			
			DO CASE
			CASE VARTYPE(m.tnValue) = "Q"
				m.lqDashes = m.tnValue
				m.liCount = LEN(m.lqDashes)/4
				This.SetStatus(xfcGdipSetPenDashArray(This.Handle, @lqDashes, m.liCount))
				DIMENSION This.DashPattern[MAX(m.liCount,1)]
				
			CASE VARTYPE(m.tnValue) = "N"
				This.SetStatus(xfcGdipGetPenDashCount(This.Handle, @liCount))
				m.lqDashes = REPLICATE(EMPTY_FLOAT, m.liCount)
				This.SetStatus(xfcGdipGetPenDashArray(This.Handle, @lqDashes, m.liCount))
				m.tnIndex = NVL(m.tnIndex,1)
				IF m.liCount < m.tnIndex
					m.liCount = m.tnIndex
					m.lqDashes = PADR(m.lqDashes, m.liCount*4, 0h00)
					DIMENSION This.DashPattern[MAX(m.liCount,1)]
				ENDIF
				m.lqDashes = STUFF(m.lqDashes, (m.tnIndex-1)*4+1, 4, BINTOC(m.tnValue, "f"))
				This.SetStatus(xfcGdipSetPenDashArray(This.Handle, @lqDashes, m.liCount))
				
			ENDCASE
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION DashStyle_ACCESS
	*********************************************************************
	** Property: DashStyle (Access)
	**
	** Gets or sets the style used for dashed lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.DashStyle%28vs.80%29.aspx
	** Returns: DashStyle
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liDashStyle
		m.liDashStyle = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenDashStyle(This.Handle, @liDashstyle))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liDashStyle
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION DashStyle_ASSIGN
	*********************************************************************
	** Property: DashStyle (Assign)
	**
	** Gets or sets the style used for dashed lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiDashStyle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipSetPenDashStyle(This.Handle, m.tiDashStyle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION EndCap_ACCESS
	*********************************************************************
	** Property: EndCap (Access)
	**
	** Gets or sets the cap style used at the end of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.EndCap%28vs.80%29.aspx
	** Returns: LineCap
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liLineCap
		m.liLineCap = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenEndCap(This.Handle, @liLineCap))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liLineCap
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION EndCap_ASSIGN
	*********************************************************************
	** Property: EndCap (Assign)
	**
	** Gets or sets the cap style used at the end of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiLineCap
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipSetPenEndCap(This.Handle, m.tiLineCap))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION LineJoin_ACCESS
	*********************************************************************
	** Property: LineJoin (Access)
	**
	** Gets or sets the join style for the ends of two consecutive lines drawn with this
	** Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.LineJoin%28vs.80%29.aspx
	** Returns: LineJoin
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liLineJoin
		m.liLineJoin = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenLineJoin(This.Handle, @liLineJoin))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liLineJoin
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION LineJoin_ASSIGN
	*********************************************************************
	** Property: LineJoin (Assign)
	**
	** Gets or sets the join style for the ends of two consecutive lines drawn with this
	** Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiLineJoin
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipSetPenLineJoin(This.Handle, m.tiLineJoin))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION MiterLimit_ACCESS
	*********************************************************************
	** Property: MiterLimit (Access)
	**
	** Gets or sets the limit of the thickness of the join on a mitered corner.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.MiterLimit%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL lnMiterLimit
		m.lnMiterLimit = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenMiterLimit(This.Handle, @lnMiterLimit))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnMiterLimit
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION MiterLimit_ASSIGN
	*********************************************************************
	** Property: MiterLimit (Assign)
	**
	** Gets or sets the limit of the thickness of the join on a mitered corner.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnMiterLimit
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipSetPenMiterLimit(This.Handle, m.tnMiterLimit))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION MultiplyTransform
	*********************************************************************
	** Method: xfcPen.MultiplyTransform
	**
	** Multiplies the transformation matrix for this Pen object by the specified Matrix.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.MultiplyTransform%28vs.80%29.aspx
	** Parameters:
	**  Matrix matrix
	**  Matrix matrix, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS toMatrix AS xfcMatrix, tiOrder AS EnumMatrixOrder
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF PCOUNT() < 2
				m.tiOrder = 0	&& MatrixOrderPrepend
			ENDIF
			This.SetStatus(xfcGdipMultiplyPenTransform(This.Handle, m.toMatrix.Handle, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION PenType_ACCESS
	*********************************************************************
	** Property: PenType (Access)
	**
	** Gets the style of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.PenType%28vs.80%29.aspx
	** Returns: PenType
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liPenType
		m.liPenType = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenFillType(This.Handle, @liPenType))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liPenType
	ENDFUNC


	*********************************************************************
	FUNCTION ResetTransform
	*********************************************************************
	** Method: xfcPen.ResetTransform
	**
	** Resets the geometric transformation matrix for this Pen object to identity.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.ResetTransform%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: void
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipResetPenTransform(This.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION RotateTransform
	*********************************************************************
	** Method: xfcPen.RotateTransform
	**
	** Rotates the local geometric transformation by the specified angle. This method prepends
	** the rotation to the transformation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.RotateTransform%28vs.80%29.aspx
	** Parameters:
	**  float angle
	**  float angle, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnAngle, tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF PCOUNT() < 2
				m.tiOrder = 0	&& MatrixOrderPrepend
			ENDIF
			This.SetStatus(xfcGdipRotatePenTransform(This.Handle, m.tnAngle, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ScaleTransform
	*********************************************************************
	** Method: xfcPen.ScaleTransform
	**
	** Scales the local geometric transformation by the specified factors. This method
	** prepends the scaling matrix to the transformation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.ScaleTransform%28vs.80%29.aspx
	** Parameters:
	**  float sx, float sy
	**  float sx, float sy, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnSx, tnSy, tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF PCOUNT() < 3
				m.tiOrder = 0	&& MatrixOrderPrepend
			ENDIF
			This.SetStatus(xfcGdipScalePenTransform(This.Handle, m.tnSx, m.tnSy, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION SetLineCap
	*********************************************************************
	** Method: xfcPen.SetLineCap
	**
	** Sets the values that determine the style of cap used to end lines drawn by this
	** Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.SetLineCap%28vs.80%29.aspx
	** Parameters:
	**  LineCap startCap, LineCap endCap, DashCap dashCap
	** Returns: void
	*********************************************************************
	LPARAMETERS tiStartCap AS EnumLineCap, tiEndCap AS EnumLineCap, tiDashCap AS EnumDashCap
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetPenLineCap197819(This.Handle, m.tiStartCap, m.tiEndCap, m.tiDashCap))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION StartCap_ACCESS
	*********************************************************************
	** Property: StartCap (Access)
	**
	** Gets or sets the cap style used at the beginning of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.StartCap%28vs.80%29.aspx
	** Returns: LineCap
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liLineCap
		m.liLineCap = 0
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipGetPenStartCap(This.Handle, @liLineCap))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liLineCap
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION StartCap_ASSIGN
	*********************************************************************
	** Property: StartCap (Assign)
	**
	** Gets or sets the cap style used at the beginning of lines drawn with this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiLineCap
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetPenStartCap(This.Handle, m.tiLineCap))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Transform_ACCESS
	*********************************************************************
	** Property: Transform (Access)
	**
	** Gets or sets the geometric transformation for this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.Transform%28vs.80%29.aspx
	** Returns: Matrix
	*********************************************************************
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		
		LOCAL loMatrix, lhMatrix
		m.lhMatrix = 0
		m.loMatrix = NULL
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipGetPenTransform(This.Handle, m.lhMatrix))
				IF(m.lhMatrix <> 0)
					m.loMatrix = NEWOBJECT("xfcMatrix", XFCCLASS_DRAWING2D)
					m.loMatrix.Handle = m.lhMatrix
				ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loMatrix
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Transform_ASSIGN
	*********************************************************************
	** Property: Transform (Assign)
	**
	** Gets or sets the geometric transformation for this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**  2006/08/01: BDurban - Added support for NULL
	*********************************************************************
	LPARAMETERS toMatrix
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			LOCAL lhMatrix
			m.lhMatrix = IIF(ISNULL(toMatrix), 0, m.toMatrix.Handle)
			This.SetStatus(xfcGdipSetPenTransform(This.Handle, m.lhMatrix))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION TranslateTransform
	*********************************************************************
	** Method: xfcPen.TranslateTransform
	**
	** Translates the local geometric transformation by the specified dimensions. This
	** method prepends the translation to the transformation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.TranslateTransform%28vs.80%29.aspx
	** Parameters:
	**  float dx, float dy
	**  float dx, float dy, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnDx, tnDy, tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF PCOUNT() < 3
				m.tiOrder = 0	&& MatrixOrderPrepend
			ENDIF
		
			This.SetStatus(xfcGdipTranslatePenTransform(This.Handle, m.tnDx, m.tnDy, m.tiOrder))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Width_ACCESS
	*********************************************************************
	** Property: Width (Access)
	**
	** Gets or sets the width of this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pen.Width%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		LOCAL lnValue
		m.lnValue = 0.0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetPenWidth(This.Handle, @lnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.lnValue
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION Width_ASSIGN
	*********************************************************************
	** Property: Width (Assign)
	**
	** Gets or sets the width of this Pen object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue
		LOCAL loExc AS Exception
		TRY
			IF This._immutable
				ERROR "Changes cannot be made to Pen because permissions are not valid."
			ENDIF
		
			This.SetStatus(xfcGdipSetPenWidth(This.Handle, m.tnValue))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="multiplytransform" type="method" display="MultiplyTransform"/>]+;
		[<memberdata name="resettransform" type="method" display="ResetTransform"/>]+;
		[<memberdata name="rotatetransform" type="method" display="RotateTransform"/>]+;
		[<memberdata name="scaletransform" type="method" display="ScaleTransform"/>]+;
		[<memberdata name="setlinecap" type="method" display="SetLineCap"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="translatetransform" type="method" display="TranslateTransform"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="alignment" type="property" display="Alignment"/>]+;
		[<memberdata name="brush" type="property" display="Brush"/>]+;
		[<memberdata name="color" type="property" display="Color"/>]+;
		[<memberdata name="compoundarray" type="property" display="CompoundArray"/>]+;
		[<memberdata name="customendcap" type="property" display="CustomEndCap"/>]+;
		[<memberdata name="customstartcap" type="property" display="CustomStartCap"/>]+;
		[<memberdata name="dashcap" type="property" display="DashCap"/>]+;
		[<memberdata name="dashoffset" type="property" display="DashOffset"/>]+;
		[<memberdata name="dashpattern" type="property" display="DashPattern"/>]+;
		[<memberdata name="dashstyle" type="property" display="DashStyle"/>]+;
		[<memberdata name="endcap" type="property" display="EndCap"/>]+;
		[<memberdata name="linejoin" type="property" display="LineJoin"/>]+;
		[<memberdata name="miterlimit" type="property" display="MiterLimit"/>]+;
		[<memberdata name="pentype" type="property" display="PenType"/>]+;
		[<memberdata name="startcap" type="property" display="StartCap"/>]+;
		[<memberdata name="transform" type="property" display="Transform"/>]+;
		[<memberdata name="width" type="property" display="Width"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCPENS
DEFINE CLASS xfcPens AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	AliceBlue = .NULL.	&& A system defined Pen object with a width of 1
	AntiqueWhite = .NULL.	&& A system defined Pen object with a width of 1
	Aqua = .NULL.	&& A system defined Pen object with a width of 1
	Aquamarine = .NULL.	&& A system defined Pen object with a width of 1
	Azure = .NULL.	&& A system defined Pen object with a width of 1
	BaseName = "Pens"
	Beige = .NULL.	&& A system defined Pen object with a width of 1
	Bisque = .NULL.	&& A system defined Pen object with a width of 1
	Black = .NULL.	&& A system defined Pen object with a width of 1
	BlanchedAlmond = .NULL.	&& A system defined Pen object with a width of 1
	Blue = .NULL.	&& A system defined Pen object with a width of 1
	BlueViolet = .NULL.	&& A system defined Pen object with a width of 1
	Brown = .NULL.	&& A system defined Pen object with a width of 1
	BurlyWood = .NULL.	&& A system defined Pen object with a width of 1
	CadetBlue = .NULL.	&& A system defined Pen object with a width of 1
	Chartreuse = .NULL.	&& A system defined Pen object with a width of 1
	Chocolate = .NULL.	&& A system defined Pen object with a width of 1
	Coral = .NULL.	&& A system defined Pen object with a width of 1
	CornflowerBlue = .NULL.	&& A system defined Pen object with a width of 1
	Cornsilk = .NULL.	&& A system defined Pen object with a width of 1
	Crimson = .NULL.	&& A system defined Pen object with a width of 1
	Cyan = .NULL.	&& A system defined Pen object with a width of 1
	DarkBlue = .NULL.	&& A system defined Pen object with a width of 1
	DarkCyan = .NULL.	&& A system defined Pen object with a width of 1
	DarkGoldenrod = .NULL.	&& A system defined Pen object with a width of 1
	DarkGray = .NULL.	&& A system defined Pen object with a width of 1
	DarkGreen = .NULL.	&& A system defined Pen object with a width of 1
	DarkKhaki = .NULL.	&& A system defined Pen object with a width of 1
	DarkMagenta = .NULL.	&& A system defined Pen object with a width of 1
	DarkOliveGreen = .NULL.	&& A system defined Pen object with a width of 1
	DarkOrange = .NULL.	&& A system defined Pen object with a width of 1
	DarkOrchid = .NULL.	&& A system defined Pen object with a width of 1
	DarkRed = .NULL.	&& A system defined Pen object with a width of 1
	DarkSalmon = .NULL.	&& A system defined Pen object with a width of 1
	DarkSeaGreen = .NULL.	&& A system defined Pen object with a width of 1
	DarkSlateBlue = .NULL.	&& A system defined Pen object with a width of 1
	DarkSlateGray = .NULL.	&& A system defined Pen object with a width of 1
	DarkTurquoise = .NULL.	&& A system defined Pen object with a width of 1
	DarkViolet = .NULL.	&& A system defined Pen object with a width of 1
	DeepPink = .NULL.	&& A system defined Pen object with a width of 1
	DeepSkyBlue = .NULL.	&& A system defined Pen object with a width of 1
	DimGray = .NULL.	&& A system defined Pen object with a width of 1
	DodgerBlue = .NULL.	&& A system defined Pen object with a width of 1
	Firebrick = .NULL.	&& A system defined Pen object with a width of 1
	FloralWhite = .NULL.	&& A system defined Pen object with a width of 1
	ForestGreen = .NULL.	&& A system defined Pen object with a width of 1
	Fuchsia = .NULL.	&& A system defined Pen object with a width of 1
	Gainsboro = .NULL.	&& A system defined Pen object with a width of 1
	GhostWhite = .NULL.	&& A system defined Pen object with a width of 1
	Gold = .NULL.	&& A system defined Pen object with a width of 1
	Goldenrod = .NULL.	&& A system defined Pen object with a width of 1
	Gray = .NULL.	&& A system defined Pen object with a width of 1
	Green = .NULL.	&& A system defined Pen object with a width of 1
	GreenYellow = .NULL.	&& A system defined Pen object with a width of 1
	Honeydew = .NULL.	&& A system defined Pen object with a width of 1
	HotPink = .NULL.	&& A system defined Pen object with a width of 1
	IndianRed = .NULL.	&& A system defined Pen object with a width of 1
	Indigo = .NULL.	&& A system defined Pen object with a width of 1
	Ivory = .NULL.	&& A system defined Pen object with a width of 1
	Khaki = .NULL.	&& A system defined Pen object with a width of 1
	Lavender = .NULL.	&& A system defined Pen object with a width of 1
	LavenderBlush = .NULL.	&& A system defined Pen object with a width of 1
	LawnGreen = .NULL.	&& A system defined Pen object with a width of 1
	LemonChiffon = .NULL.	&& A system defined Pen object with a width of 1
	LightBlue = .NULL.	&& A system defined Pen object with a width of 1
	LightCoral = .NULL.	&& A system defined Pen object with a width of 1
	LightCyan = .NULL.	&& A system defined Pen object with a width of 1
	LightGoldenrodYellow = .NULL.
	** A system defined Pen object with a width of 1
	LightGray = .NULL.	&& A system defined Pen object with a width of 1
	LightGreen = .NULL.	&& A system defined Pen object with a width of 1
	LightPink = .NULL.	&& A system defined Pen object with a width of 1
	LightSalmon = .NULL.	&& A system defined Pen object with a width of 1
	LightSeaGreen = .NULL.	&& A system defined Pen object with a width of 1
	LightSkyBlue = .NULL.	&& A system defined Pen object with a width of 1
	LightSlateGray = .NULL.	&& A system defined Pen object with a width of 1
	LightSteelBlue = .NULL.	&& A system defined Pen object with a width of 1
	LightYellow = .NULL.	&& A system defined Pen object with a width of 1
	Lime = .NULL.	&& A system defined Pen object with a width of 1
	LimeGreen = .NULL.	&& A system defined Pen object with a width of 1
	Linen = .NULL.	&& A system defined Pen object with a width of 1
	Magenta = .NULL.	&& A system defined Pen object with a width of 1
	Maroon = .NULL.	&& A system defined Pen object with a width of 1
	MediumAquamarine = .NULL.	&& A system defined Pen object with a width of 1
	MediumBlue = .NULL.	&& A system defined Pen object with a width of 1
	MediumOrchid = .NULL.	&& A system defined Pen object with a width of 1
	MediumPurple = .NULL.	&& A system defined Pen object with a width of 1
	MediumSeaGreen = .NULL.	&& A system defined Pen object with a width of 1
	MediumSlateBlue = .NULL.	&& A system defined Pen object with a width of 1
	MediumSpringGreen = .NULL.
	** A system defined Pen object with a width of 1
	MediumTurquoise = .NULL.	&& A system defined Pen object with a width of 1
	MediumVioletRed = .NULL.	&& A system defined Pen object with a width of 1
	MidnightBlue = .NULL.	&& A system defined Pen object with a width of 1
	MintCream = .NULL.	&& A system defined Pen object with a width of 1
	MistyRose = .NULL.	&& A system defined Pen object with a width of 1
	Moccasin = .NULL.	&& A system defined Pen object with a width of 1
	NavajoWhite = .NULL.	&& A system defined Pen object with a width of 1
	Navy = .NULL.	&& A system defined Pen object with a width of 1
	OldLace = .NULL.	&& A system defined Pen object with a width of 1
	Olive = .NULL.	&& A system defined Pen object with a width of 1
	OliveDrab = .NULL.	&& A system defined Pen object with a width of 1
	Orange = .NULL.	&& A system defined Pen object with a width of 1
	OrangeRed = .NULL.	&& A system defined Pen object with a width of 1
	Orchid = .NULL.	&& A system defined Pen object with a width of 1
	PaleGoldenrod = .NULL.	&& A system defined Pen object with a width of 1
	PaleGreen = .NULL.	&& A system defined Pen object with a width of 1
	PaleTurquoise = .NULL.	&& A system defined Pen object with a width of 1
	PaleVioletRed = .NULL.	&& A system defined Pen object with a width of 1
	PapayaWhip = .NULL.	&& A system defined Pen object with a width of 1
	PeachPuff = .NULL.	&& A system defined Pen object with a width of 1
	Peru = .NULL.	&& A system defined Pen object with a width of 1
	Pink = .NULL.	&& A system defined Pen object with a width of 1
	Plum = .NULL.	&& A system defined Pen object with a width of 1
	PowderBlue = .NULL.	&& A system defined Pen object with a width of 1
	Purple = .NULL.	&& A system defined Pen object with a width of 1
	Red = .NULL.	&& A system defined Pen object with a width of 1
	RosyBrown = .NULL.	&& A system defined Pen object with a width of 1
	RoyalBlue = .NULL.	&& A system defined Pen object with a width of 1
	SaddleBrown = .NULL.	&& A system defined Pen object with a width of 1
	Salmon = .NULL.	&& A system defined Pen object with a width of 1
	SandyBrown = .NULL.	&& A system defined Pen object with a width of 1
	SeaGreen = .NULL.	&& A system defined Pen object with a width of 1
	SeaShell = .NULL.	&& A system defined Pen object with a width of 1
	Sienna = .NULL.	&& A system defined Pen object with a width of 1
	Silver = .NULL.	&& A system defined Pen object with a width of 1
	SkyBlue = .NULL.	&& A system defined Pen object with a width of 1
	SlateBlue = .NULL.	&& A system defined Pen object with a width of 1
	SlateGray = .NULL.	&& A system defined Pen object with a width of 1
	Snow = .NULL.	&& A system defined Pen object with a width of 1
	SpringGreen = .NULL.	&& A system defined Pen object with a width of 1
	SteelBlue = .NULL.	&& A system defined Pen object with a width of 1
	Tan = .NULL.	&& A system defined Pen object with a width of 1
	Teal = .NULL.	&& A system defined Pen object with a width of 1
	Thistle = .NULL.	&& A system defined Pen object with a width of 1
	Tomato = .NULL.	&& A system defined Pen object with a width of 1
	Transparent = .NULL.	&& A system defined Pen object with a width of 1
	Turquoise = .NULL.	&& A system defined Pen object with a width of 1
	Violet = .NULL.	&& A system defined Pen object with a width of 1
	Wheat = .NULL.	&& A system defined Pen object with a width of 1
	White = .NULL.	&& A system defined Pen object with a width of 1
	WhiteSmoke = .NULL.	&& A system defined Pen object with a width of 1
	Yellow = .NULL.	&& A system defined Pen object with a width of 1
	YellowGreen = .NULL.	&& A system defined Pen object with a width of 1

	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcPens.Pens
	**
	** Pens for all the standard colors. This class cannot be inherited.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/04: BDurban - Coded
	**  2006/08/26: BDurban - Added memberdata
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Pens%28vs.80%29.aspx
	*********************************************************************
		
		*!ToDo: Test this function
		
		DODEFAULT()
		
		#IFDEF USE_MEMBERDATA
			This._memberdata = [<VFPData>]+;
				[<memberdata name="aliceblue" display="AliceBlue"/>]+;
				[<memberdata name="antiquewhite" display="AntiqueWhite"/>]+;
				[<memberdata name="aqua" display="Aqua"/>]+;
				[<memberdata name="aquamarine" display="Aquamarine"/>]+;
				[<memberdata name="azure" display="Azure"/>]+;
				[<memberdata name="beige" display="Beige"/>]+;
				[<memberdata name="bisque" display="Bisque"/>]+;
				[<memberdata name="black" display="Black"/>]+;
				[<memberdata name="blanchedalmond" display="BlanchedAlmond"/>]+;
				[<memberdata name="blue" display="Blue"/>]+;
				[<memberdata name="blueviolet" display="BlueViolet"/>]+;
				[<memberdata name="brown" display="Brown"/>]+;
				[<memberdata name="burlywood" display="BurlyWood"/>]+;
				[<memberdata name="cadetblue" display="CadetBlue"/>]+;
				[<memberdata name="chartreuse" display="Chartreuse"/>]+;
				[<memberdata name="chocolate" display="Chocolate"/>]+;
				[<memberdata name="coral" display="Coral"/>]+;
				[<memberdata name="cornflowerblue" display="CornflowerBlue"/>]+;
				[<memberdata name="cornsilk" display="Cornsilk"/>]+;
				[<memberdata name="crimson" display="Crimson"/>]+;
				[<memberdata name="cyan" display="Cyan"/>]+;
				[<memberdata name="darkblue" display="DarkBlue"/>]+;
				[<memberdata name="darkcyan" display="DarkCyan"/>]+;
				[<memberdata name="darkgoldenrod" display="DarkGoldenrod"/>]+;
				[<memberdata name="darkgray" display="DarkGray"/>]+;
				[<memberdata name="darkgreen" display="DarkGreen"/>]+;
				[<memberdata name="darkkhaki" display="DarkKhaki"/>]+;
				[<memberdata name="darkmagenta" display="DarkMagenta"/>]+;
				[<memberdata name="darkolivegreen" display="DarkOliveGreen"/>]+;
				[<memberdata name="darkorange" display="DarkOrange"/>]+;
				[<memberdata name="darkorchid" display="DarkOrchid"/>]+;
				[<memberdata name="darkred" display="DarkRed"/>]+;
				[<memberdata name="darksalmon" display="DarkSalmon"/>]+;
				[<memberdata name="darkseagreen" display="DarkSeaGreen"/>]+;
				[<memberdata name="darkslateblue" display="DarkSlateBlue"/>]+;
				[<memberdata name="darkslategray" display="DarkSlateGray"/>]+;
				[<memberdata name="darkturquoise" display="DarkTurquoise"/>]+;
				[<memberdata name="darkviolet" display="DarkViolet"/>]+;
				[<memberdata name="deeppink" display="DeepPink"/>]+;
				[<memberdata name="deepskyblue" display="DeepSkyBlue"/>]+;
				[<memberdata name="dimgray" display="DimGray"/>]+;
				[<memberdata name="dodgerblue" display="DodgerBlue"/>]+;
				[<memberdata name="firebrick" display="Firebrick"/>]+;
				[<memberdata name="floralwhite" display="FloralWhite"/>]+;
				[<memberdata name="forestgreen" display="ForestGreen"/>]+;
				[<memberdata name="fuchsia" display="Fuchsia"/>]+;
				[<memberdata name="gainsboro" display="Gainsboro"/>]+;
				[<memberdata name="ghostwhite" display="GhostWhite"/>]+;
				[<memberdata name="gold" display="Gold"/>]+;
				[<memberdata name="goldenrod" display="Goldenrod"/>]+;
				[<memberdata name="gray" display="Gray"/>]+;
				[<memberdata name="green" display="Green"/>]+;
				[<memberdata name="greenyellow" display="GreenYellow"/>]+;
				[<memberdata name="honeydew" display="Honeydew"/>]+;
				[<memberdata name="hotpink" display="HotPink"/>]+;
				[<memberdata name="indianred" display="IndianRed"/>]+;
				[<memberdata name="indigo" display="Indigo"/>]+;
				[<memberdata name="ivory" display="Ivory"/>]+;
				[<memberdata name="khaki" display="Khaki"/>]+;
				[<memberdata name="lavender" display="Lavender"/>]+;
				[<memberdata name="lavenderblush" display="LavenderBlush"/>]+;
				[<memberdata name="lawngreen" display="LawnGreen"/>]+;
				[<memberdata name="lemonchiffon" display="LemonChiffon"/>]+;
				[<memberdata name="lightblue" display="LightBlue"/>]+;
				[<memberdata name="lightcoral" display="LightCoral"/>]+;
				[<memberdata name="lightcyan" display="LightCyan"/>]+;
				[<memberdata name="lightgoldenrodyellow" display="LightGoldenrodYellow"/>]+;
				[<memberdata name="lightgray" display="LightGray"/>]+;
				[<memberdata name="lightgreen" display="LightGreen"/>]+;
				[<memberdata name="lightpink" display="LightPink"/>]+;
				[<memberdata name="lightsalmon" display="LightSalmon"/>]+;
				[<memberdata name="lightseagreen" display="LightSeaGreen"/>]+;
				[<memberdata name="lightskyblue" display="LightSkyBlue"/>]+;
				[<memberdata name="lightslategray" display="LightSlateGray"/>]+;
				[<memberdata name="lightsteelblue" display="LightSteelBlue"/>]+;
				[<memberdata name="lightyellow" display="LightYellow"/>]+;
				[<memberdata name="lime" display="Lime"/>]+;
				[<memberdata name="limegreen" display="LimeGreen"/>]+;
				[<memberdata name="linen" display="Linen"/>]+;
				[<memberdata name="magenta" display="Magenta"/>]+;
				[<memberdata name="maroon" display="Maroon"/>]+;
				[<memberdata name="mediumaquamarine" display="MediumAquamarine"/>]+;
				[<memberdata name="mediumblue" display="MediumBlue"/>]+;
				[<memberdata name="mediumorchid" display="MediumOrchid"/>]+;
				[<memberdata name="mediumpurple" display="MediumPurple"/>]+;
				[<memberdata name="mediumseagreen" display="MediumSeaGreen"/>]+;
				[<memberdata name="mediumslateblue" display="MediumSlateBlue"/>]+;
				[<memberdata name="mediumspringgreen" display="MediumSpringGreen"/>]+;
				[<memberdata name="mediumturquoise" display="MediumTurquoise"/>]+;
				[<memberdata name="mediumvioletred" display="MediumVioletRed"/>]+;
				[<memberdata name="midnightblue" display="MidnightBlue"/>]+;
				[<memberdata name="mintcream" display="MintCream"/>]+;
				[<memberdata name="mistyrose" display="MistyRose"/>]+;
				[<memberdata name="moccasin" display="Moccasin"/>]+;
				[<memberdata name="navajowhite" display="NavajoWhite"/>]+;
				[<memberdata name="navy" display="Navy"/>]+;
				[<memberdata name="oldlace" display="OldLace"/>]+;
				[<memberdata name="olive" display="Olive"/>]+;
				[<memberdata name="olivedrab" display="OliveDrab"/>]+;
				[<memberdata name="orange" display="Orange"/>]+;
				[<memberdata name="orangered" display="OrangeRed"/>]+;
				[<memberdata name="orchid" display="Orchid"/>]+;
				[<memberdata name="palegoldenrod" display="PaleGoldenrod"/>]+;
				[<memberdata name="palegreen" display="PaleGreen"/>]+;
				[<memberdata name="paleturquoise" display="PaleTurquoise"/>]+;
				[<memberdata name="palevioletred" display="PaleVioletRed"/>]+;
				[<memberdata name="papayawhip" display="PapayaWhip"/>]+;
				[<memberdata name="peachpuff" display="PeachPuff"/>]+;
				[<memberdata name="peru" display="Peru"/>]+;
				[<memberdata name="pink" display="Pink"/>]+;
				[<memberdata name="plum" display="Plum"/>]+;
				[<memberdata name="powderblue" display="PowderBlue"/>]+;
				[<memberdata name="purple" display="Purple"/>]+;
				[<memberdata name="red" display="Red"/>]+;
				[<memberdata name="rosybrown" display="RosyBrown"/>]+;
				[<memberdata name="royalblue" display="RoyalBlue"/>]+;
				[<memberdata name="saddlebrown" display="SaddleBrown"/>]+;
				[<memberdata name="salmon" display="Salmon"/>]+;
				[<memberdata name="sandybrown" display="SandyBrown"/>]+;
				[<memberdata name="seagreen" display="SeaGreen"/>]+;
				[<memberdata name="seashell" display="SeaShell"/>]+;
				[<memberdata name="sienna" display="Sienna"/>]+;
				[<memberdata name="silver" display="Silver"/>]+;
				[<memberdata name="skyblue" display="SkyBlue"/>]+;
				[<memberdata name="slateblue" display="SlateBlue"/>]+;
				[<memberdata name="slategray" display="SlateGray"/>]+;
				[<memberdata name="snow" display="Snow"/>]+;
				[<memberdata name="springgreen" display="SpringGreen"/>]+;
				[<memberdata name="steelblue" display="SteelBlue"/>]+;
				[<memberdata name="tan" display="Tan"/>]+;
				[<memberdata name="teal" display="Teal"/>]+;
				[<memberdata name="thistle" display="Thistle"/>]+;
				[<memberdata name="tomato" display="Tomato"/>]+;
				[<memberdata name="transparent" display="Transparent"/>]+;
				[<memberdata name="turquoise" display="Turquoise"/>]+;
				[<memberdata name="violet" display="Violet"/>]+;
				[<memberdata name="wheat" display="Wheat"/>]+;
				[<memberdata name="white" display="White"/>]+;
				[<memberdata name="whitesmoke" display="WhiteSmoke"/>]+;
				[<memberdata name="yellow" display="Yellow"/>]+;
				[<memberdata name="yellowgreen" display="YellowGreen"/>]+;
				[</VFPData>]
		#ENDIF
		
		RETURN
	ENDFUNC


	*********************************************************************
	PROTECTED FUNCTION This_ACCESS
	*********************************************************************
	LPARAMETERS tcMember
		
		IF VARTYPE(m.tcMember)="C" ;
				AND PEMSTATUS(This,m.tcMember,5) ;
				AND PEMSTATUS(This,m.tcMember,3)="Property" ;
				AND ISNULL(This.&tcMember)
			LOCAL loColor
			m.loColor = _SCREEN.GdipToken.KnownColorTable.NameToKnownColor(tcMember)
			IF VARTYPE(m.loColor) = "O"
				This.&tcMember = CREATEOBJECT("xfcPen",m.loColor,.T.)
			ENDIF
		ENDIF
		
		RETURN This
	ENDFUNC





ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCPOINT
DEFINE CLASS xfcPoint AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Point"
	IsEmpty = 0	&& Gets a value indicating whether this Point is empty.
	X = 0	&& Gets or sets the x-coordinate of this Point.
	Y = 0	&& Gets or sets the y-coordinate of this Point.
 
 	DIMENSION _InternalArray[1]

	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcPoint.Point
	**
	** Initializes a new instance of the Point class with the specified coordinates.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.Point%28vs.80%29.aspx
	** Parameters:
	**  int dw
	**  Size sz
	**  int x, int y
	*********************************************************************
	LPARAMETERS tiX, tiY
	*********** tiDw
	*********** toSz AS xfcSize
		
		
		*!ToDo: Test this function
		
		LOCAL loSize AS xfcSize
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			DO CASE
			CASE VARTYPE(m.tiX)+VARTYPE(m.tiY) == "NN"
			** Do nothing
				
			CASE VARTYPE(m.tiX) == "N"	&& DWORD
				m.tiY = BITRSHIFT(BITAND(m.tiX,0xffff0000),16)
				m.tiX = BITAND(m.tiX,0x0000ffff)
				
			CASE VARTYPE(m.tiX) = "O"	&& Size
				m.loPoint = m.tiX
				m.loPoint.GetExtent(@tiX,@tiY)
				
			CASE VARTYPE(m.tiX) = "Q"
				lqStruct = m.tiX
				m.tiX = CTOBIN(SUBSTR(lqStruct,1,4),"4rs")
				m.tiY = CTOBIN(SUBSTR(lqStruct,5,4),"4rs")
				
			OTHERWISE
				STORE 0 TO m.tiX, m.tiY
			ENDCASE
			
			This.X = m.tiX
			This.Y = m.tiY
				
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tiX, tiY
		
		RETURN CREATEOBJECT(This.Class, tiX, tiY)
	ENDFUNC
	

	*********************************************************************
	FUNCTION NewArray
	*********************************************************************
	LPARAMETERS tnX, tnY
	
		IF VARTYPE(m.tnX) = "Q" AND LEN(m.tnX) > SIZEOF_POINT AND MOD(LEN(m.tnX),SIZEOF_POINT)=0 
			LOCAL lqBinary, lqStruct, lnStep, lnSize
			m.lqBinary = m.tnX
			m.lnSize = INT(LEN(lqBinary)/SIZEOF_POINT)
			DIMENSION This._InternalArray[m.lnSize]
			FOR lnStep = 1 TO m.lnSize
				m.lqStruct = SUBSTR(m.lqBinary, (m.lnStep-1)*SIZEOF_POINT+1, SIZEOF_POINT)  
				This._InternalArray[m.lnStep] = CREATEOBJECT(This.Class, m.lqStruct)
			ENDFOR
			RETURN @This._InternalArray
		ELSE
			RETURN CREATEOBJECT(This.Class, m.tnX, m.tnY)
		ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION Ceiling
	*********************************************************************
	** Method: xfcPoint.Ceiling
	**
	** Converts the specified PointF object to a Point object by rounding the values of
	** the PointF object to the next higher integer values.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.Ceiling%28vs.80%29.aspx
	** Parameters:
	**  PointF value
	** Returns: Point
	*********************************************************************
	LPARAMETERS toPointF AS xfcPointF
		
		*!ToDo: Test this function
		
		LOCAL loPoint AS xfcPoint
		LOCAL liX, liY
		
		m.loPoint = NULL
		STORE 0 TO liX, liY
		
		LOCAL loExc AS Exception
		TRY
			toPointF.GetExtent(@liX, @liY)
			m.liX     = CEILING(m.liX)
			m.liY     = CEILING(m.liY)
			m.loPoint = CREATEOBJECT(This.Class, m.liX, m.liY)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loPoint
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcPoint.Equals
	**
	** Specifies whether this Point contains the same coordinates as the specified Object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toObj AS Object
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			llValue = (This.X = toObj.X) AND (This.Y = toObj.Y)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetExtent
	*********************************************************************
	** Method: xfcPoint.GetExtent
	**
	** History:
	**	2006/05/01: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiX, tiY
		
		m.tiX = This.X
		m.tiY = This.Y
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcPoint.GetHashCode
	**
	** Returns a hash code for this Point object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsEmpty_ACCESS
	*********************************************************************
	** Property: IsEmpty (Access)
	**
	** Gets a value indicating whether this Point is empty.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.IsEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			m.llValue = (This.X = 0 AND This.Y = 0)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION Offset
	*********************************************************************
	** Method: xfcPoint.Offset
	**
	** Translates this Point by the specified amount.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/10: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.Offset%28vs.80%29.aspx
	** Parameters:
	**  int dx, int dy
	** Returns: void
	*********************************************************************
	LPARAMETERS tiDx, tiDy
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.X = This.X + m.tiDx
			This.Y = This.Y + m.tiDy
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Round
	*********************************************************************
	** Method: xfcPoint.Round
	**
	** Converts the specified PointF object to a Point object by rounding the Point object
	** values to the nearest integer.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.Round%28vs.80%29.aspx
	** Parameters:
	**  PointF value
	** Returns: Point
	*********************************************************************
	LPARAMETERS toPointF AS xfcPointF
		
		*!ToDo: Test this function
		
		LOCAL loPoint AS xfcRPoint
		LOCAL liX, liY
		
		m.loPoint = NULL
		STORE 0 TO liX, liY
		
		LOCAL loExc AS Exception
		TRY
			toPointF.GetExtent(@liX, @liY)
			m.liX     = ROUND(m.liX,0)
			m.liY     = ROUND(m.liY,0)
			m.loPoint = CREATEOBJECT("xfcPoint", liX, liY)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loPoint
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcPoint.ToString
	**
	** Converts this Point to a human readable string.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/10: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		*!ToDo: Is this the right format?
		RETURN "{"+ALLTRIM(STR(This.X))+","+ALLTRIM(STR(This.Y))+"}"
	ENDFUNC


	*********************************************************************
	FUNCTION ToVarbinary
	*********************************************************************
	** Method: xfcPoint.ToVarbinary
	**
	** Returns a binary representation of this Point structure
	**
	** History:
	**	2006/05/01: BDurban - Coded
	**	2006/05/01: BDurban - Modified to handle arrays
	**  2006/07/08: BDurban - Changed method name
	**  2006/12/24: BDurban - Add option for 2D array of integers
	*********************************************************************
	LPARAMETERS taPoint AS xfcPoint, tiCount
		
		LOCAL lqBinary, liX, liY, loPoint, lnLoop
		m.lqBinary = 0h
		m.tiCount = 0
		
		DO CASE
		CASE PCOUNT() = 0
			m.lqBinary = 0h+;
				BINTOC(This.X, "4rs")+;
				BINTOC(This.Y, "4rs")
		
		CASE VARTYPE(m.taPoint) = "Q"
			m.lqBinary = m.taPoint
			m.tiCount = INT(LEN(m.lqBinary)/8)
				
		CASE TYPE("m.taPoint[1]") = "O"
			FOR EACH loPoint AS xfcPoint IN taPoint FOXOBJECT
				m.liX = 0
				m.liY = 0
				loPoint.GetExtent(@liX, @liY)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.liX, "4rs")+;
					BINTOC(m.liY, "4rs")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE TYPE("m.taPoint[1,2]")="N" AND ALEN(m.taPoint,2) >= 2
			FOR m.lnLoop = 1 TO ALEN(m.taPoint,1)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.taPoint[m.lnLoop,1], "4rs")+;
					BINTOC(m.taPoint[m.lnLoop,2], "4rs")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE VARTYPE(m.taPoint) = "O"
			m.loPoint = m.taPoint
			m.liX = 0
			m.liY = 0
			loPoint.GetExtent(@liX, @liY)
			m.lqBinary = 0h+;
				BINTOC(m.liX, "4rs")+;
				BINTOC(m.liY, "4rs")
			m.tiCount = 1
			
		OTHERWISE
			m.lqBinary = NULL
		ENDCASE
		
		RETURN m.lqBinary
	ENDFUNC


	*********************************************************************
	FUNCTION Truncate
	*********************************************************************
	** Method: xfcPoint.Truncate
	**
	** Converts the specified PointF object to a Point object by truncating the values
	** of the Point object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.Truncate%28vs.80%29.aspx
	** Parameters:
	**  PointF value
	** Returns: Point
	*********************************************************************
	LPARAMETERS toPointF AS xfcPointF
		
		*!ToDo: Test this function
		
		LOCAL loPoint AS xfcPoint
		LOCAL liX, liY
		
		m.loPoint = NULL
		STORE 0 TO liX, liY
		
		LOCAL loExc AS Exception
		TRY
			toPointF.GetExtent(@liX, @liY)
			m.liX     = FLOOR(m.liX)
			m.liY     = FLOOR(m.liY)
			m.loPoint = CREATEOBJECT(This.Class, liX, liY)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loPoint
	ENDFUNC


	*********************************************************************
	FUNCTION X_ASSIGN
	*********************************************************************
	** Property: X (Assign)
	**
	** Gets or sets the x-coordinate of this Point.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.X%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.X = INT(tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Y_ASSIGN
	*********************************************************************
	** Property: Y (Assign)
	**
	** Gets or sets the y-coordinate of this Point.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Point.Y%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.Y = INT(tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="ceiling" type="method" display="Ceiling"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="offset" type="method" display="Offset"/>]+;
		[<memberdata name="round" type="method" display="Round"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="truncate" type="method" display="Truncate"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="isempty" type="property" display="IsEmpty"/>]+;
		[<memberdata name="x" type="property" display="X"/>]+;
		[<memberdata name="y" type="property" display="Y"/>]+;
		[<memberdata name="getextent" type="method" display="GetExtent"/>]+;
		[<memberdata name="tovarbinary" type="method" display="ToVarbinary"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************


*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCPOINTF
DEFINE CLASS xfcPointF AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "PointF"
	IsEmpty = .F.	&& Gets a value indicating whether this PointF is empty.
	X = 0	&& Gets the x-coordinate of this PointF.
	Y = 0	&& Gets the y-coordinate of this PointF.
	
	DIMENSION _InternalArray[1]
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcPointF.PointF
	**
	** Initializes a new instance of the PointF class with the specified coordinates.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.PointF.PointF%28vs.80%29.aspx
	** Parameters:
	**  float x, float y
	*********************************************************************
	LPARAMETERS tnX, tnY
		
		*!ToDo: Test this function
		LOCAL lqStruct, lqBinary
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			LOCAL loPoint, lqStruct, lnStep, lnSize
			DO CASE
			CASE VARTYPE(m.tnX)+VARTYPE(m.tnY) == "NN"
			
			CASE VARTYPE(m.tnX) = "O"
				m.loPoint = m.tnX
				m.loPoint.GetExtent(@tnX,@tnY)
				
			CASE VARTYPE(m.tnX) = "Q"
				m.lqStruct = m.tnX
				m.tnX = CTOBIN(SUBSTR(lqStruct,1,4),"n")
				m.tnY = CTOBIN(SUBSTR(lqStruct,5,4),"n")
				
			OTHERWISE
				STORE 0 TO m.tnX, m.tnY
			ENDCASE
			
			This.X = (m.tnX)
			This.Y = (m.tnY)
				
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcPointF.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	*********************************************************************
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
	** This.SetStatus(GdipSomeFunction???())
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tnX, tnY
	
		RETURN CREATEOBJECT(This.Class, m.tnX, m.tnY)
	ENDFUNC


	*********************************************************************
	FUNCTION NewArray
	*********************************************************************
	LPARAMETERS tnX, tnY
	
		IF VARTYPE(m.tnX) = "Q" AND LEN(m.tnX) > SIZEOF_POINTF AND MOD(LEN(m.tnX),SIZEOF_POINTF)=0 
			LOCAL lqBinary, lqStruct, lnStep, lnSize
			m.lqBinary = m.tnX
			m.lnSize = INT(LEN(lqBinary)/SIZEOF_POINTF)
			DIMENSION This._InternalArray[m.lnSize]
			FOR lnStep = 1 TO m.lnSize
				m.lqStruct = SUBSTR(m.lqBinary, (m.lnStep-1)*SIZEOF_POINTF+1, SIZEOF_POINTF)  
				This._InternalArray[m.lnStep] = CREATEOBJECT(This.Class, m.lqStruct)
			ENDFOR
			RETURN @This._InternalArray
		ELSE
			RETURN CREATEOBJECT(This.Class, m.tnX, m.tnY)
		ENDIF
	ENDFUNC

	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcPointF.Equals
	**
	** Specifies whether this PointF contains the same coordinates as the specified Object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.PointF.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toObj AS Object
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			llValue = This.X = toObj.X ;
				AND This.Y = toObj.Y
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetExtent
	*********************************************************************
	** Method: xfcPointF.GetExtent
	**
	** History:
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnX, tnY
		
		m.tnX = This.X
		m.tnY = This.Y
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcPointF.GetHashCode
	**
	** Returns a hash code for this PointF object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.PointF.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsEmpty_ACCESS
	*********************************************************************
	** Property: IsEmpty (Access)
	**
	** Gets a value indicating whether this PointF is empty.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.PointF.IsEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			m.llValue = (This.X = 0 ;
				AND This.Y = 0)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcPointF.ToString
	**
	** Converts this PointF to a human readable string.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.PointF.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		*!ToDo: Is this the right format?
		RETURN "{"+TRANSFORM(This.X)+","+TRANSFORM(This.Y)+"}"
	ENDFUNC


	*********************************************************************
	FUNCTION ToVarBinary
	*********************************************************************
	** Method: xfcPointF.ToVarBinary
	**
	** Returns a binary representation of this PointF structure
	**
	** History:
	**	2006/05/01: BDurban - Coded
	**	2006/05/01: BDurban - Modified to handle arrays
	**  2006/07/08: BDurban - Changed method name
	**  2006/12/24: BDurban - Add option for 2D array of integers
	*********************************************************************
	LPARAMETERS taPoint AS xfcPointF, tiCount
		
		EXTERNAL ARRAY taPoint
		
		LOCAL lqBinary, liX, liY, loPoint, lnLoop
		m.lqBinary = 0h
		m.tiCount = 0
		
		DO CASE
		CASE PCOUNT() = 0
			m.lqBinary = 0h+;
				BINTOC(This.X, "f")+;
				BINTOC(This.Y, "f")
				
		CASE TYPE("m.taPoint[1]") = "O"
			FOR EACH loPoint AS xfcPointF IN taPoint FOXOBJECT
				m.liX = 0
				m.liY = 0
				loPoint.GetExtent(@liX, @liY)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.liX, "f")+;
					BINTOC(m.liY, "f")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE TYPE("m.taPoint[1,2]") = "N" AND ALEN(m.taPoint,2) >= 2
			FOR m.lnLoop = 1 TO ALEN(m.taPoint,1)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.taPoint[m.lnLoop,1], "f")+;
					BINTOC(m.taPoint[m.lnLoop,2], "f")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE VARTYPE(m.taPoint) = "O"
			m.loPoint = m.taPoint
			m.liX = 0
			m.liY = 0
			loPoint.GetExtent(@liX, @liY)
			m.lqBinary = 0h+;
				BINTOC(m.liX, "f")+;
				BINTOC(m.liY, "f")
			m.tiCount = 1
		ENDCASE
		
		RETURN m.lqBinary
	ENDFUNC


	*********************************************************************
	FUNCTION X_ASSIGN
	*********************************************************************
	** Property: X (Assign)
	**
	** Gets the x-coordinate of this PointF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.PointF.X%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
	LPARAMETERS tnValue
		LOCAL loExc AS Exception
		TRY
			This.X = tnValue+0.0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Y_ASSIGN
	*********************************************************************
	** Property: Y (Assign)
	**
	** Gets the y-coordinate of this PointF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.PointF.Y%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
	LPARAMETERS tnValue
		LOCAL loExc AS Exception
		TRY
			This.Y = tnValue+0.0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="isempty" type="property" display="IsEmpty"/>]+;
		[<memberdata name="x" type="property" display="X"/>]+;
		[<memberdata name="y" type="property" display="Y"/>]+;
		[<memberdata name="tovarbinary" type="method" display="ToVarBinary"/>]+;
		[<memberdata name="length" type="property" display="Length"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCRECTANGLE
DEFINE CLASS xfcRectangle AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Rectangle"
	Bottom = 0	&& Gets the y-coordinate of the bottom edge of this Rectangle structure.
	IsEmpty = 0	&& Tests whether all numeric properties of this Rectangle have values of zero.
	Location = 0	&& Gets or sets the coordinates of the upper-left corner of this Rectangle structure.
	Right = 0	&& Gets the x-coordinate of the right edge of this Rectangle structure.
	Size = 0	&& Gets or sets the size of this Rectangle.
	X = 0	&& Gets or sets the x-coordinate of the upper-left corner of this Rectangle structure.
	Y = 0	&& Gets or sets the y-coordinate of the upper-left corner of this Rectangle structure.
	PROTECTED _height
	_height = 0
	PROTECTED _width
	_width = 0
	
	DIMENSION _InternalArray[1]
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcRectangle.Rectangle
	**
	** Initializes a new instance of the Rectangle class with the specified location and
	** size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Rectangle%28vs.80%29.aspx
	** Parameters:
	**  Point location, Size size
	**  int x, int y, int width, int height
	*********************************************************************
	LPARAMETERS tiX, tiY, tiWidth, tiHeight
	*********** toLocation AS xfcPoint, toSize AS xfcSize
		
		*!ToDo: Test this function
		LOCAL loPoint AS xfcPoint
		LOCAL loSize AS xfcSize
		LOCAL loExc AS Exception
		LOCAL lqStruct
		TRY
			DODEFAULT()
			
			DO CASE
			CASE VARTYPE(m.tiX)+VARTYPE(m.tiY) == "OO"		&& Point, Size
				m.loPoint = m.tiX
				m.loSize = m.tiY
				
				m.loPoint.GetExtent(@tiX, @tiY)
				m.loSize.GetExtent(@tiWidth, @tiHeight)
				
			CASE VARTYPE(m.tiX)+VARTYPE(m.tiY)+VARTYPE(m.tiWidth)+VARTYPE(m.tiHeight) == "NNNN"
			
			CASE VARTYPE(m.tiX) = "Q" OR (VARTYPE(m.tiX) = "C" AND LEN(m.tnX) = 16)
				lqStruct = m.tiX
				m.tiX = CTOBIN(SUBSTR(lqStruct,1,4),"4rs")
				m.tiY = CTOBIN(SUBSTR(lqStruct,5,4),"4rs")
				m.tiWidth = CTOBIN(SUBSTR(lqStruct,9,4),"4rs")
				m.tiHeight = CTOBIN(SUBSTR(lqStruct,13,4),"4rs")
			
			OTHERWISE
				STORE 0 TO m.tiX, m.tiY, m.tiWidth, m.tiHeight
			ENDCASE
			
			This.X      = (m.tiX)
			This.Y      = (m.tiY)
			This.Width  = (m.tiWidth)
			This.Height = (m.tiHeight)
				
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcRectangle.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	*********************************************************************
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
	** This.SetStatus(GdipSomeFunction???())
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tiX, tiY, tiWidth, tiHeight
		
		RETURN CREATEOBJECT(This.Class, m.tiX, m.tiY, m.tiWidth, m.tiHeight)
	ENDFUNC


	*********************************************************************
	FUNCTION NewArray
	*********************************************************************
	LPARAMETERS tiX, tiY, tiWidth, tiHeight
	
		IF VARTYPE(m.tiX) = "Q" AND LEN(m.tiX) > SIZEOF_RECTANGLE AND MOD(LEN(m.tiX),SIZEOF_RECTANGLE)=0 
			LOCAL lqBinary, lqStruct, lnStep, lnSize
			m.lqBinary = m.tiX
			m.lnSize = INT(LEN(lqBinary)/SIZEOF_RECTANGLE)
			DIMENSION This._InternalArray[m.lnSize]
			FOR lnStep = 1 TO m.lnSize
				m.lqStruct = SUBSTR(m.lqBinary, (m.lnStep-1)*SIZEOF_RECTANGLE+1, SIZEOF_RECTANGLE)  
				This._InternalArray[m.lnStep] = CREATEOBJECT(This.Class, m.lqStruct)
			ENDFOR
			RETURN @This._InternalArray
		ELSE
			RETURN CREATEOBJECT(This.Class, m.tiX, m.tiY, m.tiWidth, m.tiHeight)
		ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION Bottom_ACCESS
	*********************************************************************
	** Property: Bottom (Access)
	**
	** Gets the y-coordinate of the bottom edge of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Bottom%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		RETURN This.Y + This._height
	ENDFUNC


	*********************************************************************
	FUNCTION Ceiling
	*********************************************************************
	** Method: xfcRectangle.Ceiling
	**
	** Converts the specified RectangleF structure to a Rectangle structure by rounding
	** the RectangleF values to the next higher integer values.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Ceiling%28vs.80%29.aspx
	** Parameters:
	**  RectangleF value
	** Returns: Rectangle
	*********************************************************************
	LPARAMETERS toRectF AS xfcRectangleF
		
		*!ToDo: Test this function
		
		LOCAL loRectangle AS xfcRectangle
		LOCAL liX, liY, liWidth, liHeight
		
		m.loRectangle = NULL
		STORE 0 TO liX, liY, liWidth, liHeight
		
		LOCAL loExc AS Exception
		TRY
			toRectF.GetExtent(@liX, @liY, @liWidth, @liHeight)
			m.liX      = CEILING(m.liX)
			m.liY      = CEILING(m.liY)
			m.liWidth  = CEILING(m.liWidth)
			m.liHeight = CEILING(m.liHeight)
			m.loRectangle = CREATEOBJECT("xfcRectangle", liX, liY, liWidth, liHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRectangle
	ENDFUNC


	*********************************************************************
	FUNCTION Contains
	*********************************************************************
	** Method: xfcRectangle.Contains
	**
	** Determines if the specified point is contained within the rectangular region defined
	** by this Rectangle.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**  2008/12/10: BBout - Fixed
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Contains%28vs.80%29.aspx
	** Parameters:
	**  Point pt
	**  Rectangle rect
	**  int x, int y
	** Returns: bool
	*********************************************************************
	LPARAMETERS tiX, tiY, ;
					tiWidth, tiHeight
	*********** toPt AS xfcPoint
	*********** toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue
			m.llValue = .F.
			
			m.tiWidth = EVL(m.tiWidth, 0)
			m.tiHeight = EVL(m.tiHeight, 0)
		
			DO CASE
			CASE VARTYPE(m.tiX) = "O" AND INLIST(m.tiX.BaseName, "RectangleF", "Rectangle")
				m.loRect = m.tiX
				m.loRect.GetExtent(@tiX, @tiY, @tiWidth, @tiHeight)
			CASE VARTYPE(m.tiX) = "O" AND INLIST(m.tiX.BaseName, "PointF", "Point")
				m.tiHeight = 0
				m.tiWidth = 0
				m.loPoint = m.tiX
				m.loPoint.GetExtent(@tiX, @tiY)
			ENDCASE
			
			m.llValue = (m.tiX >= This.X ;
						AND m.tiY >= This.Y ;
						AND m.tiX + m.tiWidth  <= This.X + This.Width ;
						AND m.tiY + m.tiHeight <= This.Y + This.Height)
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcRectangle.Equals
	**
	** Tests whether obj is a Rectangle structure with the same location and size of this
	** Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toObj AS Object
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			llValue = This.X = toObj.X ;
				AND This.Y = toObj.Y ;
				AND This._width = toObj.Width ;
				AND This._height = toObj.Height
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION FromLTRB
	*********************************************************************
	** Method: xfcRectangle.FromLTRB
	**
	** Creates a Rectangle structure with the specified edge locations.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.FromLTRB%28vs.80%29.aspx
	** Parameters:
	**  int left, int top, int right, int bottom
	** Returns: Rectangle
	*********************************************************************
	LPARAMETERS tiLeft, tiTop, tiRight, tiBottom
		
		*!ToDo: Test this function
		
		LOCAL loRectangle AS xfcRectangle
		m.loRectangle = NULL
		
		LOCAL loExc AS Exception
		TRY
			m.loRectangle = CREATEOBJECT("xfcRectangle", m.tiLeft, m.tiTop, ;
						m.tiRight-m.tiLeft, m.tiBottom-m.tiRight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRectangle
	ENDFUNC


	*********************************************************************
	FUNCTION GetExtent
	*********************************************************************
	** Method: xfcRectangle.GetExtent
	**
	** History:
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiX, tiY, tiWidth, tiHeight
		
		m.tiX = This.X
		m.tiY = This.Y
		m.tiWidth = This._width
		m.tiHeight = This._height
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcRectangle.GetHashCode
	**
	** Returns the hash code for this Rectangle structure. For information about the use
	** of hash codes, see Object.GetHashCode.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ACCESS
	*********************************************************************
	** Property: Height (Access)
	**
	** Gets or sets the height of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Height%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		RETURN This._height
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ASSIGN
	*********************************************************************
	** Property: Height (Assign)
	**
	** Gets or sets the height of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This._height = INT(tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Inflate
	*********************************************************************
	** Method: xfcRectangle.Inflate
	**
	** Creates and returns an inflated copy of the specified Rectangle structure. The copy
	** is inflated by the specified amount.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**	2006/06/11: BDurban - Fixed
	**  2006/09/06: CChalom - Fixed for 1st Overload in VARTYPE
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Inflate%28vs.80%29.aspx
	** Parameters:
	**  Size size
	**  int width, int height
	**  Rectangle rect, int x, int y
	** Returns: void
	*********************************************************************
	LPARAMETERS tiWidth, tiHeight, tiY
	*********** toRect AS xfcRectangle, tiX, tiY
	*********** tiWidth, tiHeight
	*********** toSize AS xfcSize
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRect AS xfcRectangle, loSize AS xfcSize
			m.loRect = NULL
		
			DO CASE
			CASE VARTYPE(m.tiWidth) + VARTYPE(m.tiHeight) == "NN"
				This.X = This.X - m.tiWidth
				This.Y = This.Y - m.tiHeight
				This.Width = This.Width + (m.tiWidth*2)
				This.Height = This.Height + (m.tiHeight*2)
			
			CASE VARTYPE(m.tiWidth)="O" AND INLIST(m.tiWidth.BaseName,"Rectangle","RectangleF")
			** ToDo: Make a copy of this rectangle. Don't modify the original
				m.loRect = m.tiWidth
				m.tiWidth = m.tiHeight
				m.tiHeight = m.tiY
				m.loRect.Inflate(m.tiWidth, m.tiHeight)
				
			CASE VARTYPE(m.tiWidth)="O" AND INLIST(m.tiWidth.BaseName,"Size","SizeF")
				m.loSize = m.tiWidth
				m.loSize.GetExtent(@tiWidth, @tiHeight)
				This.Inflate(m.tiWidth, m.tiHeight)
				m.loSize = NULL
			
			OTHERWISE
				
			ENDCASE
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRect
	ENDFUNC


	*********************************************************************
	FUNCTION Intersect
	*********************************************************************
	** Method: xfcRectangle.Intersect
	**
	** Replaces this Rectangle structure with the intersection of itself and the specified
	** Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Intersect%28vs.80%29.aspx
	** Parameters:
	**  Rectangle rect
	**  Rectangle a, Rectangle b
	** Returns: void
	*********************************************************************
	LPARAMETERS toA AS xfcRectangle, toB AS xfcRectangle
	*********** toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lnTop,lnLeft,lnBottom,lnRight
			IF VARTYPE(m.toB) <> "O"
				m.toB = This
			ENDIF
			
			m.lnRight = MIN(m.toA.Width+m.toA.X, m.toB.Width+m.toB.X)
			m.lnBottom = MIN(m.toA.Height+m.toA.Y, m.toB.Height)
			m.lnLeft = MAX(m.toA.X, m.toB.X)
			m.lnTop = MAX(m.toA.Y, m.toB.Y)
			
			This.X = m.lnLeft
			This.Y = m.lnTop
			This.Width = m.lnRight-m.lnLeft
			This.Height = m.lnBottom-m.lnTop
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION IntersectsWith
	*********************************************************************
	** Method: xfcRectangle.IntersectsWith
	**
	** Determines if this rectangle intersects with rect.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/11: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.IntersectsWith%28vs.80%29.aspx
	** Parameters:
	**  Rectangle rect
	** Returns: bool
	*********************************************************************
	LPARAMETERS toRect AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL llValue
		
		LOCAL loExc AS Exception
		TRY
			m.llValue = This.X < m.toRect.Width+m.toRect.X ;
					AND This.Y < m.toRect.Height+m.toRect.Y ;
					AND This.Width+This.X > m.toRect.X ;
					AND This.Height+This.Y > m.toRect.Y
					
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsEmpty_ACCESS
	*********************************************************************
	** Property: IsEmpty (Access)
	**
	** Tests whether all numeric properties of this Rectangle have values of zero.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.IsEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			m.llValue = (This.X = 0 ;
				AND This.Y = 0 ;
				AND This._width = 0 ;
				AND This._height = 0)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION Left_ACCESS
	*********************************************************************
	** Property: Left (Access)
	**
	** Gets the x-coordinate of the left edge of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Left%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		RETURN This.X
	ENDFUNC


	*********************************************************************
	FUNCTION Location_ACCESS
	*********************************************************************
	** Property: Location (Access)
	**
	** Gets or sets the coordinates of the upper-left corner of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Location%28vs.80%29.aspx
	** Returns: Point
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loPoint
		m.loPoint = NULL
		
		LOCAL loExc AS Exception
		TRY
			m.loPoint = CREATEOBJECT("xfcPoint", This.X, This.Y)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPoint
	ENDFUNC


	*********************************************************************
	FUNCTION Location_ASSIGN
	*********************************************************************
	** Property: Location (Assign)
	**
	** Gets or sets the coordinates of the upper-left corner of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toPoint AS xfcPoint
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(m.toPoint) = "O"
				This.X = toPoint.X
				This.Y = toPoint.Y
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Offset
	*********************************************************************
	** Method: xfcRectangle.Offset
	**
	** Adjusts the location of this rectangle by the specified amount.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Offset%28vs.80%29.aspx
	** Parameters:
	**  Point pos
	**  int x, int y
	** Returns: void
	*********************************************************************
	LPARAMETERS tiX, tiY
	*********** toPos AS xfcPoint
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loPoint AS xfcPoint
			DO CASE
			CASE VARTYPE(m.tiX)="O"
				m.loPoint = m.tiX
				m.loPoint.GetExtent(@tiX, @tiY)
			ENDCASE
			
			This.X = m.tiX
			This.Y = m.tiY
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Right_ACCESS
	*********************************************************************
	** Property: Right (Access)
	**
	** Gets the x-coordinate of the right edge of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Right%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN This.X + This._width
	ENDFUNC


	*********************************************************************
	FUNCTION Round
	*********************************************************************
	** Method: xfcRectangle.Round
	**
	** Converts the specified RectangleF to a Rectangle by rounding the RectangleF values
	** to the nearest integer values.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Round%28vs.80%29.aspx
	** Parameters:
	**  RectangleF value
	** Returns: Rectangle
	*********************************************************************
	LPARAMETERS toRectF AS xfcRectangleF
		
		*!ToDo: Test this function
		
		LOCAL loRectangle AS xfcRectangle
		LOCAL liX, liY, liWidth, liHeight
		
		m.loRectangle = NULL
		STORE 0 TO liX, liY, liWidth, liHeight
		
		LOCAL loExc AS Exception
		TRY
			toRectF.GetExtent(@liX, @liY, @liWidth, @liHeight)
			m.liX      = ROUND(m.liX,0)
			m.liY      = ROUND(m.liY,0)
			m.liWidth  = ROUND(m.liWidth,0)
			m.liHeight = ROUND(m.liHeight,0)
			m.loRectangle = CREATEOBJECT("xfcRectangle", liX, liY, liWidth, liHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRectangle
	ENDFUNC


	*********************************************************************
	FUNCTION Size_ACCESS
	*********************************************************************
	** Property: Size (Access)
	**
	** Gets or sets the size of this Rectangle.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Size%28vs.80%29.aspx
	** Returns: Size
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loSize AS xfcSize
		m.loSize = NULL
		
		LOCAL loExc AS Exception
		TRY
			m.loSize = CREATEOBJECT("xfcSize", This._width, This._height)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loSize
	ENDFUNC


	*********************************************************************
	FUNCTION Size_ASSIGN
	*********************************************************************
	** Property: Size (Assign)
	**
	** Gets or sets the size of this Rectangle.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toSize AS xfcSize
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(m.toSize) = "O"
				This.Width  = toSize.Width
				This.Height = toSize.Height
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Top_ACCESS
	*********************************************************************
	** Property: Top (Access)
	**
	** Gets the y-coordinate of the top edge of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Top%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		RETURN This.Y
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcRectangle.ToString
	**
	** Converts the attributes of this Rectangle to a human-readable string.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN [{X=]+ TRANSFORM(This.X)+;
				[,Y=]+ TRANSFORM(This.Y)+;
				[,Width=]+ TRANSFORM(This.width)+;
				[,Height=]+ TRANSFORM(This.height)+[}]
				
	ENDFUNC


	*********************************************************************
	FUNCTION ToVarbinary
	*********************************************************************
	** Method: xfcRectangle.ToVarbinary
	**
	** Returns a binary representation of this Point structure
	**
	** History:
	**	2006/05/01: BDurban - Coded
	**	2006/05/01: BDurban - Modified to handle arrays
	**  2006/07/08: BDurban - Changed method name
	**  2006/08/27: CChalom - Migrated from xfcRectangleF.ToVarbinary()
	*********************************************************************
	LPARAMETERS taRect AS xfcRectangle, tiCount
		
		EXTERNAL ARRAY taRect
		
		LOCAL lqBinary, liX, liY, liWidth, liHeight, loRect
		m.lqBinary = 0h
		m.tiCount = 0
		
		DO CASE
		CASE PCOUNT() = 0
			m.lqBinary = 0h+;
				BINTOC(This.X,"4rs")+;
				BINTOC(This.Y,"4rs")+;
				BINTOC(This._width,"4rs")+;
				BINTOC(This._height,"4rs")
				
		CASE TYPE("m.taRect[1]") = "O"
			FOR EACH loRect AS xfcRectangle IN taRect FOXOBJECT
				STORE 0 TO liX, liY, liWidth, liHeight
				m.loRect.GetExtent(@liX, @liY, @liWidth, @liHeight)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.liX, "4rs")+;
					BINTOC(m.liY, "4rs")+;
					BINTOC(m.liWidth, "4rs")+;
					BINTOC(m.liHeight, "4rs")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE TYPE("m.taRect[1,4]") = "N" AND ALEN(taRect, 2) >= 4
			FOR m.lnLoop = 1 TO ALEN(taRect, 1)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.taRect[m.lnLoop,1], "4rs")+;
					BINTOC(m.taRect[m.lnLoop,2], "4rs")+;
					BINTOC(m.taRect[m.lnLoop,3], "4rs")+;
					BINTOC(m.taRect[m.lnLoop,4], "4rs")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE VARTYPE(m.taRect) = "O"
			m.loRect = m.taRect
			STORE 0 TO liX, liY, liWidth, liHeight
			m.loRect.GetExtent(@liX, @liY, @liWidth, @liHeight)
			m.lqBinary = 0h+;
				BINTOC(m.liX, "4rs")+;
				BINTOC(m.liY, "4rs")+;
				BINTOC(m.liWidth, "4rs")+;
				BINTOC(m.liHeight, "4rs")
			m.tiCount = m.tiCount + 1
		ENDCASE
		
		RETURN m.lqBinary
		
	*********************************************************************
	** Method: ToVarbinary
	**
	** Returns a binary representation of this Rectangle structure
	**
	** History:
	*********************************************************************
	ENDFUNC


	*********************************************************************
	FUNCTION Truncate
	*********************************************************************
	** Method: xfcRectangle.Truncate
	**
	** Converts the specified RectangleF to a Rectangle by truncating the RectangleF values.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Truncate%28vs.80%29.aspx
	** Parameters:
	**  RectangleF value
	** Returns: Rectangle
	*********************************************************************
	LPARAMETERS toRectF AS xfcRectangleF
		
		*!ToDo: Test this function
		
		LOCAL loRectangle AS xfcRectangle
		LOCAL liX, liY, liWidth, liHeight
		
		m.loRectangle = NULL
		STORE 0 TO liX, liY, liWidth, liHeight
		
		LOCAL loExc AS Exception
		TRY
			toRectF.GetExtent(@liX, @liY, @liWidth, @liHeight)
			m.liX      = FLOOR(m.liX)
			m.liY      = FLOOR(m.liY)
			m.liWidth  = FLOOR(m.liWidth)
			m.liHeight = FLOOR(m.liHeight)
			m.loRectangle = CREATEOBJECT("xfcRectangle", liX, liY, liWidth, liHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRectangle
	ENDFUNC


	*********************************************************************
	FUNCTION Union
	*********************************************************************
	** Method: xfcRectangle.Union
	**
	** Gets a Rectangle structure that contains the union of two R ectangle structures.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**  2013/03/10: Doug Hennig - Fixed - http://vfpx.codeplex.com/workitem/32677
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Union%28vs.80%29.aspx
	** Parameters:
	**  Rectangle a, Rectangle b
	** Returns: Rectangle
	*********************************************************************
	LPARAMETERS toRectA AS xfcRectangle, toRectB AS xfcRectangle
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRect AS xfcRectangleF
			m.loRect = NULL
			
			m.lnLeft = MIN(m.toRectA.X, m.toRectB.Y)
			m.lnRight = MAX(m.toRectA.X+m.toRectA.Width, m.toRectB.X+m.toRectB.Width)
			m.lnTop = MIN(m.toRectA.Y, m.toRectB.Y)
			m.lnBottom = MAX(m.toRectA.Y+m.toRectA.Height, m.toRectB.Y+m.toRectB.Height)
			
			m.loRect = CREATEOBJECT("xfcRectangleF", m.lnLeft, m.lnTop, (m.lnRight-m.lnLeft), (m.lnBottom-m.lnTop))
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRect
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ACCESS
	*********************************************************************
	** Property: Width (Access)
	**
	** Gets or sets the width of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Width%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		RETURN This._width
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ASSIGN
	*********************************************************************
	** Property: Width (Assign)
	**
	** Gets or sets the width of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This._width = INT(tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION X_ACCESS
	*********************************************************************
	** Property: X (Access)
	**
	** Gets or sets the x-coordinate of the upper-left corner of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.X%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		RETURN This.X
	ENDFUNC


	*********************************************************************
	FUNCTION X_ASSIGN
	*********************************************************************
	** Property: X (Assign)
	**
	** Gets or sets the x-coordinate of the upper-left corner of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.X = INT(tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Y_ACCESS
	*********************************************************************
	** Property: Y (Access)
	**
	** Gets or sets the y-coordinate of the upper-left corner of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Rectangle.Y%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		RETURN This.Y
	ENDFUNC


	*********************************************************************
	FUNCTION Y_ASSIGN
	*********************************************************************
	** Property: Y (Assign)
	**
	** Gets or sets the y-coordinate of the upper-left corner of this Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.Y = INT(tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="ceiling" type="method" display="Ceiling"/>]+;
		[<memberdata name="contains" type="method" display="Contains"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="fromltrb" type="method" display="FromLTRB"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="inflate" type="method" display="Inflate"/>]+;
		[<memberdata name="intersect" type="method" display="Intersect"/>]+;
		[<memberdata name="intersectswith" type="method" display="IntersectsWith"/>]+;
		[<memberdata name="offset" type="method" display="Offset"/>]+;
		[<memberdata name="round" type="method" display="Round"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="truncate" type="method" display="Truncate"/>]+;
		[<memberdata name="union" type="method" display="Union"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="bottom" type="property" display="Bottom"/>]+;
		[<memberdata name="height" type="property" display="Height"/>]+;
		[<memberdata name="isempty" type="property" display="IsEmpty"/>]+;
		[<memberdata name="left" type="property" display="Left"/>]+;
		[<memberdata name="location" type="property" display="Location"/>]+;
		[<memberdata name="right" type="property" display="Right"/>]+;
		[<memberdata name="size" type="property" display="Size"/>]+;
		[<memberdata name="top" type="property" display="Top"/>]+;
		[<memberdata name="width" type="property" display="Width"/>]+;
		[<memberdata name="x" type="property" display="X"/>]+;
		[<memberdata name="y" type="property" display="Y"/>]+;
		[<memberdata name="getextent" type="method" display="GetExtent"/>]+;
		[<memberdata name="tovarbinary" type="method" display="ToVarbinary"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCRECTANGLEF
DEFINE CLASS xfcRectangleF AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "RectangleF"
	Bottom = 0	&& Gets the y-coordinate of the bottom edge of this RectangleF structure.
	IsEmpty = 0	&& Tests whether all numeric properties of this RectangleF have values of zero.
	Location = 0	&& Gets or sets the coordinates of the upper-left corner of this RectangleF structure.
	Right = 0	&& Gets the x-coordinate of the right edge of this RectangleF structure.
	Size = 0	&& Gets or sets the size of this RectangleF.
	X = 0	&& Gets or sets the x-coordinate of the upper-left corner of this RectangleF structure.
	Y = 0	&& Gets or sets the y-coordinate of the upper-left corner of this RectangleF structure.
	PROTECTED _height
	_height = 0.0
	PROTECTED _width
	_width = 0.0
	
	DIMENSION _InternalArray[1]
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcRectangleF.RectangleF
	**
	** Initializes a new instance of the RectangleF class with the specified location and
	** size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.RectangleF%28vs.80%29.aspx
	** Parameters:
	**  PointF location, SizeF size
	**  float x, float y, float width, float height
	*********************************************************************
	LPARAMETERS tnX, tnY, tnWidth, tnHeight
	*********** toLocation AS xfcPointF, toSize AS xfcSizeF
		
		*!ToDo: Test this function
		LOCAL loPoint AS xfcPoint
		LOCAL loSize AS xfcSize
		LOCAL loExc AS Exception
		LOCAL lqStruct
		TRY
			DODEFAULT()
			
			DO CASE
			CASE PCOUNT() = 2		&& Point, Size
				m.loPoint = m.tnX
				m.loSize = m.tnY
				
				m.loPoint.GetExtent(@tnX, @tnY)
				m.loSize.GetExtent(@tnWidth, @tnHeight)
				
			CASE VARTYPE(m.tnX)+VARTYPE(m.tnY)+VARTYPE(m.tnWidth)+VARTYPE(m.tnHeight) == "NNNN"
				
			CASE VARTYPE(m.tnX) = "Q" OR (VARTYPE(m.tnX)="C" AND LEN(m.tnX)=16)
				lqStruct = m.tnX
				m.tnX = CTOBIN(SUBSTR(lqStruct,1,4),"n")
				m.tnY = CTOBIN(SUBSTR(lqStruct,5,4),"n")
				m.tnWidth = CTOBIN(SUBSTR(lqStruct,9,4),"n")
				m.tnHeight = CTOBIN(SUBSTR(lqStruct,13,4),"n")
				
			OTHERWISE
				STORE 0 TO m.tnX, m.tnY, m.tnWidth, m.tnHeight
			ENDCASE
			
			This.X      = (m.tnX)
			This.Y      = (m.tnY)
			This.Width  = (m.tnWidth)
			This.Height = (m.tnHeight)
				
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tnX, tnY, tnWidth, tnHeight
		
		RETURN CREATEOBJECT(This.Class, m.tnX, m.tnY, m.tnWidth, m.tnHeight)
	ENDFUNC


	*********************************************************************
	FUNCTION NewArray
	*********************************************************************
	LPARAMETERS tnX, tnY, tnWidth, tnHeight
	
		IF VARTYPE(m.tnX) = "Q" AND LEN(m.tnX) > SIZEOF_RECTANGLEF AND MOD(LEN(m.tnX),SIZEOF_RECTANGLEF)=0 
			LOCAL lqBinary, lqStruct, lnStep, lnSize
			m.lqBinary = m.tnX
			m.lnSize = INT(LEN(lqBinary)/SIZEOF_RECTANGLEF)
			DIMENSION This._InternalArray[m.lnSize]
			FOR lnStep = 1 TO m.lnSize
				m.lqStruct = SUBSTR(m.lqBinary, (m.lnStep-1)*SIZEOF_RECTANGLEF+1, SIZEOF_RECTANGLEF)  
				This._InternalArray[m.lnStep] = CREATEOBJECT(This.Class, m.lqStruct)
			ENDFOR
			RETURN @This._InternalArray
		ELSE
			RETURN CREATEOBJECT(This.Class, m.tnX, m.tnY, m.tnWidth, m.tnHeight)
		ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION Bottom_ACCESS
	*********************************************************************
	** Property: Bottom (Access)
	**
	** Gets the y-coordinate of the bottom edge of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Bottom%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		RETURN This.Y + This._height
	ENDFUNC


	*********************************************************************
	FUNCTION Contains
	*********************************************************************
	** Method: xfcRectangleF.Contains
	**
	** Determines if the specified point is contained within this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded (to match .NET)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Contains%28vs.80%29.aspx
	** Parameters:
	**  PointF pt
	**  RectangleF rect
	**  float x, float y
	** Returns: bool
	*********************************************************************
	LPARAMETERS tnX, tnY
	*********** toPt AS xfcPointF
	*********** toRect AS xfcRectangleF
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue, loPoint AS xfcPointF, loRect AS xfcRectangleF
			m.llValue = .F.
			
			DO CASE
			CASE VARTYPE(m.tnX) = "O" AND INLIST(m.tnX.BaseName, "Rectangle", "RectangleF")
				m.loRect = m.tnX
				m.llValue = (This.X <= m.loRect.X) AND ((m.loRect.X+m.loRect.Width) <= (This.X + This.Width)) ;
						AND (This.Y <= m.loRect.Y) AND ((m.loRect.Y+m.loRect.Height) <= (This.Y + This.Height)) ;
			
			CASE VARTYPE(m.tnX) = "O" AND INLIST(m.tnX.BaseName, "Point", "PointF")
				m.loPoint = m.tnX
				m.loPoint.GetExtent(@tnX, @tnY)
				m.llValue = This.Contains(m.tnX, m.tnY)
				
			CASE VARTYPE(m.tnX)+VARTYPE(m.tnY) == "NN"
				m.llValue = (This.X <= m.tnX) AND m.tnX < (This.X + This._Width) ;
						AND (This.Y <= m.tnY) AND m.tnY < (This.Y + This._Height)
		
			OTHERWISE
				*!ToDo Error?
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcRectangleF.Equals
	**
	** Tests whether obj is a RectangleF with the same location and size of this RectangleF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toObj AS Object
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			llValue = This.X = toObj.X ;
				AND This.Y = toObj.Y ;
				AND This._width = toObj.Width ;
				AND This._height = toObj.Height
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION FromLTRB
	*********************************************************************
	** Method: xfcRectangleF.FromLTRB
	**
	** Creates a RectangleF structure with upper-left corner and lower-right corner at
	** the specified locations.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.FromLTRB%28vs.80%29.aspx
	** Parameters:
	**  float left, float top, float right, float bottom
	** Returns: RectangleF
	*********************************************************************
	LPARAMETERS tnLeft, tnTop, tnRight, tnBottom
		
		*!ToDo: Test this function
		
		LOCAL loRectangle AS xfcRectangleF
		m.loRectangle = NULL
		
		LOCAL loExc AS Exception
		TRY
			m.loRectangle = CREATEOBJECT("xfcRectangleF", m.tnLeft, m.tnTop, ;
						m.tnRight-m.tnLeft, m.tnBottom-m.tnRight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRectangle
	ENDFUNC


	*********************************************************************
	FUNCTION GetExtent
	*********************************************************************
	** Method: xfcRectangleF.GetExtent
	**
	** History:
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnX, tnY, tnWidth, tnHeight
		
		m.tnX = This.X
		m.tnY = This.Y
		m.tnWidth = This._width
		m.tnHeight = This._height
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcRectangleF.GetHashCode
	**
	** Gets the hash code for this RectangleF structure. For information about the use
	** of hash codes, see Object.GetHashCode.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ACCESS
	*********************************************************************
	** Property: Height (Access)
	**
	** Gets or sets the height of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Height%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		RETURN This._height
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ASSIGN
	*********************************************************************
	** Property: Height (Assign)
	**
	** Gets or sets the height of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This._height = tnValue+0.0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Inflate
	*********************************************************************
	** Method: xfcRectangleF.Inflate
	**
	** Inflates this RectangleF by the specified amount.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**  2006/07/08: BDurban - Changed to match .NET
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Inflate%28vs.80%29.aspx
	** Parameters:
	**  SizeF size
	**  float x, float y
	**  RectangleF rect, float x, float y
	** Returns: void
	*********************************************************************
	LPARAMETERS tnX, tnY, tnP3
	*********** tnX, tnY
	*********** toSize AS xfcSizeF
	*********** toRect AS xfcRectangleF, tnX, tnY
		
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loReturn, loRect AS xfcRectangeF, loSize AS xfcSizeF
			leReturn = NULL
			
			DO CASE
			CASE VARTYPE(m.tnX)="O" AND INLIST(m.tnX.BaseName, "Size", "SizeF")
				m.loSize = m.tnX
				m.loSize.GetExtent(@tnX, @tnY)
				m.loRect = This
				
			CASE VARTYPE(m.toSize)="O" AND INLIST(m.toSize.BaseName, "Rectangle", "RectangleF")
				m.loRect = m.tnX
				m.tnX = EVL(m.tny, 0)
				m.tnY = EVL(m.tnP3, 0)
				m.leReturn = m.loRect
				
			CASE VARTYPE(m.tnX)+VARTYPE(m.tnY) == "NN"
				m.loRect = This
			
			OTHERWISE
				*!ToDo: Error handling?
				m.tnX = 0
				m.tnY = 0
				m.loRect = This
				
			ENDCASE
			
			m.loRect.X = m.loRect.X - m.tnX
			m.loRect.Y = m.loRect.Y - m.tnY
			m.loRect.Width = m.loRect.Width + (m.tnX*2)
			m.loRect.Height = m.loRect.Height + (m.tnY*2)
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.leReturn
	ENDFUNC


	*********************************************************************
	FUNCTION Intersect
	*********************************************************************
	** Method: xfcRectangleF.Intersect
	**
	** Returns a RectangleF structure that represents the intersection of two rectangles.
	** If there is no intersection, null is returned.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/11: BDurban - Coded
	**  2006/07/08: BDurban - Changed to match .NET
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Intersect%28vs.80%29.aspx
	** Parameters:
	**  RectangleF rect
	**  RectangleF a, RectangleF b
	** Returns: void or RectangleF
	*********************************************************************
	LPARAMETERS toRectA AS xfcRectangleF, toRectB AS xfcRectangleF
	*********** toRect AS xfcRectangleF
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRect AS xfcRectangleF
			LOCAL lnTop,lnLeft,lnBottom,lnRight
			
			DO CASE
			CASE PCOUNT() = 1
				m.loRect = This.Intersect(m.toRectA, This)
				This.X = m.loRect.X
				This.Y = m.loRect.Y
				This.Width = m.loRect.Width
				This.Height = m.loRect.Height
				
				m.loRect = NULL
			
			OTHERWISE
		
				m.lnLeft = MAX(m.toRectA.X, m.toRectB.X)
				m.lnRight = MIN(m.toRectA.X+m.toRectA.Width, m.toRectB.X+m.toRectB.Width)
				m.lnTop = MAX(m.toRectA.Y, m.toRectB.Y)
				m.lnBottom = MIN(m.toRectA.Y+m.toRectA.Height, m.toRectB.Y+m.toRectB.Height)
				
				IF m.lnRight > m.lnLeft AND m.lnBottom > m.lnTop
					m.loRect = CREATEOBJECT("xfcRectangleF", m.lnLeft, m.lnTop, (m.lnRight-m.lnLeft), (m.lnBottom-m.lnLeft))
				ELSE
					m.loRect = CREATEOBJECT("xfcRectangleF")
				ENDIF
			
			ENDCASE
					
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRect
	ENDFUNC


	*********************************************************************
	FUNCTION IntersectsWith
	*********************************************************************
	** Method: xfcRectangleF.IntersectsWith
	**
	** Determines if this rectangle intersects with rect.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/06/11: BDurban - Coded
	**	2006/07/08: BDurban - Tweaked to match .NET
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.IntersectsWith%28vs.80%29.aspx
	** Parameters:
	**  RectangleF rect
	** Returns: bool
	*********************************************************************
	LPARAMETERS toRect AS xfcRectangleF
		
		*!ToDo: Test this function
		
		LOCAL llValue
		
		LOCAL loExc AS Exception
		TRY
			m.llValue = m.toRect.X < (This.X + This.Width) ;
					AND This.X < (m.toRect.X + m.toRect.Width) ;
					AND m.toRect.Y < (This.Y + This.Height) ;
					AND This.Y < (m.toRect.Y + m.toRect.Height)
					
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION IsEmpty_ACCESS
	*********************************************************************
	** Property: IsEmpty (Access)
	**
	** Tests whether all numeric properties of this RectangleF have values of zero.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/07/08: BDurban - Changed to match .NET
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.IsEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			m.llValue = (This._width = 0 AND This._height = 0)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION Left_ACCESS
	*********************************************************************
	** Property: Left (Access)
	**
	** Gets the x-coordinate of the left edge of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Left%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		RETURN This.X
	ENDFUNC


	*********************************************************************
	FUNCTION Location_ACCESS
	*********************************************************************
	** Property: Location (Access)
	**
	** Gets or sets the coordinates of the upper-left corner of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Location%28vs.80%29.aspx
	** Returns: PointF
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loPoint AS xfcPointF
		m.loPoint = NULL
		
		LOCAL loExc AS Exception
		TRY
			m.loPoint = CREATEOBJECT("xfcPointF", This.X, This.Y)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPoint
	ENDFUNC


	*********************************************************************
	FUNCTION Location_ASSIGN
	*********************************************************************
	** Property: Location (Assign)
	**
	** Gets or sets the coordinates of the upper-left corner of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toPoint AS xfcPointF
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(m.toPoint)="O"
				This.X = toPoint.X
				This.Y = toPoint.Y
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Offset
	*********************************************************************
	** Method: xfcRectangleF.Offset
	**
	** Adjusts the location of this rectangle by the specified amount.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/11: BDurban - Coded
	**  2006/07/08: BDurban - Tweaked to match .NET
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Offset%28vs.80%29.aspx
	** Parameters:
	**  PointF pos
	**  float x, float y
	** Returns: void
	*********************************************************************
	LPARAMETERS tnX, tnY
	*********** toPos AS xfcPointF
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loPoint AS xfcPointF
			m.tnX = EVL(m.tnX, 0.0)
			m.tnY = EVL(m.tnY, 0.0)
			DO CASE
			CASE VARTYPE(m.tnX)="O"
				m.loPoint = m.tnX
				m.loPoint.GetExtent(@tnX, @tnY)
			
			CASE VARTYPE(m.tnXorPoint)+VARTYPE(m.tnY) == "NN"
				
			OTHERWISE
				*!ToDo: Error handling?
			ENDCASE
			
			This.X = This.X + m.tnX
			This.Y = This.Y + m.tnY
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Right_ACCESS
	*********************************************************************
	** Property: Right (Access)
	**
	** Gets the x-coordinate of the right edge of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Right%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN This.X + This._width
	ENDFUNC


	*********************************************************************
	FUNCTION Size_ACCESS
	*********************************************************************
	** Property: Size (Access)
	**
	** Gets or sets the size of this RectangleF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Size%28vs.80%29.aspx
	** Returns: SizeF
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loSize AS xfcSizeF
		m.loSize = NULL
		
		LOCAL loExc AS Exception
		TRY
			m.loSize = CREATEOBJECT("xfcSizeF", This._width, This._height)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loSize
	ENDFUNC


	*********************************************************************
	FUNCTION Size_ASSIGN
	*********************************************************************
	** Property: Size (Assign)
	**
	** Gets or sets the size of this RectangleF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toSize AS xfcSizeF
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(m.toSize) = "O"
				This._width  = toSize.Width
				This._height = toSize.Height
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Top_ACCESS
	*********************************************************************
	** Property: Top (Access)
	**
	** Gets the y-coordinate of the top edge of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Top%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		RETURN This.Y
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcRectangleF.ToString
	**
	** Converts the Location and Size of this RectangleF to a human-readable string.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		
		* RETURN [{X=]+ALLTRIM(TRANSFORM(This.X),1,"0"," ")+;
				[,Y=]+ALLTRIM(TRANSFORM(This.Y),1,"0"," ")+;
				[,Width=]+ALLTRIM(TRANSFORM(This._width),1,"0"," ")+;
				[,Height=]+ALLTRIM(TRANSFORM(This._height),1,"0"," ")+[}]
		
		
		RETURN [{X=]+ TRANSFORM(This.X)+;
				[,Y=]+ TRANSFORM(This.Y)+;
				[,Width=]+ TRANSFORM(This.width)+;
				[,Height=]+ TRANSFORM(This.height)+[}]
	ENDFUNC


	*********************************************************************
	FUNCTION ToVarbinary
	*********************************************************************
	** Method: xfcRectangleF.ToVarbinary
	**
	** Returns a binary representation of this RectangleF structure
	**
	** History:
	**	2006/03/28: BDurban - Coded
	**	2006/05/01: BDurban - Modified to handle arrays
	**  2006/07/08: BDurban - Changed method name
	*********************************************************************
	LPARAMETERS taRect AS xfcRectangleF, tiCount
		
		EXTERNAL ARRAY taRect
		
		LOCAL lqBinary, liX, liY, liWidth, liHeight, loRect
		m.lqBinary = 0h
		m.tiCount = 0
		
		DO CASE
		CASE PCOUNT() = 0
			m.lqBinary = 0h+;
				BINTOC(This.X, "f")+;
				BINTOC(This.Y, "f")+;
				BINTOC(This._width, "f")+;
				BINTOC(This._height, "f")
				
		CASE TYPE("m.taRect[1]") = "O"
			FOR EACH loRect AS xfcRectangleF IN taRect FOXOBJECT
				STORE 0 TO liX, liY, liWidth, liHeight
				m.loRect.GetExtent(@liX, @liY, @liWidth, @liHeight)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.liX, "f")+;
					BINTOC(m.liY, "f")+;
					BINTOC(m.liWidth, "f")+;
					BINTOC(m.liHeight, "f")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE TYPE("m.taRect[1,4]") = "N" AND ALEN(m.taRect,2) >= 4
			FOR m.lnLoop = 1 TO ALEN(m.taRect, 1)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.taRect[m.lnLoop,1], "f")+;
					BINTOC(m.taRect[m.lnLoop,2], "f")+;
					BINTOC(m.taRect[m.lnLoop,3], "f")+;
					BINTOC(m.taRect[m.lnLoop,4], "f")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE VARTYPE(m.taRect) = "O"
			m.loRect = m.taRect
			STORE 0 TO liX, liY, liWidth, liHeight
			m.loRect.GetExtent(@liX, @liY, @liWidth, @liHeight)
			m.lqBinary = 0h+;
				BINTOC(m.liX, "f")+;
				BINTOC(m.liY, "f")+;
				BINTOC(m.liWidth, "f")+;
				BINTOC(m.liHeight, "f")
			m.tiCount = m.tiCount + 1
		ENDCASE
		
		RETURN m.lqBinary
	ENDFUNC


	*********************************************************************
	FUNCTION Union
	*********************************************************************
	** Method: xfcRectangleF.Union
	**
	** Creates the smallest possible third rectangle that can contain both of two rectangles
	** that form a union.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/07/08: BDurban - Coded (to match .NET)
	**  2013/03/10: Doug Hennig - Fixed - http://vfpx.codeplex.com/workitem/32677
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Union%28vs.80%29.aspx
	** Parameters:
	**  RectangleF a, RectangleF b
	** Returns: RectangleF
	*********************************************************************
	LPARAMETERS toRectA AS xfcRectangleF, toRectB AS xfcRectangleF
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRect AS xfcRectangleF
			m.loRect = NULL
			
			m.lnLeft = MIN(m.toRectA.X, m.toRectB.Y)
			m.lnRight = MAX(m.toRectA.X+m.toRectA.Width, m.toRectB.X+m.toRectB.Width)
			m.lnTop = MIN(m.toRectA.Y, m.toRectB.Y)
			m.lnBottom = MAX(m.toRectA.Y+m.toRectA.Height, m.toRectB.Y+m.toRectB.Height)
			
			m.loRect = CREATEOBJECT("xfcRectangleF", m.lnLeft, m.lnTop, (m.lnRight-m.lnLeft), (m.lnBottom-m.lnTop))
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRect
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ACCESS
	*********************************************************************
	** Property: Width (Access)
	**
	** Gets or sets the width of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Width%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		RETURN This._width
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ASSIGN
	*********************************************************************
	** Property: Width (Assign)
	**
	** Gets or sets the width of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This._width = tnValue+0.0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION X_ASSIGN
	*********************************************************************
	** Property: X (Assign)
	**
	** Gets or sets the x-coordinate of the upper-left corner of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.X%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
	LPARAMETERS tnValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.X = tnValue+0.0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Y_ASSIGN
	*********************************************************************
	** Property: Y (Assign)
	**
	** Gets or sets the y-coordinate of the upper-left corner of this RectangleF structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.RectangleF.Y%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
	LPARAMETERS tnValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.Y = tnValue+0.0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="contains" type="method" display="Contains"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="fromltrb" type="method" display="FromLTRB"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="inflate" type="method" display="Inflate"/>]+;
		[<memberdata name="intersect" type="method" display="Intersect"/>]+;
		[<memberdata name="intersectswith" type="method" display="IntersectsWith"/>]+;
		[<memberdata name="offset" type="method" display="Offset"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="union" type="method" display="Union"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="bottom" type="property" display="Bottom"/>]+;
		[<memberdata name="height" type="property" display="Height"/>]+;
		[<memberdata name="isempty" type="property" display="IsEmpty"/>]+;
		[<memberdata name="left" type="property" display="Left"/>]+;
		[<memberdata name="location" type="property" display="Location"/>]+;
		[<memberdata name="right" type="property" display="Right"/>]+;
		[<memberdata name="size" type="property" display="Size"/>]+;
		[<memberdata name="top" type="property" display="Top"/>]+;
		[<memberdata name="width" type="property" display="Width"/>]+;
		[<memberdata name="x" type="property" display="X"/>]+;
		[<memberdata name="y" type="property" display="Y"/>]+;
		[<memberdata name="tovarbinary" type="method" display="ToVarbinary"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCREGION
DEFINE CLASS xfcRegion AS xfcgpobject
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Region"
	lastresult = 0
	
	DIMENSION _InternalArray[1]
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcRegion.Region
	**
	** Initializes a new Region object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Region%28vs.80%29.aspx
	** Parameters:
	**  [None]
	**  GraphicsPath path
	**  Rectangle rect
	**  RectangleF rect
	**  RegionData rgnData
	*********************************************************************
	LPARAMETERS toPath AS xfcGraphicsPath
	*********** toRect AS xfcRectangle
	*********** toRgnData AS xfcRegionData
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			LOCAL lnFunctionType
			m.lnFunctionType = 0
			
			LOCAL lhRegion
			m.lhRegion = 0
			
			DO CASE
			CASE VARTYPE(m.toPath) <> "O"
				This.SetStatus(xfcGdipCreateRegion(@lhRegion))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "GraphicsPath"
				This.SetStatus(xfcGdipCreateRegionPath(m.toPath.Handle, @lhRegion))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "RectangleF"
				This.SetStatus(xfcGdipCreateRegionRect(m.toPath.ToVarBinary(), @lhRegion))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Rectangle"
				This.SetStatus(xfcGdipCreateRegionRectI(m.toPath.ToVarBinary(), @lhRegion))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "RegionData"
				This.SetStatus(xfcGdipCreateRegionRectI(m.toPath.Data, @lhRegion))
			ENDCASE
			
			This.Handle = m.lhRegion
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcRegion.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipDeleteRegion(This.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	** Property: New
	**
	** History:
	** 2006/08/26: CChalom - Coded
	*********************************************************************
	LPARAMETERS toPath AS xfcGraphicsPath
	*********** toRect AS xfcRectangle
	*********** toRgnData AS xfcRegionData
		
		RETURN CREATEOBJECT(This.Class, m.toPath)
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcRegion.Clone
	**
	** Creates an exact copy if this Region object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/02: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Clone%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: Region
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRegion, lhRegion
			m.lhRegion = 0
			m.loRegion = NULL
			This.SetStatus(xfcGdipCloneRegion(This.Handle, @lhCloneRegion))
			IF(m.lhRegion <> 0)
				m.loRegion = CREATEOBJECT(This.Class)
				m.loRegion.Handle = m.lhRegion
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRegion
	ENDFUNC


	*********************************************************************
	FUNCTION Complement
	*********************************************************************
	** Method: xfcRegion.Complement
	**
	** Updates this Region object to the portion of the specified RectangleF structure
	** that does not intersect with this Region object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**  2006/08/26: CChalom - Fixed == on Rectangle
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Complement%28vs.80%29.aspx
	** Parameters:
	**  GraphicsPath path
	**  Rectangle rect
	**  RectangleF rect
	**  Region region
	** Returns: void
	*********************************************************************
	LPARAMETERS toPath AS xfcGraphicsPath
	*********** toRect AS xfcRectangle
	*********** toRegion AS xfcRegion
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			
			DO CASE
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Rectangle"
				This.SetStatus(xfcGdipCombineRegionRectI(This.Handle, m.toPath.ToVarBinary(), CombineModeComplement))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "RectangleF"
				This.SetStatus(xfcGdipCombineRegionRect(This.Handle, m.toPath.ToVarBinary(), CombineModeComplement))
		
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "GraphicsPath"
				This.SetStatus(xfcGdipCombineRegionPath(This.Handle, m.toPath.Handle, CombineModeComplement))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Region"
				This.SetStatus(xfcGdipCombineRegionRegion(This.Handle, m.toPath.Handle, CombineModeComplement))
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcRegion.Equals
	**
	** Overloaded.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Equals%28vs.80%29.aspx
	** Parameters:
	**  Region region, Graphics g
	** Returns: bool
	*********************************************************************
	LPARAMETERS toRegion AS xfcRegion, toG AS xfcGraphics
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liResult
			m.liResult = FALSE
			This.SetStatus(xfcGdipIsEqualRegion(This.Handle, m.toRegion.Handle, m.toG.Handle, @liResult))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN (m.liResult = TRUE)
	ENDFUNC


	*********************************************************************
	FUNCTION Exclude
	*********************************************************************
	** Method: xfcRegion.Exclude
	**
	** Updates this Region object to the portion of its interior that does not intersect
	** with the specified Rectangle structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**  2006/08/26: CChalom - Fixed == on Rectangle
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Exclude%28vs.80%29.aspx
	** Parameters:
	**  GraphicsPath path
	**  Rectangle rect
	**  RectangleF rect
	**  Region region
	** Returns: void
	*********************************************************************
	LPARAMETERS toPath AS xfcGraphicsPath
	*********** toRect AS xfcRectangle
	*********** toRegion AS xfcRegion
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			
			DO CASE
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Rectangle"
				This.SetStatus(xfcGdipCombineRegionRectI(This.Handle, m.toPath.ToVarBinary(), CombineModeExclude))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "RectangleF"
				This.SetStatus(xfcGdipCombineRegionRect(This.Handle, m.toPath.ToVarBinary(), CombineModeExclude))
		
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "GraphicsPath"
				This.SetStatus(xfcGdipCombineRegionPath(This.Handle, m.toPath.Handle, CombineModeExclude))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Region"
				This.SetStatus(xfcGdipCombineRegionRegion(This.Handle, m.toPath.Handle, CombineModeExclude))
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION FromHrgn
	*********************************************************************
	** Method: xfcRegion.FromHrgn
	**
	** Initializes a new Region object from a handle to the specified existing GDI region.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.FromHrgn%28vs.80%29.aspx
	** Parameters:
	**  IntPtr hrgn
	** Returns: Region
	*********************************************************************
	LPARAMETERS tHRgn AS IntPtr
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRegion AS xfcRegion, lhRegion
			m.lhRegion = 0
			m.loRegion = NULL
			This.SetStatus(xfcGdipCreateRegionHrgn(m.tHRgn, @lhRegion))
			IF(m.lhRegion <> 0)
				m.loRegion = CREATEOBJECT(This.Class)
				m.loRegion.Handle = m.lhRegion
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRegion
	ENDFUNC

	*********************************************************************
	FUNCTION GetBounds
	*********************************************************************
	** Method: xfcRegion.GetBounds
	**
	** Gets a RectangleF structure that represents a rectangle that bounds this Region
	** object on the drawing surface of a Graphics object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.GetBounds%28vs.80%29.aspx
	** Parameters:
	**  Graphics g
	** Returns: RectangleF
	*********************************************************************
	LPARAMETERS toG AS xfcGraphics
	
		*!ToDo: Test this function
	
		LOCAL loExc AS Exception
		TRY
			LOCAL loRectF, lqRect
			m.loRectF = NULL
			m.lqRect = REPLICATE(EMPTY_FLOAT, 4)
			This.SetStatus(xfcGdipGetRegionBounds(This.Handle, m.toG.Handle, @lqRect))
			*!*	This.SetStatus(xfcGdipGetRegionBoundsI(This.Handle, m.toG.Handle, @lqRect))

			m.loRectF = CREATEOBJECT("xfcRectangleF", m.lqRect)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
	
		RETURN m.loRectF
	ENDFUNC


	*********************************************************************
	FUNCTION GetHrgn
	*********************************************************************
	** Method: xfcRegion.GetHrgn
	**
	** Returns a Windows handle to this Region object in the specified graphics context.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.GetHrgn%28vs.80%29.aspx
	** Parameters:
	**  Graphics g
	** Returns: IntPtr
	*********************************************************************
	LPARAMETERS toG AS xfcGraphics
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lHRgn
			m.lHRgn = 0
			This.SetStatus(xfcGdipGetRegionHRgn(This.Handle, m.toG.Handle, @lHRgn))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lHRgn
	ENDFUNC


	*********************************************************************
	FUNCTION GetRegionData
	*********************************************************************
	** Method: xfcRegion.GetRegionData
	**
	** Returns a RegionData object that represents the information that describes this
	** Region object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.GetRegionData%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: RegionData
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loRegionData AS xfcRegionData, lqBuffer, liBufferSize, liSizeFilled
			m.loRegionData = NULL
			m.lqBuffer = 0h
			m.liBufferSize = 0
			m.liSizeFilled = 0
			
			This.SetStatus(xfcGdipGetRegionDataSize(This.Handle, @liBufferSize))
			m.lqBuffer = 0h+REPLICATE(0h00,m.liBufferSize)
			This.SetStatus(xfcGdipGetRegionData(This.Handle, @lqBuffer, m.liBufferSize, @liSizeFilled))
			m.loRegionData = CREATEOBJECT("xfcRegionData")
			m.loRegionData.Data = m.lqBuffer
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRegionData
	ENDFUNC


	*********************************************************************
	FUNCTION GetRegionScans
	*********************************************************************
	** Method: xfcRegion.GetRegionScans
	**
	** Returns an array of RectangleF structures that approximate this Region object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2007/09/01: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.GetRegionScans%28vs.80%29.aspx
	** Parameters:
	**  Matrix matrix
	** Returns: RectangleF[]
	*********************************************************************
	LPARAMETERS toMatrix AS xfcMatrix
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		LOCAL liCount, liLoop, lqRects
	
		LOCAL loExc AS Exception
		TRY
			m.liCount = 0
			This.SetStatus(xfcGdipGetRegionScansCount(This.Handle, @m.liCount, m.toMatrix.Handle))
		
			IF m.liCount > 0
				DIMENSION This._InternalArray[m.liCount]
				m.lqRects = 0h+REPLICATE(EMPTY_RECTANGLEF, m.liCount) 
				This.SetStatus(xfcGdipGetRegionScans(This.Handle, @m.lqRects, @m.liCount, m.toMatrix.Handle))
			
				FOR m.liLoop = 1 TO m.liCount
					This._InternalArray[m.liLoop] = ;
							CREATEOBJECT("xfcRectangleF", ;
								SUBSTR(m.lqRects, (m.liLoop-1)*SIZEOF_RECTANGLEF+1, SIZEOF_RECTANGLEF))
				ENDFOR
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
	
		IF m.liCount = 0
			RETURN NULL
		ELSE
			RETURN @This._InternalArray
		ENDIF
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION Intersect
	*********************************************************************
	** Method: xfcRegion.Intersect
	**
	** Updates this Region object to the intersection of itself with the specified Region
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**  2006/08/26: CChalom - Fixed == on Rectangle
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Intersect%28vs.80%29.aspx
	** Parameters:
	**  GraphicsPath path
	**  Rectangle rect
	**  RectangleF rect
	**  Region region
	** Returns: void
	*********************************************************************
	LPARAMETERS toPath AS xfcGraphicsPath
	*********** toRect AS xfcRectangle
	*********** toRegion AS xfcRegion
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			
			DO CASE
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Rectangle"
				This.SetStatus(xfcGdipCombineRegionRectI(This.Handle, m.toPath.ToVarBinary(), CombineModeIntersect))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "RectangleF"
				This.SetStatus(xfcGdipCombineRegionRect(This.Handle, m.toPath.ToVarBinary(), CombineModeIntersect))
		
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "GraphicsPath"
				This.SetStatus(xfcGdipCombineRegionPath(This.Handle, m.toPath.Handle, CombineModeIntersect))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Region"
				This.SetStatus(xfcGdipCombineRegionRegion(This.Handle, m.toPath.Handle, CombineModeIntersect))
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION IsEmpty
	*********************************************************************
	** Method: xfcRegion.IsEmpty
	**
	** Tests whether this Region object has an empty interior on the specified drawing
	** surface.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.IsEmpty%28vs.80%29.aspx
	** Parameters:
	**  Graphics g
	** Returns: bool
	*********************************************************************
	LPARAMETERS toG AS xfcGraphics
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liResult
			m.liResult = FALSE
			This.SetStatus(xfcGdipIsEmptyRegion(This.Handle, m.toG.Handle, @liResult))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN (m.liResult = TRUE)
	ENDFUNC


	*********************************************************************
	FUNCTION IsInfinite
	*********************************************************************
	** Method: xfcRegion.IsInfinite
	**
	** Tests whether this Region object has an infinite interior on the specified drawing
	** surface.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.IsInfinite%28vs.80%29.aspx
	** Parameters:
	**  Graphics g
	** Returns: bool
	*********************************************************************
	LPARAMETERS toG AS xfcGraphics
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liResult
			m.liResult = FALSE
			This.SetStatus(xfcGdipIsInfiniteRegion(This.Handle, m.toG.Handle, @liResult))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN (m.liResult = TRUE)
	ENDFUNC


	*********************************************************************
	FUNCTION IsVisible
	*********************************************************************
	** Method: xfcRegion.IsVisible
	**
	** Tests whether the specified rectangle is contained within this Region object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.IsVisible%28vs.80%29.aspx
	** Parameters:
	**  Point point
	**  PointF point
	**  Rectangle rect
	**  RectangleF rect
	**  Point point, Graphics g
	**  PointF point, Graphics g
	**  Rectangle rect, Graphics g
	**  RectangleF rect, Graphics g
	**  float x, float y
	**  int x, int y, Graphics g
	**  float x, float y, Graphics g
	**  int x, int y, int width, int height
	**  float x, float y, float width, float height
	**  int x, int y, int width, int height, Graphics g
	**  float x, float y, float width, float height, Graphics g
	** Returns: bool
	*********************************************************************
	LPARAMETERS tnX, tnY, ;
					tnWidth, tnHeight, ;
					toG AS xfcGraphics
	*********** tnX, tnY [, toG AS xfcGraphics]
	*********** toPoint AS xfcPoint [, toG AS xfcGraphics]
	*********** toRect AS xfcRectangle [, toG AS xfcGraphics]
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liResult, lhGraphics, loObject, lcVartype
			LOCAL lnFunctionType
			m.liResult = 0
			m.lnFunctionType = 0
			
			lcVarType = VARTYPE(m.tnX)+VARTYPE(m.tnY)+VARTYPE(m.tnWidth)+VARTYPE(m.tnHeight)+VARTYPE(m.toG)
			
			DO CASE
			CASE LEFT(m.lcVarType,4) == "NNNN"
				IF INT(m.tnX)=m.tnX AND INT(m.tnY)=m.tnY ;
						AND INT(m.tnWidth)=m.tnWidth ;
						AND INT(m.tnHeight)=m.tnHeight
					m.lnFunction = 3
				ELSE
					m.lnFunction = 4
				ENDIF
				
			CASE LEFT(m.lcVarType,2) == "NN"
				m.toG = m.tnWidth
				IF INT(m.tnX)=m.tnX AND INT(m.tnY)=m.tnY
					m.lnFunction = 2
				ELSE
					m.lnFunction = 1
				ENDIF
				
			CASE LEFT(m.lcVarType,1) == "O" AND m.tnX.BaseName == "PointF"
				m.toG = m.tnY
				m.loObject = m.tnX
				m.loObject.GetExtent(@tnX,@tnY)
				m.lnFunction = 1
				
			CASE LEFT(m.lcVarType,1) == "O" AND m.tnX.BaseName == "Point"
				m.toG = m.tnY
				m.loObject = m.tnX
				m.loObject.GetExtent(@tnX,@tnY)
				m.lnFunction = 2
				
			CASE LEFT(m.lcVarType,1) == "O" AND m.tnX.BaseName == "RectangleF"
				m.toG = m.tnY
				m.loObject = m.tnX
				m.loObject.GetExtent(@tnX,@tnY,@tnWidth,@tnHeight)
				m.lnFunction = 3
				
			CASE LEFT(m.lcVarType,1) == "O" AND m.tnX.BaseName == "Rectangle"
				m.toG = m.tnY
				m.loObject = m.tnX
				m.loObject.GetExtent(@tnX,@tnY,@tnWidth,@tnHeight)
				m.lnFunction = 4
				
			ENDCASE
			
			IF VARTYPE(m.toG) = "O"
				m.lhGraphics = m.toG.Handle
			ENDIF
			
			DO CASE
			CASE m.lnFunctionType = 1
				This.SetStatus(xfcGdipIsVisibleRegionPoint(This.Handle, m.tnX, m.tnY, m.lhGraphics, @liResult))
			CASE m.lnFunctionType = 2
				This.SetStatus(xfcGdipIsVisibleRegionPointI(This.Handle, m.tnX, m.tnY, m.lhGraphics, @liResult))
			CASE m.lnFunctionType = 3
				This.SetStatus(xfcGdipIsVisibleRegionRect(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.lhGraphics, @liResult))
			CASE m.lnFunctionType = 4
				This.SetStatus(xfcGdipIsVisibleRegionRectI(This.Handle, m.tnX, m.tnY, m.tnWidth, m.tnHeight, m.lhGraphics, @liResult))
			ENDCASE
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN (m.liResult = TRUE)
	ENDFUNC


	*********************************************************************
	FUNCTION MakeEmpty
	*********************************************************************
	** Method: xfcRegion.MakeEmpty
	**
	** Initializes this Region object to an empty interior.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.MakeEmpty%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: void
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetEmpty(THIs.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION MakeInfinite
	*********************************************************************
	** Method: xfcRegion.MakeInfinite
	**
	** Initializes this Region object to an infinite interior.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.MakeInfinite%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: void
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetInfinite(This.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Transform
	*********************************************************************
	** Method: xfcRegion.Transform
	**
	** Transforms this Region object by the specified Matrix object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Transform%28vs.80%29.aspx
	** Parameters:
	**  Matrix matrix
	** Returns: void
	*********************************************************************
	LPARAMETERS toMatrix AS xfcMatrix
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipTransformRegion(This.Handle, m.toMatrix.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION Translate
	*********************************************************************
	** Method: xfcRegion.Translate
	**
	** Offsets the coordinates of this Region object by the specified amount.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Translate%28vs.80%29.aspx
	** Parameters:
	**  int dx, int dy
	**  float dx, float dy
	** Returns: void
	*********************************************************************
	LPARAMETERS tnDx, tnDy
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF INT(m.tnDx)=m.tnDx AND INT(m.tnDy)=m.tnDy
				This.SetStatus(xfcGdipTranslateRegionI(This.Handle, m.tnDx, m.tnDy))
			ELSE
				This.SetStatus(xfcGdipTranslateRegion(This.Handle, m.tnDx, m.tnDy))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Union
	*********************************************************************
	** Method: xfcRegion.Union
	**
	** Updates this Region object to the union of itself and the specified GraphicsPath
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**  2006/08/26: CChalom - Fixed == on Rectangle
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Union%28vs.80%29.aspx
	** Parameters:
	**  GraphicsPath path
	**  Rectangle rect
	**  RectangleF rect
	**  Region region
	** Returns: void
	*********************************************************************
	LPARAMETERS toPath AS xfcGraphicsPath
	*********** toRect AS xfcRectangle
	*********** toRegion AS xfcRegion
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			
			DO CASE
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Rectangle"
				This.SetStatus(xfcGdipCombineRegionRectI(This.Handle, m.toPath.ToVarBinary(), CombineModeUnion))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "RectangleF"
				This.SetStatus(xfcGdipCombineRegionRect(This.Handle, m.toPath.ToVarBinary(), CombineModeUnion))
		
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "GraphicsPath"
				This.SetStatus(xfcGdipCombineRegionPath(This.Handle, m.toPath.Handle, CombineModeUnion))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Region"
				This.SetStatus(xfcGdipCombineRegionRegion(This.Handle, m.toPath.Handle, CombineModeUnion))
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Xor
	*********************************************************************
	** Method: xfcRegion.Xor
	**
	** Updates this Region object to the union minus the intersection of itself with the
	** specified GraphicsPath object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**  2006/08/26: CChalom - Fixed == on Rectangle
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Region.Xor%28vs.80%29.aspx
	** Parameters:
	**  GraphicsPath path
	**  Rectangle rect
	**  RectangleF rect
	**  Region region
	** Returns: void
	*********************************************************************
	LPARAMETERS toPath AS xfcGraphicsPath
	*********** toRect AS xfcRectangle
	*********** toRegion AS xfcRegion
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			
			DO CASE
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Rectangle"
				This.SetStatus(xfcGdipCombineRegionRectI(This.Handle, m.toPath.ToVarBinary(), CombineModeXor))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "RectangleF"
				This.SetStatus(xfcGdipCombineRegionRect(This.Handle, m.toPath.ToVarBinary(), CombineModeXor))
		
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "GraphicsPath"
				This.SetStatus(xfcGdipCombineRegionPath(This.Handle, m.toPath.Handle, CombineModeXor))
				
			CASE VARTYPE(m.toPath) = "O" AND m.toPath.BaseName == "Region"
				This.SetStatus(xfcGdipCombineRegionRegion(This.Handle, m.toPath.Handle, CombineModeXor))
			ENDCASE
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="complement" type="method" display="Complement"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="exclude" type="method" display="Exclude"/>]+;
		[<memberdata name="fromhrgn" type="method" display="FromHrgn"/>]+;
		[<memberdata name="getbounds" type="method" display="GetBounds"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gethrgn" type="method" display="GetHrgn"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="getregiondata" type="method" display="GetRegionData"/>]+;
		[<memberdata name="getregionscans" type="method" display="GetRegionScans"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="intersect" type="method" display="Intersect"/>]+;
		[<memberdata name="isempty" type="method" display="IsEmpty"/>]+;
		[<memberdata name="isinfinite" type="method" display="IsInfinite"/>]+;
		[<memberdata name="isvisible" type="method" display="IsVisible"/>]+;
		[<memberdata name="makeempty" type="method" display="MakeEmpty"/>]+;
		[<memberdata name="makeinfinite" type="method" display="MakeInfinite"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="transform" type="method" display="Transform"/>]+;
		[<memberdata name="translate" type="method" display="Translate"/>]+;
		[<memberdata name="union" type="method" display="Union"/>]+;
		[<memberdata name="xor" type="method" display="Xor"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCSIZE
DEFINE CLASS xfcSize AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "Size"
	IsEmpty = 0	&& Tests whether this Size has zero width and height.
	PROTECTED _height
	_height = 0
	PROTECTED _width
	_width = 0
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcSize.Size
	**
	** Initializes a new instance of the Size class from the specified Point.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**  2006/07/08: BDurban - Minor tweaks
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.Size%28vs.80%29.aspx
	** Parameters:
	**  Point pt
	**  int width, int height
	*********************************************************************
	LPARAMETERS tiWidth, tiHeight
	*********** toPt AS xfcPoint
		
		*!ToDo: Test this function
		
		LOCAL loPoint AS xfcPoint
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			DO CASE
			CASE VARTYPE(m.tiWidth)+VARTYPE(m.tiHeight) == "NN"
			** Do nothing
				
			CASE VARTYPE(m.tiWidth) = "O"		&& Point
				m.loPoint = m.tiWidth
				m.loPoint.GetExtent(@tiWidth, @tiHeight)
				
			CASE INLIST(VARTYPE(m.tiWidth),"Q")
				m.lqStruct = m.tiWidth
				m.tiWidth = CTOBIN(SUBSTR(lqStruct,1,4),"4rs")
				m.tiHeight = CTOBIN(SUBSTR(lqStruct,5,4),"4rs")
				
			OTHERWISE
				STORE 0 TO m.tiWidth, m.tiHeight
			ENDCASE
			
			This._Width  = INT(m.tiWidth)
			This._Height = INT(m.tiHeight)
				
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcSize.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	*********************************************************************
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tiWidth, tiHeight
		
		RETURN CREATEOBJECT(This.Class, m.tiWidth, m.tiHeight)
	ENDFUNC


	*********************************************************************
	FUNCTION Ceiling
	*********************************************************************
	** Method: xfcSize.Ceiling
	**
	** Converts the specified SizeF structure to a Size structure by rounding the values
	** of the Size structure to the next higher integer values.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.Ceiling%28vs.80%29.aspx
	** Parameters:
	**  SizeF value
	** Returns: Size
	*********************************************************************
	LPARAMETERS toSizeF AS xfcSizeF
		
		*!ToDo: Test this function
		
		LOCAL loSize AS xfcSize
		LOCAL liWidth, liHeight
		
		m.loSize = NULL
		STORE 0 TO m.liWidth, m.liHeight
		
		LOCAL loExc AS Exception
		TRY
			toSizeF.GetExtent(@liWidth, @liHeight)
			m.liWidth   = CEILING(m.liWidth)
			m.liHeight  = CEILING(m.liHeight)
			m.loSize = CREATEOBJECT(This.Class, m.liWidth, m.liHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loSize
	ENDFUNC


	*********************************************************************
	FUNCTION ToRectangle
	*********************************************************************
	** Method: xfcSize.ToRectangle
	**
	** History:
	**	2007/11/27: CChalom - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangle
		LOCAL liWidth, liHeight
		
		m.loRect = NULL
		STORE 0 TO m.liWidth, m.liHeight
		
		LOCAL loExc AS Exception
		TRY
			m.liWidth   = This.Width
			m.liHeight  = This.Height
			m.loRect = CREATEOBJECT("xfcRectangle", 0, 0, m.liWidth, m.liHeight)
		CATCH TO loExc
			THROW m.loExc
		ENDTRY
		
		RETURN m.loRect
	ENDFUNC


	*********************************************************************
	FUNCTION ToRectangleF
	*********************************************************************
	** Method: xfcSize.ToRectangleF
	**
	** History:
	**	2007/11/27: CChalom - Coded
	**	2013/03/19: CChalom - Coded - Thanks to MJindru - http://vfpx.codeplex.com/workitem/30995
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		LOCAL lnWidth, lnHeight
		
		m.loRect = NULL
		STORE 0 TO m.liWidth, m.liHeight
		
		LOCAL loExc AS Exception
		TRY
			m.lnWidth   = This.Width
			m.lnHeight  = This.Height
			m.loRect = CREATEOBJECT("xfcRectangleF", 0, 0, m.lnWidth, m.lnHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRect
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcSize.Equals
	**
	** Tests to see whether the specified object is a Size with the same dimensions as
	** this Size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toObj AS Object
		
		*!ToDo: Test this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			llValue = This._Width = toObj.Width ;
				AND This._Height = toObj.Height
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetExtent
	*********************************************************************
	** Method: xfcSize.GetExtent
	**
	** History:
	**	2006/05/01: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiWidth, tiHeight
		
		m.tiWidth = This._Width
		m.tiHeight = This._Height
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcSize.GetHashCode
	**
	** Returns a hash code for this Size structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ACCESS
	*********************************************************************
	** Property: Height (Access)
	**
	** Gets or sets the vertical component of this Size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/20: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.Height%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		*!ToDo: Test this function
		
		RETURN This._Height
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ASSIGN
	*********************************************************************
	** Property: Height (Assign)
	**
	** Gets or sets the vertical component of this Size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This._Height = INT(tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION IsEmpty_ACCESS
	*********************************************************************
	** Property: IsEmpty (Access)
	**
	** Tests whether this Size has zero width and height.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.IsEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN (This._Width=0 AND This._Height=0)
	ENDFUNC


	*********************************************************************
	FUNCTION Round
	*********************************************************************
	** Method: xfcSize.Round
	**
	** Converts the specified SizeF structure to a Size structure by rounding the values
	** of the Size structure to the nearest integer values.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.Round%28vs.80%29.aspx
	** Parameters:
	**  SizeF value
	** Returns: Size
	*********************************************************************
	LPARAMETERS toSizeF AS xfcSizeF
		
		*!ToDo: Test this function
		
		LOCAL loSize AS xfcSize
		LOCAL liWidth, liHeight
		
		m.loSize = NULL
		STORE 0 TO m.liWidth, m.liHeight
		
		LOCAL loExc AS Exception
		TRY
			toSizeF.GetExtent(@liWidth, @liHeight)
			m.liWidth   = ROUND(m.liWidth,0)
			m.liHeight  = ROUND(m.liHeight,0)
			m.loSize = CREATEOBJECT(This.Class, m.liWidth, m.liHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loSize
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcSize.ToString
	**
	** Creates a human-readable string that represents this Size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/07/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lcValue
			m.lcValue = [{Width=]+ALLTRIM(STR(This._Width))+[, Height=]+ALLTRIM(STR(This._Height))+[}]
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lcValue
	ENDFUNC


	*********************************************************************
	FUNCTION ToVarbinary
	*********************************************************************
	** Method: xfcSize.ToVarbinary
	**
	** Returns a binary representation of this Size structure
	**
	** History:
	**	2006/03/28: BDurban - Coded
	**	2006/05/01: BDurban - Modified to handle arrays
	*********************************************************************
	LPARAMETERS taSize AS xfcSize, tiCount
		
		LOCAL lqBinary, liWidth, liHeight, loSize
		m.lqBinary = 0h
		m.tiCount = 0
		
		DO CASE
		CASE PCOUNT() = 0
			m.lqBinary = 0h+;
				BINTOC(This._Width, "4rs")+;
				BINTOC(This._Height, "4rs")
				
		CASE TYPE("taSize[1]") = "O"
			FOR EACH loSize AS xfcSize IN taSize FOXOBJECT
				m.liWidth = 0
				m.liHeight = 0
				loSize.GetExtent(@liWidth, @liHeight)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.liWidth, "4rs")+;
					BINTOC(m.liHeight, "4rs")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE VARTYPE(m.taSize) = "O"
			m.loSize = m.taSize
			m.liWidth = 0
			m.liHeight = 0
			loSize.GetExtent(@liWidth, @liHeight)
			m.lqBinary = 0h+;
				BINTOC(m.liWidth, "4rs")+;
				BINTOC(m.liHeight, "4rs")
			m.tiCount = m.tiCount + 1
		ENDCASE
		
		RETURN m.lqBinary
	ENDFUNC


	*********************************************************************
	FUNCTION Truncate
	*********************************************************************
	** Method: xfcSize.Truncate
	**
	** Converts the specified SizeF structure to a Size structure by truncating the values
	** of the Size structure to the next lower integer values.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.Truncate%28vs.80%29.aspx
	** Parameters:
	**  SizeF value
	** Returns: Size
	*********************************************************************
	LPARAMETERS toSizeF AS xfcSizeF
		
		*!ToDo: Test this function
		
		LOCAL loSize AS xfcSize
		LOCAL liWidth, liHeight
		
		m.loSize = NULL
		STORE 0 TO m.liWidth, m.liHeight
		
		LOCAL loExc AS Exception
		TRY
			toSizeF.GetExtent(@liWidth, @liHeight)
			m.liWidth   = FLOOR(m.liWidth)
			m.liHeight  = FLOOR(m.liHeight)
			m.loSize = CREATEOBJECT(This.Class, m.liWidth, m.liHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loSize
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ACCESS
	*********************************************************************
	** Property: Width (Access)
	**
	** Gets or sets the horizontal component of this Size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/20: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.Size.Width%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		*!ToDo: Test this function
		
		RETURN This._Width
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ASSIGN
	*********************************************************************
	** Property: Width (Assign)
	**
	** Gets or sets the horizontal component of this Size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This._Width = INT(tiValue)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="ceiling" type="method" display="Ceiling"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="round" type="method" display="Round"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="truncate" type="method" display="Truncate"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="height" type="property" display="Height"/>]+;
		[<memberdata name="isempty" type="property" display="IsEmpty"/>]+;
		[<memberdata name="width" type="property" display="Width"/>]+;
		[<memberdata name="tovarbinary" type="method" display="ToVarbinary"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************


*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCSIZEF
DEFINE CLASS xfcSizeF AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "SizeF"
	IsEmpty = 0	&& Gets a value indicating whether this SizeF has zero width and height.
	PROTECTED _height
	_height = 0
	PROTECTED _width
	_width = .F.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcSizeF.SizeF
	**
	** Initializes a new instance of the SizeF class from the specified existing SizeF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.SizeF%28vs.80%29.aspx
	** Parameters:
	**  PointF pt
	**  SizeF size
	**  float width, float height
	*********************************************************************
	LPARAMETERS tnWidth, tnHeight
	*********** toPt AS xfcPointF
	*********** toSize AS xfcSizeF
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
		
			DODEFAULT()
			LOCAL loPoint AS xfcPoint
			
			DO CASE
			CASE VARTYPE(m.tnWidth) = "O" AND INLIST(m.tiWidth.ClassName,"Point","PointF","Size","SizeF")	&& Point, Size
				loPoint = m.tnWidth
				m.loPoint.GetExtent(@tnWidth, @tnHeight)
			CASE VARTYPE(m.tnWidth) = "N"
			
			CASE INLIST(VARTYPE(m.tnWidth),"C","Q")
				lqStruct = m.tnWidth
				m.tnWidth = CTOBIN(SUBSTR(lqStruct,1,4),"n")
				m.tnHeight = CTOBIN(SUBSTR(lqStruct,5,4),"n")
		
			OTHERWISE
				STORE 0 TO m.tnWidth, m.tnHeight
			ENDCASE
			
			This._Width  = m.tnWidth
			This._Height = m.tnHeight
		
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcSizeF.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	*********************************************************************
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tnWidth, tnHeight
		
		RETURN CREATEOBJECT(This.Class, m.tnWidth, m.tnHeight)
	ENDFUNC


	*********************************************************************
	FUNCTION ToRectangle
	*********************************************************************
	** Method: xfcSizeF.ToRectangle
	**
	** History:
	**	2007/11/28: CChalom - Coded
	**	2013/03/19: CChalom - Coded - Thanks to MJindru - http://vfpx.codeplex.com/workitem/30995
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangle
		LOCAL lnWidth, lnHeight
		
		m.loRect = NULL
		STORE 0 TO m.lnWidth, m.lnHeight
		
		LOCAL loExc AS Exception
		TRY
			m.lnWidth   = This.Width
			m.lnHeight  = This.Height
			m.loRect = CREATEOBJECT("xfcRectangle", 0, 0, m.lnWidth, m.lnHeight)
		CATCH TO loExc
			THROW m.loExc
		ENDTRY
		
		RETURN m.loRect
	ENDFUNC


	*********************************************************************
	FUNCTION ToRectangleF
	*********************************************************************
	** Method: xfcSizeF.ToRectangleF
	**
	** History:
	**	2007/11/28: CChalom - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loRect AS xfcRectangleF
		LOCAL lnWidth, lnHeight
		
		m.loRect = NULL
		STORE 0 TO m.lnWidth, m.lnHeight
		
		LOCAL loExc AS Exception
		TRY
			m.lnWidth   = This.Width
			m.lnHeight  = This.Height
			m.loRect = CREATEOBJECT("xfcRectangleF", 0, 0, m.lnWidth, m.lnHeight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loRect
	ENDFUNC


	*********************************************************************
	FUNCTION Equals
	*********************************************************************
	** Method: xfcSizeF.Equals
	**
	** Tests to see whether the specified object is a SizeF with the same dimensions as
	** this SizeF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.Equals%28vs.80%29.aspx
	** Parameters:
	**  object obj
	** Returns: bool
	*********************************************************************
	LPARAMETERS toObj AS Object
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL llValue
			m.llValue = .F.
			llValue = This._Width = toObj.Width ;
				AND This._Height = toObj.Height
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION GetExtent
	*********************************************************************
	** Method: xfcSizeF.GetExtent
	**
	** History:
	**	2006/05/01: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiWidth, tiHeight
		
		m.tiWidth = This._Width
		m.tiHeight = This._Height
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GetHashCode
	*********************************************************************
	** Method: xfcSizeF.GetHashCode
	**
	** Returns a hash code for this Size structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.GetHashCode%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: int
	*********************************************************************
		
		
		*!ToDo: Implement this function
		*!ToDo: Test this function
		ERROR 1999	&& Function not implemented
		RETURN NULL
		
		LOCAL loExc AS Exception
		TRY
			LOCAL liValue
			m.liValue = 0
		** This.SetStatus(GdipSomeFunction???())
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.liValue
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ACCESS
	*********************************************************************
	** Property: Height (Access)
	**
	** Gets or sets the vertical component of this SizeF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.Height%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN This._Height
	ENDFUNC


	*********************************************************************
	FUNCTION Height_ASSIGN
	*********************************************************************
	** Property: Height (Assign)
	**
	** Gets or sets the vertical component of this SizeF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This._Height = m.tnValue+0.0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION IsEmpty_ACCESS
	*********************************************************************
	** Property: IsEmpty (Access)
	**
	** Gets a value indicating whether this SizeF has zero width and height.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.IsEmpty%28vs.80%29.aspx
	** Returns: bool
	*********************************************************************
		
		*!ToDo: Implement this function
		
		LOCAL llValue
		m.llValue = .F.
		
		LOCAL loExc AS Exception
		TRY
			m.llValue = (This._Width = 0 ;
				AND This._Height = 0)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.llValue
	ENDFUNC


	*********************************************************************
	FUNCTION ToPointF
	*********************************************************************
	** Method: xfcSizeF.ToPointF
	**
	** Converts a SizeF to a PointF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.ToPointF%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: PointF
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loPointF
			m.loPointF = CREATEOBJECT("xfcPointF", This._Width, This._Height)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loPointF
	ENDFUNC


	*********************************************************************
	FUNCTION ToSize
	*********************************************************************
	** Method: xfcSizeF.ToSize
	**
	** Converts a SizeF to a Size.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.ToSize%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: Size
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL loSize
			m.loSize = CREATEOBJECT("xfcSize", This._Width, This._Height)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loSize
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcSizeF.ToString
	**
	** Creates a human-readable string that represents this SizeF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**  2006/09/02: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lcValue
			m.lcValue = "{Width=" + ALLTRIM(PADR(This._width,10)) + ", " + ;
					"Height=" + ALLTRIM(PADR(This._height,10)) + "}"
					
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lcValue
	ENDFUNC


	*********************************************************************
	FUNCTION tovarbinary
	*********************************************************************
	** Method: xfcSizeF.ToVarbinary
	**
	** Returns a binary representation of this SizeF structure
	**
	** History:
	**	2006/03/28: BDurban - Coded
	**	2006/05/01: BDurban - Modified to handle arrays
	**  2006/07/08: BDurban - Changed method name
	*********************************************************************
	LPARAMETERS taSize AS xfcSizeF, tiCount
		
		LOCAL lqBinary, liX, liY, loSize
		m.lqBinary = 0h
		m.tiCount = 0
		
		DO CASE
		CASE PCOUNT() = 0
			m.lqBinary = 0h+;
				BINTOC(This._Width, "f")+;
				BINTOC(This._Height, "f")
				
		CASE TYPE("taSize[1]") = "O"
			FOR EACH loSize AS xfcSizeF IN taSize FOXOBJECT
				m.liX = 0
				m.liY = 0
				m.loSize.GetExtent(@liX, @liY)
				m.lqBinary = m.lqBinary + ;
					BINTOC(m.liX, "f")+;
					BINTOC(m.liY, "f")
				m.tiCount = m.tiCount + 1
			ENDFOR
		
		CASE VARTYPE(m.taSize) = "O"
			m.loSize = m.taSize
			m.liX = 0
			m.liY = 0
			m.loSize.GetExtent(@liX, @liY)
			m.lqBinary = 0h+;
				BINTOC(m.liX, "f")+;
				BINTOC(m.liY, "f")
			m.tiCount = m.tiCount + 1
		ENDCASE
		
		RETURN m.lqBinary
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ACCESS
	*********************************************************************
	** Property: Width (Access)
	**
	** Gets or sets the horizontal component of this SizeF.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SizeF.Width%28vs.80%29.aspx
	** Returns: float
	*********************************************************************
		
		RETURN This._Width
	ENDFUNC


	*********************************************************************
	FUNCTION Width_ASSIGN
	*********************************************************************
	** Property: Width (Assign)
	**
	** Gets or sets the vertical component of this SizeF.
	**
	** History:
	**  2006/07/08: BDurban - Coded
	*********************************************************************
	LPARAMETERS tnValue
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This._Width = m.tnValue+0.0
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="topointf" type="method" display="ToPointF"/>]+;
		[<memberdata name="tosize" type="method" display="ToSize"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="height" type="property" display="Height"/>]+;
		[<memberdata name="isempty" type="property" display="IsEmpty"/>]+;
		[<memberdata name="width" type="property" display="Width"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCSOLIDBRUSH
DEFINE CLASS xfcSolidBrush AS xfcbrush
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "SolidBrush"
	Color = 0	&& Gets or sets the color of this SolidBrush object.
	lastresult = 0
	PROTECTED _color
	_color = .NULL.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcSolidBrush.SolidBrush
	**
	** Initializes a new SolidBrush object of the specified color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**	2006/05/03: BDurban - Modified to accept ARGB integer
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SolidBrush.SolidBrush%28vs.80%29.aspx
	** Parameters:
	**  Color color
	*********************************************************************
	LPARAMETERS toColor AS xfcColor, tlImmutable
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lhBrush, liArgb
			m.lhBrush = 0
			m.liArgb = 0xFF000000
			DODEFAULT()
			
			DO CASE
			CASE VARTYPE(m.toColor) = "N"
				m.liArgb = m.toColor
			CASE VARTYPE(m.toColor) = "O"
				m.liArgb = m.toColor.Argb
			ENDCASE
			This.SetStatus(xfcGdipCreateSolidFill(m.liArgb, @lhBrush))
			This.Handle = m.lhBrush
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS toColor AS xfcColor, tlImmutable
		
		RETURN CREATEOBJECT(This.Class, m.toColor, m.tlImmutable)
	ENDFUNC


	*********************************************************************
	FUNCTION Color_ACCESS
	*********************************************************************
	** Property: Color (Access)
	**
	** Gets or sets the color of this SolidBrush object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/25: BDurban - Changed to use Color property
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SolidBrush.Color%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liArgb
		m.liArgb = 0
		This._color = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetSolidFillColor(This.Handle, @liArgb))
			This._color = CREATEOBJECT("xfcColor", m.liArgb)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This._color
	ENDFUNC


	*********************************************************************
	FUNCTION Color_ASSIGN
	*********************************************************************
	** Property: Color (Assign)
	**
	** Gets or sets the color of this SolidBrush object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/07: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toColor
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(m.toColor) = "O"
				This.SetStatus(xfcGdipSetSolidFillColor(This.Handle, m.toColor.Argb))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="color" type="property" display="Color"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCSTRINGFORMAT
DEFINE CLASS xfcStringFormat AS xfcgpobject
*************************************************************************
*************************************************************************
*************************************************************************
	Alignment = 0	&& Gets or sets text alignment information.
	BaseName = "StringFormat"
	DigitSubstitutionLanguage = 0
	** Gets or sets the language that is used when local digits are substituted for western digits.
	DigitSubstitutionMethod = 0
	** Gets or sets the method to be used for digit substitution.
	FormatFlags = 0	&& Gets or sets a StringFormatFlags enumeration that contains formatting information.
	GenericDefault = 0	&& Gets a generic default StringFormat object.
	GenericTypographic = 0	&& Gets a generic typographic StringFormat object.
	HotkeyPrefix = 0	&& Gets or sets the HotkeyPrefix object for this StringFormat object.
	lastresult = 0
	LineAlignment = 0	&& Gets or sets the line alignment.
	Trimming = 0	&& Gets or sets the StringTrimming enumeration for this StringFormat object.
	DIMENSION _tabstops[1]

 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcStringFormat.StringFormat
	**
	** Initializes a new StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.StringFormat%28vs.80%29.aspx
	** Parameters:
	**  [None]
	**  StringFormat format
	**  StringFormatFlags options
	**  StringFormatFlags options, int language
	*********************************************************************
	LPARAMETERS tiOptions AS EnumStringFormatFlags , tiLanguage
	*********** toFormat AS xfcStringFormat
		
		*!ToDo: Test this function
		
		LOCAL lhStringFormat, loFormat AS xfcStringFormat
		m.lhStringFormat = 0
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			IF VARTYPE(m.tiOptions) = "O" AND m.tiOptions.BaseName = "StringFormat"
				m.loFormat = m.tiOptions
				This.SetStatus(xfcGdipCloneStringFormat(m.loFormat.Handle, @lhStringFormat))
			ELSE
			** Set default values for optional parameters
				m.tiOptions  = EVL(m.tiOptions, 0)
				m.tiLanguage = EVL(m.tiLanguage, LANG_NEUTRAL)
				This.SetStatus(xfcGdipCreateStringFormat(m.tiOptions, m.tiLanguage, @lhStringFormat))
			ENDIF
		
			This.Handle = m.lhStringFormat
			
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcStringFormat.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/08: BDurban - Coded
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF This.Handle <> 0
				This.SetStatus(xfcGdipDeleteStringFormat(This.Handle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS tiOptions AS EnumStringFormatFlags , tiLanguage
		
		RETURN CREATEOBJECT(This.Class, tiOptions, tiLanguage)
	ENDFUNC


	*********************************************************************
	FUNCTION Alignment_ACCESS
	*********************************************************************
	** Property: Alignment (Access)
	**
	** Gets or sets text alignment information.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.Alignment%28vs.80%29.aspx
	** Returns: StringAlignment
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liStringAlignment
		m.liStringAlignment = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetStringFormatAlign(This.Handle, @liStringAlignment))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liStringAlignment
	ENDFUNC


	*********************************************************************
	FUNCTION Alignment_ASSIGN
	*********************************************************************
	** Property: Alignment (Assign)
	**
	** Gets or sets text alignment information.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/08: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiStringAlignment
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetStringFormatAlign(This.Handle, m.tiStringAlignment))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcStringFormat.Clone
	**
	** Creates an exact copy of this StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.Clone%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: object
	*********************************************************************
		
		RETURN CREATEOBJECT(This.Class, This)
	ENDFUNC


	*********************************************************************
	FUNCTION DigitSubstitutionLanguage_ACCESS
	*********************************************************************
	** Property: DigitSubstitutionLanguage (Access)
	**
	** Gets or sets the language that is used when local digits are substituted for western
	** digits.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.DigitSubstitutionLanguage%28vs.80%29.aspx
	** Returns: int
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liLanguage
		m.liLanguage = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetStringFormatDigitSubstitution(This.Handle, @liLanguage, 0))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liLanguage
	ENDFUNC


	*********************************************************************
	FUNCTION DigitSubstitutionMethod_ACCESS
	*********************************************************************
	** Property: DigitSubstitutionMethod (Access)
	**
	** Gets or sets the method to be used for digit substitution.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.DigitSubstitutionMethod%28vs.80%29.aspx
	** Returns: StringDigitSubstitute
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liDigitSubstitute
		m.liDigitSubstitute = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetStringFormatDigitSubstitution(This.Handle, 0, @liDigitSubstitute))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liDigitSubstitute
	ENDFUNC


	*********************************************************************
	FUNCTION FormatFlags_ACCESS
	*********************************************************************
	** Property: FormatFlags (Access)
	**
	** Gets or sets a StringFormatFlags enumeration that contains formatting information.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.FormatFlags%28vs.80%29.aspx
	** Returns: StringFormatFlags
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liStringFormatFlags
		m.liStringFormatFlags = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetStringFormatFlags(This.Handle, @liStringFormatFlags))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liStringFormatFlags
	ENDFUNC


	*********************************************************************
	FUNCTION FormatFlags_ASSIGN
	*********************************************************************
	** Property: FormatFlags (Assign)
	**
	** Gets or sets a StringFormatFlags enumeration that contains formatting information.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/14: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiStringFormatFlags
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetStringFormatFlags(This.Handle, m.tiStringFormatFlags))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION GenericDefault_ACCESS
	*********************************************************************
	** Property: GenericDefault (Access)
	**
	** Gets a generic default StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.GenericDefault%28vs.80%29.aspx
	** Returns: StringFormat
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loStringFormat, lhStringFormat
		m.lhStringFormat = 0
		m.loStringFormat = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipStringFormatGetGenericDefault(@lhStringFormat))
				IF(m.lhStringFormat <> 0)
					m.loStringFormat = CREATEOBJECT(This.Class)
					m.loStringFormat.Handle = m.lhStringFormat
				ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loStringFormat
	ENDFUNC


	*********************************************************************
	FUNCTION GenericTypographic_ACCESS
	*********************************************************************
	** Property: GenericTypographic (Access)
	**
	** Gets a generic typographic StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.GenericTypographic%28vs.80%29.aspx
	** Returns: StringFormat
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loStringFormat, lhStringFormat
		m.lhStringFormat = 0
		m.loStringFormat = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipStringFormatGetGenericTypographic(@lhStringFormat))
				IF(m.lhStringFormat <> 0)
					m.loStringFormat = CREATEOBJECT(This.Class)
					m.loStringFormat.Handle = m.lhStringFormat
				ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loStringFormat
	ENDFUNC


	*********************************************************************
	FUNCTION GetTabStops
	*********************************************************************
	** Method: xfcStringFormat.GetTabStops
	**
	** Gets the tab stops for this StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/10: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.GetTabStops%28vs.80%29.aspx
	** Parameters:
	**  out float firstTabOffset
	** Returns: float[]
	*********************************************************************
	LPARAMETERS tnFirstTabOffset AS Number
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lqTabStops, liCount
			m.tnFirstTabOffset = EVL(m.tnFirstTabOffset, 0)
			m.liCount = 0	
			This.SetStatus(xfcGdipGetStringFormatTabStopCount(This.Handle, @liCount))
			lqTabStops = REPLICATE(BINTOC(0.0,"f"), m.liCount)
			This.SetStatus(xfcGdipGetStringFormatTabStops(This.Handle, m.liCount, @tnFirstTabOffset, @lqTabStops))
			IF m.liCount = 0
				DIMENSION This._TabStops[1]
				This._TabStops = .F.
			ELSE
				DIMENSION This._TabStops[m.liCount]
				FOR lnStep = 1 TO m.liCount
					This._TabStops[m.lnStep] = CTOBIN(SUBSTR(lqTabStops,(m.lnStep-1)*4+1,4),"n")
				ENDFOR
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN @This._TabStops
	ENDFUNC


	*********************************************************************
	FUNCTION HotkeyPrefix_ACCESS
	*********************************************************************
	** Property: HotkeyPrefix (Access)
	**
	** Gets or sets the HotkeyPrefix object for this StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/14: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.HotkeyPrefix%28vs.80%29.aspx
	** Returns: HotkeyPrefix
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liHotkeyPrefix
		m.liHotkeyPrefix = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetStringFormatHotkeyPrefix(This.Handle, @liHotkeyPrefix))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liHotkeyPrefix
	ENDFUNC


	*********************************************************************
	FUNCTION HotkeyPrefix_ASSIGN
	*********************************************************************
	** Property: HotkeyPrefix (Assign)
	**
	** Gets or sets the HotkeyPrefix object for this StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/14: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiHotkeyPrefix
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetStringFormatHotkeyPrefix(This.Handle, m.tiHotkeyPrefix))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION LineAlignment_ACCESS
	*********************************************************************
	** Property: LineAlignment (Access)
	**
	** Gets or sets the line alignment.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/08: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.LineAlignment%28vs.80%29.aspx
	** Returns: StringAlignment
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liStringAlignment
		m.liStringAlignment = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetStringFormatLineAlign(This.Handle, @liStringAlignment))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liStringAlignment
	ENDFUNC


	*********************************************************************
	FUNCTION LineAlignment_ASSIGN
	*********************************************************************
	** Property: LineAlignment (Assign)
	**
	** Gets or sets the line alignment.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/08: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiStringAlignment
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetStringFormatLineAlign(This.Handle, m.tiStringAlignment))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION SetDigitSubstitution
	*********************************************************************
	** Method: xfcStringFormat.SetDigitSubstitution
	**
	** Specifies the language and method to be used when local digits are substituted for
	** western digits.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.SetDigitSubstitution%28vs.80%29.aspx
	** Parameters:
	**  int language, StringDigitSubstitute substitute
	** Returns: void
	*********************************************************************
	LPARAMETERS tiLanguage, tiSubstitute AS EnumStringDigitSubstitute
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetStringFormatDigitSubstitution(This.Handle, m.tiLanguage, m.tiSubstitute))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION SetMeasurableCharacterRanges
	*********************************************************************
	** Method: xfcStringFormat.SetMeasurableCharacterRanges
	**
	** Specifies an array of CharacterRange structures that represent the ranges of characters
	** measured by a call to the Graphics.MeasureCharacterRanges method.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2007/09/01: BDurban - Coded
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
	** 
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.SetMeasurableCharacterRanges%28vs.80%29.aspx
	** Parameters:
	**  CharacterRange[] ranges
	** Returns: void
	*********************************************************************
	LPARAMETERS taoRanges AS xfcCharacterRange

		*!ToDo: Test this function
		LOCAL m.loCharRange AS xfcCharacterRange, lqRanges, liRangeCount
	
		LOCAL loExc AS Exception
		TRY
			m.lqRanges = 0h
			m.liRangeCount = 0
			FOR EACH m.loCharRange IN m.taoRanges 
				m.lqRanges = m.lqRanges + m.loCharRange.ToVarbinary()
				m.liRangeCount = m.liRangeCount + 1
			ENDFOR
			This.SetStatus(xfcGdipSetStringFormatMeasurableCharacterRanges(This.Handle, m.liRangeCount, m.lqRanges))
	
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
	
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION SetTabStops
	*********************************************************************
	** Method: xfcStringFormat.SetTabStops
	**
	** Sets tab stops for this StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/03: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.SetTabStops%28vs.80%29.aspx
	** Parameters:
	**  float firstTabOffset, float[] tabStops
	** Returns: void
	*********************************************************************
	LPARAMETERS tnFirstTabOffset, tanTabStops AS Number
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			LOCAL lqTabStops, liCount, tnStop
			lqTabStops = 0h
			liCount = 0
			FOR EACH tnStop IN tanTabStops
				m.lqTabStops = m.lqTabStops + BINTOC(tnStop,"f")
				m.liCount = m.liCount + 1
			ENDFOR
			This.SetStatus(xfcGdipSetStringFormatTabStops(This.Handle, m.tnFirstTabOffset, m.liCount, m.lqTabStops))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ToString
	*********************************************************************
	** Method: xfcStringFormat.ToString
	**
	** Converts this StringFormat object to a human-readable string.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2007/08/31: Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.ToString%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: string
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			LOCAL lcValue
			m.lcValue = ("[StringFormat, FormatFlags=" + This.FormatFlags.ToString() + "]")
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.lcValue
	ENDFUNC


	*********************************************************************
	FUNCTION Trimming_ACCESS
	*********************************************************************
	** Property: Trimming (Access)
	**
	** Gets or sets the StringTrimming enumeration for this StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/14: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.StringFormat.Trimming%28vs.80%29.aspx
	** Returns: StringTrimming
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liStringTrimming
		m.liStringTrimming = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetStringFormatTrimming(This.Handle, @liStringTrimming))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liStringTrimming
	ENDFUNC


	*********************************************************************
	FUNCTION Trimming_ASSIGN
	*********************************************************************
	** Property: Trimming (Assign)
	**
	** Gets or sets the StringTrimming enumeration for this StringFormat object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/14: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiStringTrimming
		
		*!ToDo: Implement this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetStringFormatTrimming(This.Handle, m.tiStringTrimming))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="gettabstops" type="method" display="GetTabStops"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="setdigitsubstitution" type="method" display="SetDigitSubstitution"/>]+;
		[<memberdata name="setmeasurablecharacterranges" type="method" display="SetMeasurableCharacterRanges"/>]+;
		[<memberdata name="settabstops" type="method" display="SetTabStops"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="alignment" type="property" display="Alignment"/>]+;
		[<memberdata name="digitsubstitutionlanguage" type="property" display="DigitSubstitutionLanguage"/>]+;
		[<memberdata name="digitsubstitutionmethod" type="property" display="DigitSubstitutionMethod"/>]+;
		[<memberdata name="formatflags" type="property" display="FormatFlags"/>]+;
		[<memberdata name="genericdefault" type="property" display="GenericDefault"/>]+;
		[<memberdata name="generictypographic" type="property" display="GenericTypographic"/>]+;
		[<memberdata name="hotkeyprefix" type="property" display="HotkeyPrefix"/>]+;
		[<memberdata name="linealignment" type="property" display="LineAlignment"/>]+;
		[<memberdata name="trimming" type="property" display="Trimming"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCSYSTEMBRUSHES
DEFINE CLASS xfcSystemBrushes AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	ActiveBorder = 0	&& Gets a SolidBrush object that is the color of the active window's border.
	ActiveCaption = 0	&& Gets a SolidBrush object that is the color of the background of the active window's title bar.
	ActiveCaptionText = 0	&& Gets a SolidBrush object that is the color of the text in the active window's title bar.
	AppWorkspace = 0	&& Gets a SolidBrush object that is the color of the application workspace. The application workspace is the area in a multiple-document view that is not being occupied by documents.
	BaseName = "SystemBrushes"
	Control = 0	&& Gets a SolidBrush object that is the face color of a 3-D element.
	ControlDark = 0	&& Gets a SolidBrush object that is the shadow color of a 3-D element. The shadow color is applied to parts of a 3-D element that face away from the light source.
	ControlDarkDark = 0	&& Gets a SolidBrush object that is the dark shadow color of a 3-D element. The dark shadow color is applied to the parts of a 3-D element that are the darkest color.
	ControlLight = 0	&& Gets a SolidBrush object that is the light color of a 3-D element. The light color is applied to parts of a 3-D element that face the light source.
	ControlLightLight = 0	&& Gets a SolidBrush object that is the highlight color of a 3-D element. The highlight color is applied to the parts of a 3-D element that are the lightest color.
	ControlText = 0	&& Gets a SolidBrush object that is the color of text in a 3-D element.
	Desktop = 0	&& Gets a SolidBrush object that is the color of the desktop.
	Highlight = 0	&& Gets a SolidBrush object that is the color of the background of selected items. This includes selected menu items as well as selected text. For example, the brush may be the color used for the background of selected items in a list box.
	HighlightText = 0	&& Gets a SolidBrush object that is the color of the text of selected items. This includes selected menu items as well as selected text. For example, the brush may be the color used for the text of selected items in a list box.
	HotTrack = 0	&& Gets a SolidBrush object that is the color used to designate a hot-tracked item. Single-clicking a hot-tracked item executes the item.
	InactiveBorder = 0	&& Gets a SolidBrush object that is the color of an inactive window's border.
	InactiveCaption = 0	&& Gets a SolidBrush object that is the color of the background of an inactive window's title bar.
	Info = 0	&& Gets a SolidBrush object that is the color of the background of a ToolTip.
	Menu = 0	&& Gets a SolidBrush object that is the color of a menu's background.
	ScrollBar = 0	&& Gets a SolidBrush object that is the color of the background of a scroll bar.
	Window = 0	&& Gets a SolidBrush object that is the color of the background in the client area of a window.
	WindowText = 0	&& Gets a SolidBrush object that is the color of the text in the client area of a window.
	PROTECTED oSysColor
	oSysColor = .NULL.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcSystemBrushes.SystemBrushes
	**
	** Each property of the SystemBrushes class is a SolidBrush object that is the color
	** of a Windows display element.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes%28vs.80%29.aspx
	** Parameters:
		
	*********************************************************************
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			This.oSysColor = CREATEOBJECT("xfcSystemColors")
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcSystemBrushes.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.oSysColor = NULL
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION ActiveBorder_ACCESS
	*********************************************************************
	** Property: ActiveBorder (Access)
	**
	** Gets a SolidBrush object that is the color of the active window's border.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ActiveBorder%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.ActiveBorder)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION ActiveCaptionText_ACCESS
	*********************************************************************
	** Property: ActiveCaptionText (Access)
	**
	** Gets a SolidBrush object that is the color of the text in the active window's title
	** bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ActiveCaptionText%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.ActiveCaptionText)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION ActiveCaption_ACCESS
	*********************************************************************
	** Property: ActiveCaption (Access)
	**
	** Gets a SolidBrush object that is the color of the background of the active window's
	** title bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ActiveCaption%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.ActiveCaption)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION AppWorkspace_ACCESS
	*********************************************************************
	** Property: AppWorkspace (Access)
	**
	** Gets a SolidBrush object that is the color of the application workspace. The application
	** workspace is the area in a multiple-document view that is not being occupied by
	** documents.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.AppWorkspace%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.AppWorkspace)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION ControlDarkDark_ACCESS
	*********************************************************************
	** Property: ControlDarkDark (Access)
	**
	** Gets a SolidBrush object that is the dark shadow color of a 3-D element. The dark
	** shadow color is applied to the parts of a 3-D element that are the darkest color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ControlDarkDark%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.ControlDarkDark)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION ControlDark_ACCESS
	*********************************************************************
	** Property: ControlDark (Access)
	**
	** Gets a SolidBrush object that is the shadow color of a 3-D element. The shadow color
	** is applied to parts of a 3-D element that face away from the light source.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ControlDark%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.ControlDark)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION ControlLightLight_ACCESS
	*********************************************************************
	** Property: ControlLightLight (Access)
	**
	** Gets a SolidBrush object that is the highlight color of a 3-D element. The highlight
	** color is applied to the parts of a 3-D element that are the lightest color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ControlLightLight%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.ControlLightLight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION ControlLight_ACCESS
	*********************************************************************
	** Property: ControlLight (Access)
	**
	** Gets a SolidBrush object that is the light color of a 3-D element. The light color
	** is applied to parts of a 3-D element that face the light source.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ControlLight%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.ControlLight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION ControlText_ACCESS
	*********************************************************************
	** Property: ControlText (Access)
	**
	** Gets a SolidBrush object that is the color of text in a 3-D element.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ControlText%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.ControlText)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION Control_ACCESS
	*********************************************************************
	** Property: Control (Access)
	**
	** Gets a SolidBrush object that is the face color of a 3-D element.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.Control%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.Control)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION Desktop_ACCESS
	*********************************************************************
	** Property: Desktop (Access)
	**
	** Gets a SolidBrush object that is the color of the desktop.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.Desktop%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.Desktop)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION FromSystemColor
	*********************************************************************
	** Method: xfcSystemBrushes.FromSystemColor
	**
	** Creates a Brush object from the specified Color color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.FromSystemColor%28vs.80%29.aspx
	** Parameters:
	**  Color c
	** Returns: Brush
	*********************************************************************
	LPARAMETERS toC AS xfcColor
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcBrush", toC)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION HighlightText_ACCESS
	*********************************************************************
	** Property: HighlightText (Access)
	**
	** Gets a SolidBrush object that is the color of the text of selected items. This includes
	** selected menu items as well as selected text. For example, the brush may be the
	** color used for the text of selected items in a list box.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.HighlightText%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.HighlightText)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION Highlight_ACCESS
	*********************************************************************
	** Property: Highlight (Access)
	**
	** Gets a SolidBrush object that is the color of the background of selected items.
	** This includes selected menu items as well as selected text. For example, the brush
	** may be the color used for the background of selected items in a list box.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.Highlight%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.Highlight)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION HotTrack_ACCESS
	*********************************************************************
	** Property: HotTrack (Access)
	**
	** Gets a SolidBrush object that is the color used to designate a hot-tracked item.
	** Single-clicking a hot-tracked item executes the item.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.HotTrack%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.HotTrack)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION InactiveBorder_ACCESS
	*********************************************************************
	** Property: InactiveBorder (Access)
	**
	** Gets a SolidBrush object that is the color of an inactive window's border.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.InactiveBorder%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.InactiveBorder)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION InactiveCaption_ACCESS
	*********************************************************************
	** Property: InactiveCaption (Access)
	**
	** Gets a SolidBrush object that is the color of the background of an inactive window's
	** title bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.InactiveCaption%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.InactiveCaption)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION Info_ACCESS
	*********************************************************************
	** Property: Info (Access)
	**
	** Gets a SolidBrush object that is the color of the background of a ToolTip.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.Info%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.Info)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION Menu_ACCESS
	*********************************************************************
	** Property: Menu (Access)
	**
	** Gets a SolidBrush object that is the color of a menu's background.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.Menu%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.Menu)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION ScrollBar_ACCESS
	*********************************************************************
	** Property: ScrollBar (Access)
	**
	** Gets a SolidBrush object that is the color of the background of a scroll bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.ScrollBar%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.Scrollbar)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION WindowText_ACCESS
	*********************************************************************
	** Property: WindowText (Access)
	**
	** Gets a SolidBrush object that is the color of the text in the client area of a window.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.WindowText%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.WindowText)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC


	*********************************************************************
	FUNCTION Window_ACCESS
	*********************************************************************
	** Property: Window (Access)
	**
	** Gets a SolidBrush object that is the color of the background in the client area
	** of a window.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemBrushes.Window%28vs.80%29.aspx
	** Returns: Brush
	*********************************************************************
		
		LOCAL loBrush
		
		
		LOCAL loExc AS Exception
		TRY
			m.loBrush = CREATEOBJECT("xfcSolidbrush", This.oSysColor.Window)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loBrush
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="fromsystemcolor" type="method" display="FromSystemColor"/>]+;
		[<memberdata name="activeborder" type="property" display="ActiveBorder"/>]+;
		[<memberdata name="activecaption" type="property" display="ActiveCaption"/>]+;
		[<memberdata name="activecaptiontext" type="property" display="ActiveCaptionText"/>]+;
		[<memberdata name="appworkspace" type="property" display="AppWorkspace"/>]+;
		[<memberdata name="control" type="property" display="Control"/>]+;
		[<memberdata name="controldark" type="property" display="ControlDark"/>]+;
		[<memberdata name="controldarkdark" type="property" display="ControlDarkDark"/>]+;
		[<memberdata name="controllight" type="property" display="ControlLight"/>]+;
		[<memberdata name="controllightlight" type="property" display="ControlLightLight"/>]+;
		[<memberdata name="controltext" type="property" display="ControlText"/>]+;
		[<memberdata name="desktop" type="property" display="Desktop"/>]+;
		[<memberdata name="highlight" type="property" display="Highlight"/>]+;
		[<memberdata name="highlighttext" type="property" display="HighlightText"/>]+;
		[<memberdata name="hottrack" type="property" display="HotTrack"/>]+;
		[<memberdata name="inactiveborder" type="property" display="InactiveBorder"/>]+;
		[<memberdata name="inactivecaption" type="property" display="InactiveCaption"/>]+;
		[<memberdata name="info" type="property" display="Info"/>]+;
		[<memberdata name="menu" type="property" display="Menu"/>]+;
		[<memberdata name="scrollbar" type="property" display="ScrollBar"/>]+;
		[<memberdata name="window" type="property" display="Window"/>]+;
		[<memberdata name="windowtext" type="property" display="WindowText"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCSYSTEMCOLORS
DEFINE CLASS xfcSystemColors AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	ActiveBorder = NULL	&& Gets a Color structure that is the color of the active window's border.
	ActiveCaption = NULL	&& Gets a Color structure that is the color of the background of the active window's title bar.
	ActiveCaptionText = NULL	&& Gets a Color structure that is the color of the text in the active window's title bar.
	AppWorkspace = NULL	&& Gets a Color structure that is the color of the application workspace. The application workspace is the area in a multiple-document view that is not being occupied by documents.
	BaseName = "SystemColors"
	Control = NULL	&& Gets a Color structure that is the face color of a 3-D element.
	ControlDark = NULL	&& Gets a Color structure that is the shadow color of a 3-D element. The shadow color is applied to parts of a 3-D element that face away from the light source.
	ControlDarkDark = NULL	&& Gets a Color structure that is the dark shadow color of a 3-D element. The dark shadow color is applied to the parts of a 3-D element that are the darkest color.
	ControlLight = NULL	&& Gets a Color structure that is the light color of a 3-D element. The light color is applied to parts of a 3-D element that face the light source.
	ControlLightLight = NULL	&& Gets a Color structure that is the highlight color of a 3-D element. The highlight color is applied to the parts of a 3-D element that are the lightest color.
	ControlText = NULL	&& Gets a Color structure that is the color of text in a 3-D element.
	Desktop = NULL	&& Gets a Color structure that is the color of the desktop.
	GrayText = NULL	&& Gets a Color structure that is the color of dimmed text. Items in a list that are disabled are displayed in dimmed text.
	Highlight = NULL	&& Gets a Color structure that is the color of the background of selected items. This includes selected menu items as well as selected text. For example, the Color structure may be the color used for the background of selected items in a list box.
	HighlightText = NULL	&& Gets a Color structure that is the color of the text of selected items. For example, the Color structure may be the color used for the text of selected items in a list box.
	HotTrack = NULL	&& Gets a Color structure that is the color used to designate a hot-tracked item. Single-clicking a hot-tracked item executes the item.
	InactiveBorder = NULL	&& Gets a Color structure that is the color of an inactive window's border.
	InactiveCaption = NULL	&& Gets a Color structure that is the color of the background of an inactive window's title bar.
	InactiveCaptionText = NULL	&& Gets a Color structure that is the color of the text in an inactive window's title bar.
	Info = NULL	&& Gets a Color structure that is the color of the background of a ToolTip.
	InfoText = NULL	&& Gets a Color structure that is the color of the text of a ToolTip.
	Menu = NULL	&& Gets a Color structure that is the color of a menu's background.
	MenuText = NULL	&& Gets a Color structure that is the color of a menu's text.
	ScrollBar = NULL	&& Gets a Color structure that is the color of the background of a scroll bar.
	Window = NULL	&& Gets a Color structure that is the color of the background in the client area of a window.
	WindowFrame = NULL	&& Gets a Color structure that is the color of a window frame.
	WindowText = NULL	&& Gets a Color structure that is the color of the text in the client area of a window.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcSystemColors.SystemColors
	**
	** Each property of the SystemColors class is a Color structure that is the color of
	** a Windows display element.
	**
	** History:
	**  2006/03/07: Auto Generated
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors%28vs.80%29.aspx
	** Parameters:
		
	*********************************************************************
		
		LOCAL loExc AS EXCEPTION
		TRY
			DODEFAULT()
			THIS.ADDPROPERTY("oColor",CREATEOBJECT("xfcColor"))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcSystemColors.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.oColor=NULL
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION ActiveBorder_ACCESS
	*********************************************************************
	** Property: ActiveBorder (Access)
	**
	** Gets a Color structure that is the color of the active window's border.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ActiveBorder%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ActiveBorder = This.oColor.FromRGB(xfcGetSysColor(COLOR_ACTIVEBORDER))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ActiveBorder
	ENDFUNC


	*********************************************************************
	FUNCTION ActiveCaptionText_ACCESS
	*********************************************************************
	** Property: ActiveCaptionText (Access)
	**
	** Gets a Color structure that is the color of the text in the active window's title
	** bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ActiveCaptionText%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ActiveCaptionText = This.oColor.FromRGB(xfcGetSysColor(COLOR_CAPTIONTEXT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ActiveCaptionText
	ENDFUNC


	*********************************************************************
	FUNCTION ActiveCaption_ACCESS
	*********************************************************************
	** Property: ActiveCaption (Access)
	**
	** Gets a Color structure that is the color of the background of the active window's
	** title bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ActiveCaption%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ActiveCaption = This.oColor.FromRGB(xfcGetSysColor(COLOR_ACTIVECAPTION))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ActiveCaption
	ENDFUNC


	*********************************************************************
	FUNCTION AppWorkspace_ACCESS
	*********************************************************************
	** Property: AppWorkspace (Access)
	**
	** Gets a Color structure that is the color of the application workspace. The application
	** workspace is the area in a multiple-document view that is not being occupied by
	** documents.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.AppWorkspace%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.AppWorkspace = This.oColor.FromRGB(xfcGetSysColor(COLOR_APPWORKSPACE))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.AppWorkspace
	ENDFUNC


	*********************************************************************
	FUNCTION ControlDarkDark_ACCESS
	*********************************************************************
	** Property: ControlDarkDark (Access)
	**
	** Gets a Color structure that is the dark shadow color of a 3-D element. The dark
	** shadow color is applied to the parts of a 3-D element that are the darkest color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ControlDarkDark%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ControlDarkDark = This.oColor.FromRGB(xfcGetSysColor(COLOR_3DDKSHADOW))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ControlDarkDark
	ENDFUNC


	*********************************************************************
	FUNCTION ControlDark_ACCESS
	*********************************************************************
	** Property: ControlDark (Access)
	**
	** Gets a Color structure that is the shadow color of a 3-D element. The shadow color
	** is applied to parts of a 3-D element that face away from the light source.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ControlDark%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ControlDark = This.oColor.FromRGB(xfcGetSysColor(COLOR_3DSHADOW))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ControlDark
	ENDFUNC


	*********************************************************************
	FUNCTION ControlLightLight_ACCESS
	*********************************************************************
	** Property: ControlLightLight (Access)
	**
	** Gets a Color structure that is the highlight color of a 3-D element. The highlight
	** color is applied to the parts of a 3-D element that are the lightest color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ControlLightLight%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ControlLightLight = This.oColor.FromRGB(xfcGetSysColor(COLOR_3DHIGHLIGHT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ControlLightLight
	ENDFUNC


	*********************************************************************
	FUNCTION ControlLight_ACCESS
	*********************************************************************
	** Property: ControlLight (Access)
	**
	** Gets a Color structure that is the light color of a 3-D element. The light color
	** is applied to parts of a 3-D element that face the light source.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ControlLight%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ControlLight = This.oColor.FromRGB(xfcGetSysColor(COLOR_3DLIGHT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ControlLight
	ENDFUNC


	*********************************************************************
	FUNCTION ControlText_ACCESS
	*********************************************************************
	** Property: ControlText (Access)
	**
	** Gets a Color structure that is the color of text in a 3-D element.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ControlText%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ControlText = This.oColor.FromRGB(xfcGetSysColor(COLOR_BTNTEXT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ControlText
	ENDFUNC


	*********************************************************************
	FUNCTION Control_ACCESS
	*********************************************************************
	** Property: Control (Access)
	**
	** Gets a Color structure that is the face color of a 3-D element.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.Control%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.Control = This.oColor.FromRGB(xfcGetSysColor(COLOR_3DFACE))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.Control
	ENDFUNC


	*********************************************************************
	FUNCTION Desktop_ACCESS
	*********************************************************************
	** Property: Desktop (Access)
	**
	** Gets a Color structure that is the color of the desktop.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.Desktop%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.Desktop = This.oColor.FromRGB(xfcGetSysColor(COLOR_DESKTOP))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.Desktop
	ENDFUNC


	*********************************************************************
	FUNCTION GrayText_ACCESS
	*********************************************************************
	** Property: GrayText (Access)
	**
	** Gets a Color structure that is the color of dimmed text. Items in a list that are
	** disabled are displayed in dimmed text.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.GrayText%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.GrayText = This.oColor.FromRGB(xfcGetSysColor(COLOR_GRAYTEXT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.GrayText
	ENDFUNC


	*********************************************************************
	FUNCTION HighlightText_ACCESS
	*********************************************************************
	** Property: HighlightText (Access)
	**
	** Gets a Color structure that is the color of the text of selected items. For example,
	** the Color structure may be the color used for the text of selected items in a list
	** box.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.HighlightText%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.HighlightText = This.oColor.FromRGB(xfcGetSysColor(COLOR_HIGHLIGHTTEXT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.HighlightText
	ENDFUNC


	*********************************************************************
	FUNCTION Highlight_ACCESS
	*********************************************************************
	** Property: Highlight (Access)
	**
	** Gets a Color structure that is the color of the background of selected items. This
	** includes selected menu items as well as selected text. For example, the Color structure
	** may be the color used for the background of selected items in a list box.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.Highlight%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.Highlight = This.oColor.FromRGB(xfcGetSysColor(COLOR_HIGHLIGHT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.Highlight
	ENDFUNC


	*********************************************************************
	FUNCTION HotTrack_ACCESS
	*********************************************************************
	** Property: HotTrack (Access)
	**
	** Gets a Color structure that is the color used to designate a hot-tracked item. Single-clicking
	** a hot-tracked item executes the item.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.HotTrack%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.HotTrack = This.oColor.FromRGB(xfcGetSysColor(COLOR_HOTLIGHT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.HotTrack
	ENDFUNC


	*********************************************************************
	FUNCTION InactiveBorder_ACCESS
	*********************************************************************
	** Property: InactiveBorder (Access)
	**
	** Gets a Color structure that is the color of an inactive window's border.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.InactiveBorder%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.InactiveBorder = This.oColor.FromRGB(xfcGetSysColor(COLOR_INACTIVEBORDER))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.InactiveBorder
	ENDFUNC


	*********************************************************************
	FUNCTION InactiveCaptionText_ACCESS
	*********************************************************************
	** Property: InactiveCaptionText (Access)
	**
	** Gets a Color structure that is the color of the text in an inactive window's title
	** bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.InactiveCaptionText%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.InactiveCaptionText = This.oColor.FromRGB(xfcGetSysColor(COLOR_INACTIVECAPTIONTEXT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.InactiveCaptionText
	ENDFUNC


	*********************************************************************
	FUNCTION InactiveCaption_ACCESS
	*********************************************************************
	** Property: InactiveCaption (Access)
	**
	** Gets a Color structure that is the color of the background of an inactive window's
	** title bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.InactiveCaption%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.InactiveCaption = This.oColor.FromRGB(xfcGetSysColor(COLOR_INACTIVECAPTION))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.InactiveCaption
	ENDFUNC


	*********************************************************************
	FUNCTION InfoText_ACCESS
	*********************************************************************
	** Property: InfoText (Access)
	**
	** Gets a Color structure that is the color of the text of a ToolTip.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.InfoText%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.InfoText = This.oColor.FromRGB(xfcGetSysColor(COLOR_INFOTEXT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.InfoText
	ENDFUNC


	*********************************************************************
	FUNCTION Info_ACCESS
	*********************************************************************
	** Property: Info (Access)
	**
	** Gets a Color structure that is the color of the background of a ToolTip.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.Info%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.Info = This.oColor.FromRGB(xfcGetSysColor(COLOR_INFOBK))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.Info
	ENDFUNC


	*********************************************************************
	FUNCTION MenuText_ACCESS
	*********************************************************************
	** Property: MenuText (Access)
	**
	** Gets a Color structure that is the color of a menu's text.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.MenuText%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.MenuText = This.oColor.FromRGB(xfcGetSysColor(COLOR_MENUTEXT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.MenuText
	ENDFUNC


	*********************************************************************
	FUNCTION Menu_ACCESS
	*********************************************************************
	** Property: Menu (Access)
	**
	** Gets a Color structure that is the color of a menu's background.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.Menu%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.Menu = This.oColor.FromRGB(xfcGetSysColor(COLOR_MENU))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.Menu
	ENDFUNC


	*********************************************************************
	FUNCTION ScrollBar_ACCESS
	*********************************************************************
	** Property: ScrollBar (Access)
	**
	** Gets a Color structure that is the color of the background of a scroll bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.ScrollBar%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.ScrollBar = This.oColor.FromRGB(xfcGetSysColor(COLOR_SCROLLBAR))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.ScrollBar
	ENDFUNC


	*********************************************************************
	FUNCTION WindowFrame_ACCESS
	*********************************************************************
	** Property: WindowFrame (Access)
	**
	** Gets a Color structure that is the color of a window frame.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.WindowFrame%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.WindowFrame = This.oColor.FromRGB(xfcGetSysColor(COLOR_WINDOWFRAME))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.WindowFrame
	ENDFUNC


	*********************************************************************
	FUNCTION WindowText_ACCESS
	*********************************************************************
	** Property: WindowText (Access)
	**
	** Gets a Color structure that is the color of the text in the client area of a window.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.WindowText%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.WindowText = This.oColor.FromRGB(xfcGetSysColor(COLOR_WINDOWTEXT))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.WindowText
	ENDFUNC


	*********************************************************************
	FUNCTION Window_ACCESS
	*********************************************************************
	** Property: Window (Access)
	**
	** Gets a Color structure that is the color of the background in the client area of
	** a window.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/08: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemColors.Window%28vs.80%29.aspx
	** Returns: Color
	*********************************************************************
		LOCAL loExc AS Exception
		TRY
			This.Window = This.oColor.FromRGB(xfcGetSysColor(COLOR_WINDOW))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN This.Window
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="activeborder" type="property" display="ActiveBorder"/>]+;
		[<memberdata name="activecaption" type="property" display="ActiveCaption"/>]+;
		[<memberdata name="activecaptiontext" type="property" display="ActiveCaptionText"/>]+;
		[<memberdata name="appworkspace" type="property" display="AppWorkspace"/>]+;
		[<memberdata name="control" type="property" display="Control"/>]+;
		[<memberdata name="controldark" type="property" display="ControlDark"/>]+;
		[<memberdata name="controldarkdark" type="property" display="ControlDarkDark"/>]+;
		[<memberdata name="controllight" type="property" display="ControlLight"/>]+;
		[<memberdata name="controllightlight" type="property" display="ControlLightLight"/>]+;
		[<memberdata name="controltext" type="property" display="ControlText"/>]+;
		[<memberdata name="desktop" type="property" display="Desktop"/>]+;
		[<memberdata name="graytext" type="property" display="GrayText"/>]+;
		[<memberdata name="highlight" type="property" display="Highlight"/>]+;
		[<memberdata name="highlighttext" type="property" display="HighlightText"/>]+;
		[<memberdata name="hottrack" type="property" display="HotTrack"/>]+;
		[<memberdata name="inactiveborder" type="property" display="InactiveBorder"/>]+;
		[<memberdata name="inactivecaption" type="property" display="InactiveCaption"/>]+;
		[<memberdata name="inactivecaptiontext" type="property" display="InactiveCaptionText"/>]+;
		[<memberdata name="info" type="property" display="Info"/>]+;
		[<memberdata name="infotext" type="property" display="InfoText"/>]+;
		[<memberdata name="menu" type="property" display="Menu"/>]+;
		[<memberdata name="menutext" type="property" display="MenuText"/>]+;
		[<memberdata name="scrollbar" type="property" display="ScrollBar"/>]+;
		[<memberdata name="window" type="property" display="Window"/>]+;
		[<memberdata name="windowframe" type="property" display="WindowFrame"/>]+;
		[<memberdata name="windowtext" type="property" display="WindowText"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCSYSTEMICONS
DEFINE CLASS xfcSystemIcons AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	Asterisk = NULL	&& Gets an Icon object that contains the system asterisk icon (WIN32: IDI_ASTERISK).
	BaseName = "SystemIcons"
	Exclamation = NULL	&& Gets an Icon object that contains the system exclamation icon (WIN32: IDI_EXCLAMATION).
	Hand = NULL	&& Gets an Icon object that contains the system hand icon (WIN32: IDI_HAND).
	Information = NULL	&& Gets an Icon object that contains the system information icon (WIN32: IDI_INFORMATION).
	Question = NULL	&& Gets an Icon object that contains the system question icon (WIN32: IDI_QUESTION).
	Warning = NULL	&& Gets an Icon object that contains the system warning icon (WIN32: IDI_WARNING).
	WinLogo = NULL	&& Gets an Icon object that contains the Windows logo icon (WIN32: IDI_WINLOGO).
	PROTECTED oicon
	oicon = .NULL.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcSystemIcons.SystemIcons
	**
	** Each property of the SystemIcons class is an Icon object for Windows system-wide
	** icons. This class cannot be inherited.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons%28vs.80%29.aspx
	** Parameters:
		
	*********************************************************************
		
		LOCAL loExc AS EXCEPTION
		TRY
			DODEFAULT()
			This.oIcon = CREATEOBJECT("xfcIcon")
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcSystemIcons.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	*********************************************************************
		LOCAL loExc AS EXCEPTION
		TRY
			This.oIcon = NULL
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Application_ACCESS
	*********************************************************************
	** Property: Application (Access)
	**
	** Gets an Icon object that contains the default application icon (WIN32: IDI_APPLICATION).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.Application%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_APPLICATION)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION Asterisk_ACCESS
	*********************************************************************
	** Property: Asterisk (Access)
	**
	** Gets an Icon object that contains the system asterisk icon (WIN32: IDI_ASTERISK).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.Asterisk%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_ASTERISK)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION Error_ACCESS
	*********************************************************************
	** Property: Error (Access)
	**
	** Gets an Icon object that contains the system error icon (WIN32: IDI_ERROR).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.Error%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_ERROR)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION Exclamation_ACCESS
	*********************************************************************
	** Property: Exclamation (Access)
	**
	** Gets an Icon object that contains the system exclamation icon (WIN32: IDI_EXCLAMATION).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.Exclamation%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_EXCLAMATION)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION Hand_ACCESS
	*********************************************************************
	** Property: Hand (Access)
	**
	** Gets an Icon object that contains the system hand icon (WIN32: IDI_HAND).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.Hand%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_HAND)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION Information_ACCESS
	*********************************************************************
	** Property: Information (Access)
	**
	** Gets an Icon object that contains the system information icon (WIN32: IDI_INFORMATION).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.Information%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_INFORMATION)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION Question_ACCESS
	*********************************************************************
	** Property: Question (Access)
	**
	** Gets an Icon object that contains the system question icon (WIN32: IDI_QUESTION).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.Question%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_QUESTION)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION Warning_ACCESS
	*********************************************************************
	** Property: Warning (Access)
	**
	** Gets an Icon object that contains the system warning icon (WIN32: IDI_WARNING).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.Warning%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_WARNING)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC


	*********************************************************************
	FUNCTION WinLogo_ACCESS
	*********************************************************************
	** Property: WinLogo (Access)
	**
	** Gets an Icon object that contains the Windows logo icon (WIN32: IDI_WINLOGO).
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemIcons.WinLogo%28vs.80%29.aspx
	** Returns: Icon
	*********************************************************************
		
		LOCAL loIcon, lhIcon
		LOCAL loExc AS EXCEPTION
		TRY
			m.lhIcon = xfcLoadIcon(0, IDI_WINLOGO)
			IF(m.lhIcon <> 0)
				m.loIcon = THIS.oIcon.FromHandle(m.lhIcon)
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loIcon
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="application" type="property" display="Application"/>]+;
		[<memberdata name="asterisk" type="property" display="Asterisk"/>]+;
		[<memberdata name="error" type="property" display="Error"/>]+;
		[<memberdata name="exclamation" type="property" display="Exclamation"/>]+;
		[<memberdata name="hand" type="property" display="Hand"/>]+;
		[<memberdata name="information" type="property" display="Information"/>]+;
		[<memberdata name="question" type="property" display="Question"/>]+;
		[<memberdata name="warning" type="property" display="Warning"/>]+;
		[<memberdata name="winlogo" type="property" display="WinLogo"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCSYSTEMPENS
DEFINE CLASS xfcSystemPens AS xfcdrawingbase
*************************************************************************
*************************************************************************
*************************************************************************
	ActiveCaptionText = NULL	&& Gets a Pen object that is the color of the text in the active window's title bar.
	BaseName = "SystemPens"
	Control = NULL	&& Gets a Pen object that is the face color of a 3-D element.
	ControlDark = NULL	&& Gets a Pen object that is the shadow color of a 3-D element. The shadow color is applied to parts of a 3-D element that face away from the light source.
	ControlDarkDark = NULL	&& Gets a Pen object that is the dark shadow color of a 3-D element. The dark shadow color is applied to the parts of a 3-D element that are the darkest color.
	ControlLight = NULL	&& Gets a Pen object that is the light color of a 3-D element. The light color is applied to parts of a 3-D element that face the light source.
	ControlLightLight = NULL	&& Gets a Pen object that is the highlight color of a 3-D element. The highlight color is applied to the parts of a 3-D element that are the lightest color.
	ControlText = NULL	&& Gets a Pen object that is the color of text in a 3-D element.
	GrayText = NULL	&& Gets a Pen object that is the color of dimmed text. Items in a list that are disabled are displayed in dimmed text.
	Highlight = NULL	&& Gets a Pen object that is the color of the background of selected items. This includes selected menu items as well as selected text. For example, the pen may be the color used for the background of selected items in a list box.
	HighlightText = NULL	&& Gets a Pen object that is the color of the text of selected items. This includes selected menu items as well as selected text. For example, the pen may be the color used for the text of selected items in a list box.
	InactiveCaptionText = NULL	&& Gets a Pen object that is the color of the text in an inactive window's title bar.
	InfoText = NULL	&& Gets a Pen object that is the color of the text of a ToolTip.
	MenuText = NULL	&& Gets a Pen object that is the color of a menu's text.
	WindowFrame = NULL	&& Gets a Pen object that is the color of a window frame.
	WindowText = NULL	&& Gets a Pen object that is the color of the text in the client area of a window.
	PROTECTED oSysColor
	oSysColor = .NULL.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcSystemPens.SystemPens
	**
	** Each property of the SystemPens class is a Pen object that is the color of a Windows
	** display element and that is a width of 1.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens%28vs.80%29.aspx
	** Parameters:
		
	*********************************************************************
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			This.oSysColor = CREATEOBJECT("xfcSystemColors")
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION Destroy
	*********************************************************************
	** Method: xfcSystemPens.Destroy
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	*********************************************************************
		
		LOCAL loExc AS Exception
		TRY
			This.oSysColor = NULL
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION ActiveCaptionText_ACCESS
	*********************************************************************
	** Property: ActiveCaptionText (Access)
	**
	** Gets a Pen object that is the color of the text in the active window's title bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.ActiveCaptionText%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.ActiveCaptionText, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION ControlDarkDark_ACCESS
	*********************************************************************
	** Property: ControlDarkDark (Access)
	**
	** Gets a Pen object that is the dark shadow color of a 3-D element. The dark shadow
	** color is applied to the parts of a 3-D element that are the darkest color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.ControlDarkDark%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.ControlDarkDark, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION ControlDark_ACCESS
	*********************************************************************
	** Property: ControlDark (Access)
	**
	** Gets a Pen object that is the shadow color of a 3-D element. The shadow color is
	** applied to parts of a 3-D element that face away from the light source.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.ControlDark%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.ControlDark, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION ControlLightLight_ACCESS
	*********************************************************************
	** Property: ControlLightLight (Access)
	**
	** Gets a Pen object that is the highlight color of a 3-D element. The highlight color
	** is applied to the parts of a 3-D element that are the lightest color.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.ControlLightLight%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.ControlLightLight, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION ControlLight_ACCESS
	*********************************************************************
	** Property: ControlLight (Access)
	**
	** Gets a Pen object that is the light color of a 3-D element. The light color is applied
	** to parts of a 3-D element that face the light source.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.ControlLight%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.ControlLight, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION ControlText_ACCESS
	*********************************************************************
	** Property: ControlText (Access)
	**
	** Gets a Pen object that is the color of text in a 3-D element.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.ControlText%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.ControlText, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION Control_ACCESS
	*********************************************************************
	** Property: Control (Access)
	**
	** Gets a Pen object that is the face color of a 3-D element.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.Control%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.Control, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION FromSystemColor
	*********************************************************************
	** Method: xfcSystemPens.FromSystemColor
	**
	** Creates a Pen object from the specified Color structure.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.FromSystemColor%28vs.80%29.aspx
	** Parameters:
	**  Color c
	** Returns: Pen
	*********************************************************************
	LPARAMETERS toC AS xfcColor
		
		LOCAL loPen
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", toC)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION GrayText_ACCESS
	*********************************************************************
	** Property: GrayText (Access)
	**
	** Gets a Pen object that is the color of dimmed text. Items in a list that are disabled
	** are displayed in dimmed text.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.GrayText%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.GrayText, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION HighlightText_ACCESS
	*********************************************************************
	** Property: HighlightText (Access)
	**
	** Gets a Pen object that is the color of the text of selected items. This includes
	** selected menu items as well as selected text. For example, the pen may be the color
	** used for the text of selected items in a list box.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.HighlightText%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.HighlightText, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION Highlight_ACCESS
	*********************************************************************
	** Property: Highlight (Access)
	**
	** Gets a Pen object that is the color of the background of selected items. This includes
	** selected menu items as well as selected text. For example, the pen may be the color
	** used for the background of selected items in a list box.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.Highlight%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.Highlight, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION InactiveCaptionText_ACCESS
	*********************************************************************
	** Property: InactiveCaptionText (Access)
	**
	** Gets a Pen object that is the color of the text in an inactive window's title bar.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.InactiveCaptionText%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.InactiveCaptionText, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION InfoText_ACCESS
	*********************************************************************
	** Property: InfoText (Access)
	**
	** Gets a Pen object that is the color of the text of a ToolTip.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.InfoText%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.InfoText, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION MenuText_ACCESS
	*********************************************************************
	** Property: MenuText (Access)
	**
	** Gets a Pen object that is the color of a menu's text.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.MenuText%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.MenuText, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION WindowFrame_ACCESS
	*********************************************************************
	** Property: WindowFrame (Access)
	**
	** Gets a Pen object that is the color of a window frame.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.WindowFrame%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.WindowFrame, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC


	*********************************************************************
	FUNCTION WindowText_ACCESS
	*********************************************************************
	** Property: WindowText (Access)
	**
	** Gets a Pen object that is the color of the text in the client area of a window.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/05/09: CBoyd - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.SystemPens.WindowText%28vs.80%29.aspx
	** Returns: Pen
	*********************************************************************
		
		LOCAL loBrush
		LOCAL loExc AS Exception
		TRY
			m.loPen = CREATEOBJECT("xfcPen", This.oSysColor.WindowText, 1)
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loPen
	ENDFUNC
	

	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="fromsystemcolor" type="method" display="FromSystemColor"/>]+;
		[<memberdata name="activecaptiontext" type="property" display="ActiveCaptionText"/>]+;
		[<memberdata name="control" type="property" display="Control"/>]+;
		[<memberdata name="controldark" type="property" display="ControlDark"/>]+;
		[<memberdata name="controldarkdark" type="property" display="ControlDarkDark"/>]+;
		[<memberdata name="controllight" type="property" display="ControlLight"/>]+;
		[<memberdata name="controllightlight" type="property" display="ControlLightLight"/>]+;
		[<memberdata name="controltext" type="property" display="ControlText"/>]+;
		[<memberdata name="graytext" type="property" display="GrayText"/>]+;
		[<memberdata name="highlight" type="property" display="Highlight"/>]+;
		[<memberdata name="highlighttext" type="property" display="HighlightText"/>]+;
		[<memberdata name="inactivecaptiontext" type="property" display="InactiveCaptionText"/>]+;
		[<memberdata name="infotext" type="property" display="InfoText"/>]+;
		[<memberdata name="menutext" type="property" display="MenuText"/>]+;
		[<memberdata name="windowframe" type="property" display="WindowFrame"/>]+;
		[<memberdata name="windowtext" type="property" display="WindowText"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

*************************************************************************
*************************************************************************
*************************************************************************
#IFDEF USECLASS_XFCTEXTUREBRUSH
DEFINE CLASS xfcTextureBrush AS xfcbrush
*************************************************************************
*************************************************************************
*************************************************************************
	BaseName = "TextureBrush"
	Image = 0	&& Gets the Image object associated with this TextureBrush object.
	lastresult = 0
	Transform = 0	&& Gets or sets a Matrix object that defines a local geometric transformation for the image associated with this TextureBrush object.
	WrapMode = 0	&& Gets or sets a WrapMode enumeration that indicates the wrap mode for this TextureBrush object.
 
	*********************************************************************
	FUNCTION Init
	*********************************************************************
	** Method: xfcTextureBrush.TextureBrush
	**
	** Initializes a new TextureBrush object that uses the specified image.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**	2006/05/08: BDurban - Recoded to not use precision property
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.TextureBrush%28vs.80%29.aspx
	** Parameters:
	**  Image bitmap
	**  Image image, Rectangle dstRect
	**  Image image, RectangleF dstRect
	**  Image image, WrapMode wrapMode
	**  Image image, Rectangle dstRect, ImageAttributes imageAttr
	**  Image image, RectangleF dstRect, ImageAttributes imageAttr
	**  Image image, WrapMode wrapMode, Rectangle dstRect
	**  Image image, WrapMode wrapMode, RectangleF dstRect
	*********************************************************************
	LPARAMETERS toImage AS xfcImage, ;
					tiWrapMode AS EnumWrapMode, ;
					toDstRect AS xfcRectangle
	*********** toImage AS xfcImage [, toDstRect AS xfcRectangle] [, toImageAttr AS xfcImageAttributes]
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			DODEFAULT()
			
			LOCAL lnX, lnY, lnWidth, lnHeight
			LOCAL lhTexture, lhImageAttributes ,loImageAttributes, lcVarType
			
			STORE 0.0 TO m.lnX, m.lnY, m.lnWidth, m.lnHeight
			m.lhTexture = 0
			m.lhImageAttributes = 0
			m.lcVarType = VARTYPE(m.toImage)+VARTYPE(m.tiWrapMode)+VARTYPE(m.toDstRect)
			
		
			DO CASE
			CASE LEFT(m.lcVarType,2) == "ONO"	&& Image, WrapMode, Rect
				m.toDstRect.GetExtent(@lnX, @lnY, @lnWidth, @lnHeight)
				This.SetStatus(xfcGdipCreateTexture2(m.toImage.Handle, m.tiWrapmode, m.lnX, m.lnY, m.lnWidth, m.lnHeight, @lhTexture))
		*!*		This.SetStatus(xfcGdipCreateTexture2I(m.toImage.Handle, m.tiWrapmode, m.lnX, m.lnY, m.lnWidth, m.lnHeight, @lhTexture))
			CASE LEFT(m.lcVarType,2) == "OO"	&& Image, Rect [, Attributes]
				m.loImageAttributes = m.toDstRect
				m.toDstRect = m.tiWrapMode
				m.toDstRect.GetExtent(@lnX, @lnY, @lnWidth, @lnHeight)
				IF VARTYPE(m.loImageAttributes) = "O"
					m.lhImageAttributes = m.loImageAttributes.Handle
				ENDIF
				This.SetStatus(xfcGdipCreateTextureIA(m.toImage.Handle, m.lhImageAttributes, m.lnX, m.lnY, m.lnWidth, m.lnHeight, @lhTexture))
		*!*		This.SetStatus(xfcGdipCreateTextureIAI(m.toImage.Handle, m.lhImageAttributes, m.lnX, m.lnY, m.lnWidth, m.lnHeight, @lhTexture))
			CASE LEFT(m.lcVarType,1) == "O"	&& Image [, WrapMode]
				m.tiWrapMode = EVL(m.tiWrapMode, 0)
				This.SetStatus(xfcGdipCreateTexture(m.toImage.Handle, m.tiWrapmode, @lhTexture))
			ENDCASE
			
			This.Handle = m.lhTexture
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN
	ENDFUNC


	*********************************************************************
	FUNCTION New
	*********************************************************************
	LPARAMETERS toImage AS xfcImage, ;
					tiWrapMode AS EnumWrapMode, ;
					toDstRect AS xfcRectangle
	*********** toImage AS xfcImage [, toDstRect AS xfcRectangle] [, toImageAttr AS xfcImageAttributes]
		
		RETURN CREATEOBJECT(This.Class, m.toImage, m.tiWrapMode, m.toDstRect)
	ENDFUNC


	*********************************************************************
	FUNCTION Clone
	*********************************************************************
	** Method: xfcTextureBrush.Clone
	**
	** Creates an exact copy of this TextureBrush object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/28: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.Clone%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: object
	*********************************************************************
		
		*!ToDo: Test this function
		
		RETURN DODEFAULT()
	ENDFUNC


	*********************************************************************
	FUNCTION Image_ACCESS
	*********************************************************************
	** Property: Image (Access)
	**
	** Gets the Image object associated with this TextureBrush object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.Image%28vs.80%29.aspx
	** Returns: Image
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loImage, lhImage
		m.lhImage = 0
		m.loImage = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetTextureImage(This.Handle, @lhImage))
				IF(m.lhImage <> 0)
					m.loImage = CREATEOBJECT("xfcImage")
					m.loImage.Handle = m.lhImage
				ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loImage
	ENDFUNC


	*********************************************************************
	FUNCTION MultiplyTransform
	*********************************************************************
	** Method: xfcTextureBrush.MultiplyTransform
	**
	** Multiplies the Matrix object that represents the local geometric transformation
	** of this TextureBrush object by the specified Matrix object in the specified order.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/14: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.MultiplyTransform%28vs.80%29.aspx
	** Parameters:
	**  Matrix matrix
	**  Matrix matrix, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS toMatrix AS xfcMatrix, tiOrder AS EnumMatrixOrder
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			m.tiOrder = EVL(m.tiOrder,0)
			This.SetStatus(xfcGdipMultiplyTextureTransform(m.lhBrush, m.toMatrix.Handle, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION ResetTransform
	*********************************************************************
	** Method: xfcTextureBrush.ResetTransform
	**
	** Resets the Transform property of this TextureBrush object to identity.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.ResetTransform%28vs.80%29.aspx
	** Parameters:
	**  [None]
	** Returns: void
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipResetTextureTransform(This.Handle))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION RotateTransform
	*********************************************************************
	** Method: xfcTextureBrush.RotateTransform
	**
	** Rotates the local geometric transformation of this TextureBrush object by the specified
	** amount. This method prepends the rotation to the transformation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.RotateTransform%28vs.80%29.aspx
	** Parameters:
	**  float angle
	**  float angle, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnAngle
	*********** tnAngle, tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			m.tiOrder = EVL(m.tiOrder, 0)
			This.SetStatus(xfcGdipRotateTextureTransform(This.Handle, m.tnAngle, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION ScaleTransform
	*********************************************************************
	** Method: xfcTextureBrush.ScaleTransform
	**
	** Scales the local geometric transformation of this TextureBrush object by the specified
	** amounts. This method prepends the scaling matrix to the transformation.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.ScaleTransform%28vs.80%29.aspx
	** Parameters:
	**  float sx, float sy
	**  float sx, float sy, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnSx, tnSy
	*********** tnSx, tnSy, tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			m.tiOrder = EVL(m.tiOrder, 0)
			This.SetStatus(xfcGdipScaleTextureTransform(This.Handle, m.tnSx, m.tnSy, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION Transform_ACCESS
	*********************************************************************
	** Property: Transform (Access)
	**
	** Gets or sets a Matrix object that defines a local geometric transformation for the
	** image associated with this TextureBrush object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/14: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.Transform%28vs.80%29.aspx
	** Returns: Matrix
	*********************************************************************
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		
		LOCAL loMatrix, lhMatrix
		m.lhMatrix = 0
		m.loMatrix = NULL
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetTextureTransform(This.Handle, m.lhMatrix))
				IF(m.lhMatrix <> 0)
					m.loMatrix = NEWOBJECT("xfcMatrix", XFCCLASS_DRAWING2D)
					m.loMatrix.Handle = m.lhMatrix
				ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.loMatrix
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION Transform_ASSIGN
	*********************************************************************
	** Property: Transform (Assign)
	**
	** Gets or sets a Matrix object that defines a local geometric transformation for the
	** image associated with this TextureBrush object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/04/14: BDurban - Coded
	**  2006/08/22: BDurban - Added check for parameter data type
	*********************************************************************
	LPARAMETERS toMatrix AS xfcMatrix
	#IFDEF USECLASS_XFCMATRIX
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			IF VARTYPE(m.toMatrix)="O"
				This.SetStatus(xfcGdipSetTextureTransform(This.Handle, m.toMatrix.Handle))
			ENDIF
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	#ELSE
		ERROR "Matrix class is disabled"
	#ENDIF
	ENDFUNC


	*********************************************************************
	FUNCTION TranslateTransform
	*********************************************************************
	** Method: xfcTextureBrush.TranslateTransform
	**
	** Translates the local geometric transformation of this TextureBrush object by the
	** specified dimensions in the specified order.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.TranslateTransform%28vs.80%29.aspx
	** Parameters:
	**  float dx, float dy
	**  float dx, float dy, MatrixOrder order
	** Returns: void
	*********************************************************************
	LPARAMETERS tnDx, tnDy
	*********** tnDx, tnDy, tiOrder AS EnumMatrixOrder
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			m.tiOrder = EVL(m.tiOrder,0)
			This.SetStatus(xfcGdipTranslateTextureTransform(This.Handle, m.tnDx, m.tnDy, m.tiOrder))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC


	*********************************************************************
	FUNCTION WrapMode_ACCESS
	*********************************************************************
	** Property: WrapMode (Access)
	**
	** Gets or sets a WrapMode enumeration that indicates the wrap mode for this TextureBrush
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	**
	** .NET Help ********************************************************
	** http://msdn2.microsoft.com/en-us/library/System.Drawing.TextureBrush.WrapMode%28vs.80%29.aspx
	** Returns: WrapMode
	*********************************************************************
		
		*!ToDo: Test this function
		
		LOCAL liWrapMode
		m.liWrapMode = 0
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipGetTextureWrapMode(This.Handle, @liWrapmode))
		
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		RETURN m.liWrapMode
	ENDFUNC


	*********************************************************************
	FUNCTION WrapMode_ASSIGN
	*********************************************************************
	** Property: WrapMode (Assign)
	**
	** Gets or sets a WrapMode enumeration that indicates the wrap mode for this TextureBrush
	** object.
	**
	** History:
	**  2006/03/07: Auto Generated
	**	2006/03/30: BDurban - Coded
	*********************************************************************
	LPARAMETERS tiWrapMode
		
		*!ToDo: Test this function
		
		LOCAL loExc AS Exception
		TRY
			This.SetStatus(xfcGdipSetTextureWrapMode(This.Handle, m.tiWrapmode))
		CATCH TO loExc
			THROW_EXCEPTION
		ENDTRY
		
		RETURN NULL
	ENDFUNC




	#IFDEF USE_MEMBERDATA
	PROTECTED _memberdata
	_memberdata = [<VFPData>]+;
		[<memberdata name="clone" type="method" display="Clone"/>]+;
		[<memberdata name="createobjref" type="method" display="CreateObjRef"/>]+;
		[<memberdata name="dispose" type="method" display="Dispose"/>]+;
		[<memberdata name="equals" type="method" display="Equals"/>]+;
		[<memberdata name="gethashcode" type="method" display="GetHashCode"/>]+;
		[<memberdata name="getlifetimeservice" type="method" display="GetLifetimeService"/>]+;
		[<memberdata name="gettype" type="method" display="GetType"/>]+;
		[<memberdata name="initializelifetimeservice" type="method" display="InitializeLifetimeService"/>]+;
		[<memberdata name="multiplytransform" type="method" display="MultiplyTransform"/>]+;
		[<memberdata name="resettransform" type="method" display="ResetTransform"/>]+;
		[<memberdata name="rotatetransform" type="method" display="RotateTransform"/>]+;
		[<memberdata name="scaletransform" type="method" display="ScaleTransform"/>]+;
		[<memberdata name="tostring" type="method" display="ToString"/>]+;
		[<memberdata name="translatetransform" type="method" display="TranslateTransform"/>]+;
		[<memberdata name="finalize" type="method" display="Finalize"/>]+;
		[<memberdata name="memberwiseclone" type="method" display="MemberwiseClone"/>]+;
		[<memberdata name="image" type="property" display="Image"/>]+;
		[<memberdata name="transform" type="property" display="Transform"/>]+;
		[<memberdata name="wrapmode" type="property" display="WrapMode"/>]+;
		[</VFPData>]		
	#ENDIF
ENDDEFINE
#ENDIF
*************************************************************************
*************************************************************************

#IFDEF USECLASS_XFCBITMAP
*********************************************************************
FUNCTION xfcGdipBitmapGetPixel(nBitmap, x, y, Color)
*********************************************************************
	DECLARE Long GdipBitmapGetPixel IN GDIPLUS.DLL AS xfcGdipBitmapGetPixel Long nBitmap, Long x, Long y, Long @Color
	RETURN xfcGdipBitmapGetPixel(m.nBitmap, m.x, m.y, @m.Color)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipBitmapLockBits(nBitmap, nRect, flags, PixelFormat, lockedBitmapData)
*********************************************************************
	DECLARE Long GdipBitmapLockBits IN GDIPLUS.DLL AS xfcGdipBitmapLockBits Long nBitmap, String @nRect, Long flags, Long PixelFormat, String @lockedBitmapData
	RETURN xfcGdipBitmapLockBits(m.nBitmap, @m.nRect, m.flags, m.PixelFormat, @m.lockedBitmapData)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipBitmapSetPixel(nBitmap, x, y, Color)
*********************************************************************
	DECLARE Long GdipBitmapSetPixel IN GDIPLUS.DLL AS xfcGdipBitmapSetPixel Long nBitmap, Long x, Long y, Long Color
	RETURN xfcGdipBitmapSetPixel(m.nBitmap, m.x, m.y, m.Color)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipBitmapSetResolution(nBitmap, xdpi, ydpi)
*********************************************************************
	DECLARE Long GdipBitmapSetResolution IN GDIPLUS.DLL AS xfcGdipBitmapSetResolution Long nBitmap, Single xdpi, Single ydpi
	RETURN xfcGdipBitmapSetResolution(m.nBitmap, m.xdpi, m.ydpi)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipBitmapUnlockBits(nBitmap, lockedBitmapData)
*********************************************************************
	DECLARE Long GdipBitmapUnlockBits IN GDIPLUS.DLL AS xfcGdipBitmapUnlockBits Long nBitmap, String @lockedBitmapData
	RETURN xfcGdipBitmapUnlockBits(m.nBitmap, @m.lockedBitmapData)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCloneBitmapArea(x, y, nWidth, Height, PixelFormat, srcBitmap, dstBitmap)
*********************************************************************
	DECLARE Long GdipCloneBitmapArea IN GDIPLUS.DLL AS xfcGdipCloneBitmapArea Single x, Single y, Single nWidth, Single Height, Long PixelFormat, Long srcBitmap, Long @dstBitmap
	RETURN xfcGdipCloneBitmapArea(m.x, m.y, m.nWidth, m.Height, m.PixelFormat, m.srcBitmap, @m.dstBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCloneBitmapAreaI(x, y, nWidth, Height, PixelFormat, srcBitmap, dstBitmap)
*********************************************************************
	DECLARE Long GdipCloneBitmapAreaI IN GDIPLUS.DLL AS xfcGdipCloneBitmapAreaI Long x, Long y, Long nWidth, Long Height, Long PixelFormat, Long srcBitmap, Long @dstBitmap
	RETURN xfcGdipCloneBitmapAreaI(m.x, m.y, m.nWidth, m.Height, m.PixelFormat, m.srcBitmap, @m.dstBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromDirectDrawSurface(surface, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromDirectDrawSurface IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromDirectDrawSurface Long @surface, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromDirectDrawSurface(@m.surface, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromFile(FileName, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromFile IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromFile String FileName, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromFile(m.FileName, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromFileICM(FileName, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromFileICM IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromFileICM String FileName, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromFileICM(m.FileName, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromGdiDib(gdiBitmapInfo, gdiBitmapData, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromGdiDib IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromGdiDib String @gdiBitmapInfo, Long gdiBitmapData, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromGdiDib(@m.gdiBitmapInfo, m.gdiBitmapData, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromGraphics(nWidth, Height, graphics, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromGraphics IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromGraphics Long nWidth, Long Height, Long graphics, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromGraphics(m.nWidth, m.Height, m.graphics, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromHICON(hicon, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromHICON IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromHICON Long hicon, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromHICON(m.hicon, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromResource(hInstance, lpBitmapName, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromResource IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromResource Long hInstance, String lpBitmapName, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromResource(m.hInstance, m.lpBitmapName, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromScan0(nWidth, Height, stride, PixelFormat, scan0, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromScan0 IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromScan0 Long nWidth, Long Height, Long stride, Long PixelFormat, Long scan0, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromScan0(m.nWidth, m.Height, m.stride, m.PixelFormat, m.scan0, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromStream(stream, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromStream IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromStream Integer stream, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromStream(m.stream, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromStreamICM(stream, nBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromStreamICM IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromStreamICM Integer stream, Long @nBitmap
	RETURN xfcGdipCreateBitmapFromStreamICM(m.stream, @m.nBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateHICONFromBitmap(nBitmap, hbmReturn)
*********************************************************************
	DECLARE Long GdipCreateHICONFromBitmap IN GDIPLUS.DLL AS xfcGdipCreateHICONFromBitmap Long nBitmap, Long @hbmReturn
	RETURN xfcGdipCreateHICONFromBitmap(m.nBitmap, @m.hbmReturn)
ENDFUNC

*********************************************************************
FUNCTION xfcBitBlt(hdc, nXDest, nYDest, nWidth, nHeight, hdcSrc, nXSrc, nYSrc, nRop)
*********************************************************************
	DECLARE Integer BitBlt IN WIN32API AS xfcBitBlt Integer hdc, Integer nXDest, Integer nYDest, Integer nWidth, Integer nHeight, Long hdcSrc, Integer nXSrc, Integer nYSrc, Integer nRop
	RETURN xfcBitBlt(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.hdcSrc, m.nXSrc, m.nYSrc, m.nRop)
ENDFUNC

*********************************************************************
FUNCTION xfcCreateCompatibleBitmap(hDC, width, Height)
*********************************************************************
	DECLARE Integer CreateCompatibleBitmap IN WIN32API AS xfcCreateCompatibleBitmap Integer hDC, Integer width, Integer Height
	RETURN xfcCreateCompatibleBitmap(m.hDC, m.width, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGetWindowRect(hwnd, lpRect)
*********************************************************************
	DECLARE Long GetWindowRect IN WIN32API AS xfcGetWindowRect Long hwnd, String @lpRect
	RETURN xfcGetWindowRect(m.hwnd, @m.lpRect)
ENDFUNC

*********************************************************************
FUNCTION xfcSelectObject(hdc, hgdiobj)
*********************************************************************
	DECLARE Integer SelectObject IN WIN32API AS xfcSelectObject Integer hdc, Integer hgdiobj
	RETURN xfcSelectObject(m.hdc, m.hgdiobj)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCBRUSH
*********************************************************************
FUNCTION xfcGdipCloneBrush(brush, cloneBrush)
*********************************************************************
	DECLARE Long GdipCloneBrush IN GDIPLUS.DLL AS xfcGdipCloneBrush Long brush, Long @cloneBrush
	RETURN xfcGdipCloneBrush(m.brush, @m.cloneBrush)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDeleteBrush(brush)
*********************************************************************
	DECLARE Long GdipDeleteBrush IN GDIPLUS.DLL AS xfcGdipDeleteBrush Long brush
	RETURN xfcGdipDeleteBrush(m.brush)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCFONT
*********************************************************************
FUNCTION xfcGdipCloneFont(curFont, cloneFont)
*********************************************************************
	DECLARE Long GdipCloneFont IN GDIPLUS.DLL AS xfcGdipCloneFont Long curFont, Long @cloneFont
	RETURN xfcGdipCloneFont(m.curFont, @m.cloneFont)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateFont(fontFamily, emSize, style, unit, createdfont)
*********************************************************************
	DECLARE Long GdipCreateFont IN GDIPLUS.DLL AS xfcGdipCreateFont Long fontFamily, Single emSize, Long style, Long unit, Long @createdfont
	RETURN xfcGdipCreateFont(m.fontFamily, m.emSize, m.style, m.unit, @m.createdfont)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateFontFromDC(hdc, createdfont)
*********************************************************************
	DECLARE Long GdipCreateFontFromDC IN GDIPLUS.DLL AS xfcGdipCreateFontFromDC Long hdc, Long @createdfont
	RETURN xfcGdipCreateFontFromDC(m.hdc, @m.createdfont)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateFontFromLogfontA(hdc, lfont, createdfont)
*********************************************************************
	DECLARE Long GdipCreateFontFromLogfontA IN GDIPLUS.DLL AS xfcGdipCreateFontFromLogfontA Long hdc, Logfonta @lfont, Long @createdfont
	RETURN xfcGdipCreateFontFromLogfontA(m.hdc, @m.lfont, @m.createdfont)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateFontFromLogfontW(hdc, lfont, createdfont)
*********************************************************************
	DECLARE Long GdipCreateFontFromLogfontW IN GDIPLUS.DLL AS xfcGdipCreateFontFromLogfontW Long hdc, Logfontw @lfont, Long @createdfont
	RETURN xfcGdipCreateFontFromLogfontW(m.hdc, @m.lfont, @m.createdfont)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDeleteFont(curFont)
*********************************************************************
	DECLARE Long GdipDeleteFont IN GDIPLUS.DLL AS xfcGdipDeleteFont Long curFont
	RETURN xfcGdipDeleteFont(m.curFont)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetFamily(curFont, family)
*********************************************************************
	DECLARE Long GdipGetFamily IN GDIPLUS.DLL AS xfcGdipGetFamily Long curFont, Long @family
	RETURN xfcGdipGetFamily(m.curFont, @m.family)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetFontHeight(curFont, graphics, Height)
*********************************************************************
	DECLARE Long GdipGetFontHeight IN GDIPLUS.DLL AS xfcGdipGetFontHeight Long curFont, Long graphics, Single @Height
	RETURN xfcGdipGetFontHeight(m.curFont, m.graphics, @m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetFontHeightGivenDPI(curFont, dpi, Height)
*********************************************************************
	DECLARE Long GdipGetFontHeightGivenDPI IN GDIPLUS.DLL AS xfcGdipGetFontHeightGivenDPI Long curFont, Single dpi, Single @Height
	RETURN xfcGdipGetFontHeightGivenDPI(m.curFont, m.dpi, @m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetFontSize(curFont, Size)
*********************************************************************
	DECLARE Long GdipGetFontSize IN GDIPLUS.DLL AS xfcGdipGetFontSize Long curFont, Single @Size
	RETURN xfcGdipGetFontSize(m.curFont, @m.Size)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetFontStyle(curFont, style)
*********************************************************************
	DECLARE Long GdipGetFontStyle IN GDIPLUS.DLL AS xfcGdipGetFontStyle Long curFont, Long @style
	RETURN xfcGdipGetFontStyle(m.curFont, @m.style)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetFontUnit(curFont, unit)
*********************************************************************
	DECLARE Long GdipGetFontUnit IN GDIPLUS.DLL AS xfcGdipGetFontUnit Long curFont, Long @unit
	RETURN xfcGdipGetFontUnit(m.curFont, @m.unit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetLogFontA(curFont, graphics, lfont)
*********************************************************************
	DECLARE Long GdipGetLogFontA IN GDIPLUS.DLL AS xfcGdipGetLogFontA Long curFont, Long graphics, String @lfont
	RETURN xfcGdipGetLogFontA(m.curFont, m.graphics, @m.lfont)
ENDFUNC

*********************************************************************
FUNCTION xfcCreateFontIndirect(lplf)
*********************************************************************
	DECLARE Long CreateFontIndirect IN WIN32API AS xfcCreateFontIndirect String @lplf
	RETURN xfcCreateFontIndirect(@m.lplf)
ENDFUNC




#ENDIF

#IFDEF USECLASS_XFCFONTFAMILY
*********************************************************************
FUNCTION xfcGdipCreateFontFamilyFromName(FontName, fontCollection, fontFamily)
*********************************************************************
	DECLARE Long GdipCreateFontFamilyFromName IN GDIPLUS.DLL AS xfcGdipCreateFontFamilyFromName String FontName, Long fontCollection, Long @fontFamily
	RETURN xfcGdipCreateFontFamilyFromName(m.FontName, m.fontCollection, @m.fontFamily)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDeleteFontFamily(fontFamily)
*********************************************************************
	DECLARE Long GdipDeleteFontFamily IN GDIPLUS.DLL AS xfcGdipDeleteFontFamily Long fontFamily
	RETURN xfcGdipDeleteFontFamily(m.fontFamily)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetCellAscent(family, style, CellAscent)
*********************************************************************
	DECLARE Long GdipGetCellAscent IN GDIPLUS.DLL AS xfcGdipGetCellAscent Long family, Long style, Integer @CellAscent
	RETURN xfcGdipGetCellAscent(m.family, m.style, @m.CellAscent)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetCellDescent(family, style, CellDescent)
*********************************************************************
	DECLARE Long GdipGetCellDescent IN GDIPLUS.DLL AS xfcGdipGetCellDescent Long family, Long style, Integer @CellDescent
	RETURN xfcGdipGetCellDescent(m.family, m.style, @m.CellDescent)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetEmHeight(family, style, EmHeight)
*********************************************************************
	DECLARE Long GdipGetEmHeight IN GDIPLUS.DLL AS xfcGdipGetEmHeight Long family, Long style, Integer @EmHeight
	RETURN xfcGdipGetEmHeight(m.family, m.style, @m.EmHeight)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetFamilyName(family, FileName, language)
*********************************************************************
	DECLARE Long GdipGetFamilyName IN GDIPLUS.DLL AS xfcGdipGetFamilyName Long family, String @FileName, Integer language
	RETURN xfcGdipGetFamilyName(m.family, @m.FileName, m.language)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetGenericFontFamilyMonospace(nativeFamily)
*********************************************************************
	DECLARE Long GdipGetGenericFontFamilyMonospace IN GDIPLUS.DLL AS xfcGdipGetGenericFontFamilyMonospace Long @nativeFamily
	RETURN xfcGdipGetGenericFontFamilyMonospace(@m.nativeFamily)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetGenericFontFamilySansSerif(nativeFamily)
*********************************************************************
	DECLARE Long GdipGetGenericFontFamilySansSerif IN GDIPLUS.DLL AS xfcGdipGetGenericFontFamilySansSerif Long @nativeFamily
	RETURN xfcGdipGetGenericFontFamilySansSerif(@m.nativeFamily)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetGenericFontFamilySerif(nativeFamily)
*********************************************************************
	DECLARE Long GdipGetGenericFontFamilySerif IN GDIPLUS.DLL AS xfcGdipGetGenericFontFamilySerif Long @nativeFamily
	RETURN xfcGdipGetGenericFontFamilySerif(@m.nativeFamily)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetLineSpacing(family, style, LineSpacing)
*********************************************************************
	DECLARE Long GdipGetLineSpacing IN GDIPLUS.DLL AS xfcGdipGetLineSpacing Long family, Long style, Integer @LineSpacing
	RETURN xfcGdipGetLineSpacing(m.family, m.style, @m.LineSpacing)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsStyleAvailable(family, style, IsStyleAvailable)
*********************************************************************
	DECLARE Long GdipIsStyleAvailable IN GDIPLUS.DLL AS xfcGdipIsStyleAvailable Long family, Long style, Long @IsStyleAvailable
	RETURN xfcGdipIsStyleAvailable(m.family, m.style, @m.IsStyleAvailable)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCGRAPHICS
*********************************************************************
FUNCTION xfcGdipBeginContainer(graphics, dstrect, srcRect, unit, State)
*********************************************************************
	DECLARE Long GdipBeginContainer IN GDIPLUS.DLL AS xfcGdipBeginContainer Long graphics, String @dstrect, String @srcRect, Long unit, Long @State
	RETURN xfcGdipBeginContainer(m.graphics, @m.dstrect, @m.srcRect, m.unit, @m.State)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipBeginContainer2(graphics, State)
*********************************************************************
	DECLARE Long GdipBeginContainer2 IN GDIPLUS.DLL AS xfcGdipBeginContainer2 Long graphics, Long @State
	RETURN xfcGdipBeginContainer2(m.graphics, @m.State)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipBeginContainerI(graphics, dstrect, srcRect, unit, State)
*********************************************************************
	DECLARE Long GdipBeginContainerI IN GDIPLUS.DLL AS xfcGdipBeginContainerI Long graphics, String @dstrect, String @srcRect, Long unit, Long @State
	RETURN xfcGdipBeginContainerI(m.graphics, @m.dstrect, @m.srcRect, m.unit, @m.State)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipComment(graphics, sizeData, nData)
*********************************************************************
	DECLARE Long GdipComment IN GDIPLUS.DLL AS xfcGdipComment Long graphics, Long sizeData, String @nData
	RETURN xfcGdipComment(m.graphics, m.sizeData, @m.nData)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateFromHDC(hdc, graphics)
*********************************************************************
	DECLARE Long GdipCreateFromHDC IN GDIPLUS.DLL AS xfcGdipCreateFromHDC Long hdc, Long @graphics
	RETURN xfcGdipCreateFromHDC(m.hdc, @m.graphics)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateFromHDC2(hdc, hDevice, graphics)
*********************************************************************
	DECLARE Long GdipCreateFromHDC2 IN GDIPLUS.DLL AS xfcGdipCreateFromHDC2 Long hdc, Long hDevice, Long @graphics
	RETURN xfcGdipCreateFromHDC2(m.hdc, m.hDevice, @m.graphics)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateFromHWND(hwnd, graphics)
*********************************************************************
	DECLARE Long GdipCreateFromHWND IN GDIPLUS.DLL AS xfcGdipCreateFromHWND Long hwnd, Long @graphics
	RETURN xfcGdipCreateFromHWND(m.hwnd, @m.graphics)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateHalftonePalette()
*********************************************************************
	DECLARE Long GdipCreateHalftonePalette IN GDIPLUS.DLL AS xfcGdipCreateHalftonePalette 
	RETURN xfcGdipCreateHalftonePalette()
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDeleteGraphics(graphics)
*********************************************************************
	DECLARE Long GdipDeleteGraphics IN GDIPLUS.DLL AS xfcGdipDeleteGraphics Long graphics
	RETURN xfcGdipDeleteGraphics(m.graphics)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawArc(graphics, pen, x, y, nWidth, Height, startAngle, sweepAngle)
*********************************************************************
	DECLARE Long GdipDrawArc IN GDIPLUS.DLL AS xfcGdipDrawArc Long graphics, Long pen, Single x, Single y, Single nWidth, Single Height, Single startAngle, Single sweepAngle
	RETURN xfcGdipDrawArc(m.graphics, m.pen, m.x, m.y, m.nWidth, m.Height, m.startAngle, m.sweepAngle)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawArcI(graphics, pen, x, y, nWidth, Height, startAngle, sweepAngle)
*********************************************************************
	DECLARE Long GdipDrawArcI IN GDIPLUS.DLL AS xfcGdipDrawArcI Long graphics, Long pen, Long x, Long y, Long nWidth, Long Height, Single startAngle, Single sweepAngle
	RETURN xfcGdipDrawArcI(m.graphics, m.pen, m.x, m.y, m.nWidth, m.Height, m.startAngle, m.sweepAngle)
ENDFUNC

#IFNDEF GDIPX_SIMPLEDRAWING 
*********************************************************************
FUNCTION xfcGdipDrawBezier(graphics, pen, x1, y1, x2, y2, x3, y3, x4, y4)
*********************************************************************
	DECLARE Long GdipDrawBezier IN GDIPLUS.DLL AS xfcGdipDrawBezier Long graphics, Long pen, Single x1, Single y1, Single x2, Single y2, Single x3, Single y3, Single x4, Single y4
	RETURN xfcGdipDrawBezier(m.graphics, m.pen, m.x1, m.y1, m.x2, m.y2, m.x3, m.y3, m.x4, m.y4)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawBezierI(graphics, pen, x1, y1, x2, y2, x3, y3, x4, y4)
*********************************************************************
	DECLARE Long GdipDrawBezierI IN GDIPLUS.DLL AS xfcGdipDrawBezierI Long graphics, Long pen, Long x1, Long y1, Long x2, Long y2, Long x3, Long y3, Long x4, Long y4
	RETURN xfcGdipDrawBezierI(m.graphics, m.pen, m.x1, m.y1, m.x2, m.y2, m.x3, m.y3, m.x4, m.y4)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawBeziers(graphics, pen, pPointF, Count)
*********************************************************************
	DECLARE Long GdipDrawBeziers IN GDIPLUS.DLL AS xfcGdipDrawBeziers Long graphics, Long pen, String @pPointF, Long Count
	RETURN xfcGdipDrawBeziers(m.graphics, m.pen, @m.pPointF, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawBeziersI(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawBeziersI IN GDIPLUS.DLL AS xfcGdipDrawBeziersI Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawBeziersI(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC
#ENDIF

*********************************************************************
FUNCTION xfcGdipDrawClosedCurve(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawClosedCurve IN GDIPLUS.DLL AS xfcGdipDrawClosedCurve Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawClosedCurve(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawClosedCurve2(graphics, pen, pPoint, Count, tension)
*********************************************************************
	DECLARE Long GdipDrawClosedCurve2 IN GDIPLUS.DLL AS xfcGdipDrawClosedCurve2 Long graphics, Long pen, String @pPoint, Long Count, Single tension
	RETURN xfcGdipDrawClosedCurve2(m.graphics, m.pen, @m.pPoint, m.Count, m.tension)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawClosedCurve2I(graphics, pen, pPoint, Count, tension)
*********************************************************************
	DECLARE Long GdipDrawClosedCurve2I IN GDIPLUS.DLL AS xfcGdipDrawClosedCurve2I Long graphics, Long pen, String @pPoint, Long Count, Single tension
	RETURN xfcGdipDrawClosedCurve2I(m.graphics, m.pen, @m.pPoint, m.Count, m.tension)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawClosedCurveI(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawClosedCurveI IN GDIPLUS.DLL AS xfcGdipDrawClosedCurveI Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawClosedCurveI(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawCurve(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawCurve IN GDIPLUS.DLL AS xfcGdipDrawCurve Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawCurve(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawCurve2(graphics, pen, pPoint, Count, tension)
*********************************************************************
	DECLARE Long GdipDrawCurve2 IN GDIPLUS.DLL AS xfcGdipDrawCurve2 Long graphics, Long pen, String @pPoint, Long Count, Single tension
	RETURN xfcGdipDrawCurve2(m.graphics, m.pen, @m.pPoint, m.Count, m.tension)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawCurve2I(graphics, pen, pPoint, Count, tension)
*********************************************************************
	DECLARE Long GdipDrawCurve2I IN GDIPLUS.DLL AS xfcGdipDrawCurve2I Long graphics, Long pen, String @pPoint, Long Count, Single tension
	RETURN xfcGdipDrawCurve2I(m.graphics, m.pen, @m.pPoint, m.Count, m.tension)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawCurve3(graphics, pen, pPoint, Count, offset, numberOfSegments, tension)
*********************************************************************
	DECLARE Long GdipDrawCurve3 IN GDIPLUS.DLL AS xfcGdipDrawCurve3 Long graphics, Long pen, String @pPoint, Long Count, Long offset, Long numberOfSegments, Single tension
	RETURN xfcGdipDrawCurve3(m.graphics, m.pen, @m.pPoint, m.Count, m.offset, m.numberOfSegments, m.tension)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawCurve3I(graphics, pen, pPoint, Count, offset, numberOfSegments, tension)
*********************************************************************
	DECLARE Long GdipDrawCurve3I IN GDIPLUS.DLL AS xfcGdipDrawCurve3I Long graphics, Long pen, String @pPoint, Long Count, Long offset, Long numberOfSegments, Single tension
	RETURN xfcGdipDrawCurve3I(m.graphics, m.pen, @m.pPoint, m.Count, m.offset, m.numberOfSegments, m.tension)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawCurveI(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawCurveI IN GDIPLUS.DLL AS xfcGdipDrawCurveI Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawCurveI(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawEllipse(graphics, pen, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipDrawEllipse IN GDIPLUS.DLL AS xfcGdipDrawEllipse Long graphics, Long pen, Single x, Single y, Single nWidth, Single Height
	RETURN xfcGdipDrawEllipse(m.graphics, m.pen, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawEllipseI(graphics, pen, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipDrawEllipseI IN GDIPLUS.DLL AS xfcGdipDrawEllipseI Long graphics, Long pen, Long x, Long y, Long nWidth, Long Height
	RETURN xfcGdipDrawEllipseI(m.graphics, m.pen, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImage(graphics, nImage, x, y)
*********************************************************************
	DECLARE Long GdipDrawImage IN GDIPLUS.DLL AS xfcGdipDrawImage Long graphics, Long nImage, Single x, Single y
	RETURN xfcGdipDrawImage(m.graphics, m.nImage, m.x, m.y)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImageFX(graphics, image, sourceRectF, xFormMatrix, effect, imageAttributes, srcUnit)
*********************************************************************
	DECLARE Long GdipDrawImageFX IN GDIPLUS.DLL AS xfcGdipDrawImageFX Long graphics, Long image, String sourceRectF, Long xFormMatrix, Long effect, Long imageAttributes, Long srcUnit
	RETURN xfcGdipDrawImageFX(m.graphics, m.image, m.sourceRectF, m.xFormMatrix, m.effect, m.imageAttributes, m.srcUnit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImageI(graphics, nImage, x, y)
*********************************************************************
	DECLARE Long GdipDrawImageI IN GDIPLUS.DLL AS xfcGdipDrawImageI Long graphics, Long nImage, Long x, Long y
	RETURN xfcGdipDrawImageI(m.graphics, m.nImage, m.x, m.y)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImagePointRect(graphics, nImage, x, y, srcx, srcy, srcwidth, srcheight, srcUnit)
*********************************************************************
	DECLARE Long GdipDrawImagePointRect IN GDIPLUS.DLL AS xfcGdipDrawImagePointRect Long graphics, Long nImage, Single x, Single y, Single srcx, Single srcy, Single srcwidth, Single srcheight, Long srcUnit
	RETURN xfcGdipDrawImagePointRect(m.graphics, m.nImage, m.x, m.y, m.srcx, m.srcy, m.srcwidth, m.srcheight, m.srcUnit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImagePointRectI(graphics, nImage, x, y, srcx, srcy, srcwidth, srcheight, srcUnit)
*********************************************************************
	DECLARE Long GdipDrawImagePointRectI IN GDIPLUS.DLL AS xfcGdipDrawImagePointRectI Long graphics, Long nImage, Long x, Long y, Long srcx, Long srcy, Long srcwidth, Long srcheight, Long srcUnit
	RETURN xfcGdipDrawImagePointRectI(m.graphics, m.nImage, m.x, m.y, m.srcx, m.srcy, m.srcwidth, m.srcheight, m.srcUnit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImagePoints(graphics, nImage, dstpoints, Count)
*********************************************************************
	DECLARE Long GdipDrawImagePoints IN GDIPLUS.DLL AS xfcGdipDrawImagePoints Long graphics, Long nImage, String @dstpoints, Long Count
	RETURN xfcGdipDrawImagePoints(m.graphics, m.nImage, @m.dstpoints, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImagePointsI(graphics, nImage, dstpoints, Count)
*********************************************************************
	DECLARE Long GdipDrawImagePointsI IN GDIPLUS.DLL AS xfcGdipDrawImagePointsI Long graphics, Long nImage, String @dstpoints, Long Count
	RETURN xfcGdipDrawImagePointsI(m.graphics, m.nImage, @m.dstpoints, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImagePointsRect(graphics, nImage, pPoint, Count, srcx, srcy, srcwidth, srcheight, srcUnit, imageAttributes, pCALLBACK, callbackData)
*********************************************************************
	DECLARE Long GdipDrawImagePointsRect IN GDIPLUS.DLL AS xfcGdipDrawImagePointsRect Long graphics, Long nImage, String @pPoint, Long Count, Single srcx, Single srcy, Single srcwidth, Single srcheight, Long srcUnit, Long imageAttributes, Long pCALLBACK, Long callbackData
	RETURN xfcGdipDrawImagePointsRect(m.graphics, m.nImage, @m.pPoint, m.Count, m.srcx, m.srcy, m.srcwidth, m.srcheight, m.srcUnit, m.imageAttributes, m.pCALLBACK, m.callbackData)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImagePointsRectI(graphics, nImage, pPoint, Count, srcx, srcy, srcwidth, srcheight, srcUnit, imageAttributes, pCALLBACK, callbackData)
*********************************************************************
	DECLARE Long GdipDrawImagePointsRectI IN GDIPLUS.DLL AS xfcGdipDrawImagePointsRectI Long graphics, Long nImage, String @pPoint, Long Count, Long srcx, Long srcy, Long srcwidth, Long srcheight, Long srcUnit, Long imageAttributes, Long pCALLBACK, Long callbackData
	RETURN xfcGdipDrawImagePointsRectI(m.graphics, m.nImage, @m.pPoint, m.Count, m.srcx, m.srcy, m.srcwidth, m.srcheight, m.srcUnit, m.imageAttributes, m.pCALLBACK, m.callbackData)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImageRect(graphics, nImage, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipDrawImageRect IN GDIPLUS.DLL AS xfcGdipDrawImageRect Long graphics, Long nImage, Single x, Single y, Single nWidth, Single Height
	RETURN xfcGdipDrawImageRect(m.graphics, m.nImage, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImageRectI(graphics, nImage, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipDrawImageRectI IN GDIPLUS.DLL AS xfcGdipDrawImageRectI Long graphics, Long nImage, Long x, Long y, Long nWidth, Long Height
	RETURN xfcGdipDrawImageRectI(m.graphics, m.nImage, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImageRectRect(graphics, nImage, dstx, dsty, dstwidth, dstheight, srcx, srcy, srcwidth, srcheight, srcUnit, imageAttributes, pCALLBACK, callbackData)
*********************************************************************
	DECLARE Long GdipDrawImageRectRect IN GDIPLUS.DLL AS xfcGdipDrawImageRectRect Long graphics, Long nImage, Single dstx, Single dsty, Single dstwidth, Single dstheight, Single srcx, Single srcy, Single srcwidth, Single srcheight, Long srcUnit, Long imageAttributes, Long pCALLBACK, Long callbackData
	RETURN xfcGdipDrawImageRectRect(m.graphics, m.nImage, m.dstx, m.dsty, m.dstwidth, m.dstheight, m.srcx, m.srcy, m.srcwidth, m.srcheight, m.srcUnit, m.imageAttributes, m.pCALLBACK, m.callbackData)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawImageRectRectI(graphics, nImage, dstx, dsty, dstwidth, dstheight, srcx, srcy, srcwidth, srcheight, srcUnit, imageAttributes, pCALLBACK, callbackData)
*********************************************************************
	DECLARE Long GdipDrawImageRectRectI IN GDIPLUS.DLL AS xfcGdipDrawImageRectRectI Long graphics, Long nImage, Long dstx, Long dsty, Long dstwidth, Long dstheight, Long srcx, Long srcy, Long srcwidth, Long srcheight, Long srcUnit, Long imageAttributes, Long pCALLBACK, Long callbackData
	RETURN xfcGdipDrawImageRectRectI(m.graphics, m.nImage, m.dstx, m.dsty, m.dstwidth, m.dstheight, m.srcx, m.srcy, m.srcwidth, m.srcheight, m.srcUnit, m.imageAttributes, m.pCALLBACK, m.callbackData)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawLine(graphics, pen, x1, y1, x2, y2)
*********************************************************************
	DECLARE Long GdipDrawLine IN GDIPLUS.DLL AS xfcGdipDrawLine Long graphics, Long pen, Single x1, Single y1, Single x2, Single y2
	RETURN xfcGdipDrawLine(m.graphics, m.pen, m.x1, m.y1, m.x2, m.y2)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawLineI(graphics, pen, x1, y1, x2, y2)
*********************************************************************
	DECLARE Long GdipDrawLineI IN GDIPLUS.DLL AS xfcGdipDrawLineI Long graphics, Long pen, Long x1, Long y1, Long x2, Long y2
	RETURN xfcGdipDrawLineI(m.graphics, m.pen, m.x1, m.y1, m.x2, m.y2)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawLines(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawLines IN GDIPLUS.DLL AS xfcGdipDrawLines Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawLines(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawLinesI(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawLinesI IN GDIPLUS.DLL AS xfcGdipDrawLinesI Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawLinesI(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawPath(graphics, pen, path)
*********************************************************************
	DECLARE Long GdipDrawPath IN GDIPLUS.DLL AS xfcGdipDrawPath Long graphics, Long pen, Long path
	RETURN xfcGdipDrawPath(m.graphics, m.pen, m.path)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawPie(graphics, pen, x, y, nWidth, Height, startAngle, sweepAngle)
*********************************************************************
	DECLARE Long GdipDrawPie IN GDIPLUS.DLL AS xfcGdipDrawPie Long graphics, Long pen, Single x, Single y, Single nWidth, Single Height, Single startAngle, Single sweepAngle
	RETURN xfcGdipDrawPie(m.graphics, m.pen, m.x, m.y, m.nWidth, m.Height, m.startAngle, m.sweepAngle)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawPieI(graphics, pen, x, y, nWidth, Height, startAngle, sweepAngle)
*********************************************************************
	DECLARE Long GdipDrawPieI IN GDIPLUS.DLL AS xfcGdipDrawPieI Long graphics, Long pen, Long x, Long y, Long nWidth, Long Height, Single startAngle, Single sweepAngle
	RETURN xfcGdipDrawPieI(m.graphics, m.pen, m.x, m.y, m.nWidth, m.Height, m.startAngle, m.sweepAngle)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawPolygon(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawPolygon IN GDIPLUS.DLL AS xfcGdipDrawPolygon Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawPolygon(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawPolygonI(graphics, pen, pPoint, Count)
*********************************************************************
	DECLARE Long GdipDrawPolygonI IN GDIPLUS.DLL AS xfcGdipDrawPolygonI Long graphics, Long pen, String @pPoint, Long Count
	RETURN xfcGdipDrawPolygonI(m.graphics, m.pen, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawRectangle(graphics, pen, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipDrawRectangle IN GDIPLUS.DLL AS xfcGdipDrawRectangle Long graphics, Long pen, Single x, Single y, Single nWidth, Single Height
	RETURN xfcGdipDrawRectangle(m.graphics, m.pen, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawRectangleI(graphics, pen, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipDrawRectangleI IN GDIPLUS.DLL AS xfcGdipDrawRectangleI Long graphics, Long pen, Long x, Long y, Long nWidth, Long Height
	RETURN xfcGdipDrawRectangleI(m.graphics, m.pen, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawRectangles(graphics, pen, rects, Count)
*********************************************************************
	DECLARE Long GdipDrawRectangles IN GDIPLUS.DLL AS xfcGdipDrawRectangles Long graphics, Long pen, String @rects, Long Count
	RETURN xfcGdipDrawRectangles(m.graphics, m.pen, @m.rects, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawRectanglesI(graphics, pen, rects, Count)
*********************************************************************
	DECLARE Long GdipDrawRectanglesI IN GDIPLUS.DLL AS xfcGdipDrawRectanglesI Long graphics, Long pen, String @rects, Long Count
	RETURN xfcGdipDrawRectanglesI(m.graphics, m.pen, @m.rects, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDrawString(graphics, str, length, thefont, layoutRect, StringFormat, brush)
*********************************************************************
	DECLARE Long GdipDrawString IN GDIPLUS.DLL AS xfcGdipDrawString Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, Long brush
	RETURN xfcGdipDrawString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, m.brush)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEndContainer(graphics, State)
*********************************************************************
	DECLARE Long GdipEndContainer IN GDIPLUS.DLL AS xfcGdipEndContainer Long graphics, Long State
	RETURN xfcGdipEndContainer(m.graphics, m.State)
ENDFUNC

#IFDEF USECLASS_XFCMETAFILE
*********************************************************************
FUNCTION xfcGdipEnumerateMetafileDestPoint(graphics, metafile, destPoint, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileDestPoint IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileDestPoint Long graphics, Long metafile, String @destPoint, Long @lpEnumerateMetafileProc, Long callbackData, Long @imageAttributes
	RETURN xfcGdipEnumerateMetafileDestPoint(m.graphics, m.metafile, @m.destPoint, @m.lpEnumerateMetafileProc, m.callbackData, @m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileDestPointI(graphics, metafile, destPoint, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileDestPointI IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileDestPointI Long @graphics, Long metafile, String @destPoint, Long lpEnumerateMetafileProc, Long callbackData, Long imageAttributes
	RETURN xfcGdipEnumerateMetafileDestPointI(@m.graphics, m.metafile, @m.destPoint, m.lpEnumerateMetafileProc, m.callbackData, m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileDestPoints(graphics, metafile, destPoint, Count, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileDestPoints IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileDestPoints Long graphics, Long metafile, String @destPoint, Long Count, Long @lpEnumerateMetafileProc, Long callbackData, Long @imageAttributes
	RETURN xfcGdipEnumerateMetafileDestPoints(m.graphics, m.metafile, @m.destPoint, m.Count, @m.lpEnumerateMetafileProc, m.callbackData, @m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileDestPointsI(graphics, metafile, destPoint, Count, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileDestPointsI IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileDestPointsI Long graphics, Long metafile, String @destPoint, Long Count, Long @lpEnumerateMetafileProc, Long callbackData, Long @imageAttributes
	RETURN xfcGdipEnumerateMetafileDestPointsI(m.graphics, m.metafile, @m.destPoint, m.Count, @m.lpEnumerateMetafileProc, m.callbackData, @m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileDestRect(graphics, metafile, destRect, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileDestRect IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileDestRect Long graphics, Long metafile, String @destRect, Long @lpEnumerateMetafileProc, Long callbackData, Long @imageAttributes
	RETURN xfcGdipEnumerateMetafileDestRect(m.graphics, m.metafile, @m.destRect, @m.lpEnumerateMetafileProc, m.callbackData, @m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileDestRectI(graphics, metafile, destRect, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileDestRectI IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileDestRectI Long graphics, Long metafile, String @destRect, Long @lpEnumerateMetafileProc, Long callbackData, Long @imageAttributes
	RETURN xfcGdipEnumerateMetafileDestRectI(m.graphics, m.metafile, @m.destRect, @m.lpEnumerateMetafileProc, m.callbackData, @m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileSrcRectDestPoint(graphics, metafile, destPoint, srcRect, srcUnit, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileSrcRectDestPoint IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileSrcRectDestPoint Long graphics, Long metafile, String @destPoint, String @srcRect, Long srcUnit, Long lpEnumerateMetafileProc, Long callbackData, Long imageAttributes
	RETURN xfcGdipEnumerateMetafileSrcRectDestPoint(m.graphics, m.metafile, @m.destPoint, @m.srcRect, m.srcUnit, m.lpEnumerateMetafileProc, m.callbackData, m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileSrcRectDestPointI(graphics, metafile, destPoint, srcRect, srcUnit, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileSrcRectDestPointI IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileSrcRectDestPointI Long graphics, Long metafile, String @destPoint, String @srcRect, Long srcUnit, Long lpEnumerateMetafileProc, Long callbackData, Long imageAttributes
	RETURN xfcGdipEnumerateMetafileSrcRectDestPointI(m.graphics, m.metafile, @m.destPoint, @m.srcRect, m.srcUnit, m.lpEnumerateMetafileProc, m.callbackData, m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileSrcRectDestPoints(graphics, metafile, destPoints, Count, srcRect, srcUnit, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileSrcRectDestPoints IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileSrcRectDestPoints Long graphics, Long metafile, String @destPoints, Long Count, String @srcRect, Long srcUnit, Long lpEnumerateMetafileProc, Long callbackData, Long imageAttributes
	RETURN xfcGdipEnumerateMetafileSrcRectDestPoints(m.graphics, m.metafile, @m.destPoints, m.Count, @m.srcRect, m.srcUnit, m.lpEnumerateMetafileProc, m.callbackData, m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileSrcRectDestPointsI(graphics, metafile, destPoints, Count, srcRect, srcUnit, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileSrcRectDestPointsI IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileSrcRectDestPointsI Long graphics, Long metafile, String @destPoints, Long Count, String @srcRect, Long srcUnit, Long lpEnumerateMetafileProc, Long callbackData, Long imageAttributes
	RETURN xfcGdipEnumerateMetafileSrcRectDestPointsI(m.graphics, m.metafile, @m.destPoints, m.Count, @m.srcRect, m.srcUnit, m.lpEnumerateMetafileProc, m.callbackData, m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileSrcRectDestRect(graphics, metafile, destRect, srcRect, srcUnit, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileSrcRectDestRect IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileSrcRectDestRect Long graphics, Long metafile, String @destRect, String @srcRect, Long srcUnit, Long lpEnumerateMetafileProc, Long callbackData, Long imageAttributes
	RETURN xfcGdipEnumerateMetafileSrcRectDestRect(m.graphics, m.metafile, @m.destRect, @m.srcRect, m.srcUnit, m.lpEnumerateMetafileProc, m.callbackData, m.imageAttributes)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipEnumerateMetafileSrcRectDestRectI(graphics, metafile, destRect, srcRect, srcUnit, lpEnumerateMetafileProc, callbackData, imageAttributes)
*********************************************************************
	DECLARE Long GdipEnumerateMetafileSrcRectDestRectI IN GDIPLUS.DLL AS xfcGdipEnumerateMetafileSrcRectDestRectI Long graphics, Long metafile, String @destRect, String @srcRect, Long srcUnit, Long lpEnumerateMetafileProc, Long callbackData, Long imageAttributes
	RETURN xfcGdipEnumerateMetafileSrcRectDestRectI(m.graphics, m.metafile, @m.destRect, @m.srcRect, m.srcUnit, m.lpEnumerateMetafileProc, m.callbackData, m.imageAttributes)
ENDFUNC
#ENDIF

*********************************************************************
FUNCTION xfcGdipFillClosedCurve(graphics, brush, pPoint, Count)
*********************************************************************
	DECLARE Long GdipFillClosedCurve IN GDIPLUS.DLL AS xfcGdipFillClosedCurve Long graphics, Long brush, String @pPoint, Long Count
	RETURN xfcGdipFillClosedCurve(m.graphics, m.brush, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillClosedCurve2(graphics, brush, pPoint, Count, tension, FillMd)
*********************************************************************
	DECLARE Long GdipFillClosedCurve2 IN GDIPLUS.DLL AS xfcGdipFillClosedCurve2 Long graphics, Long brush, String @pPoint, Long Count, Single tension, Long FillMd
	RETURN xfcGdipFillClosedCurve2(m.graphics, m.brush, @m.pPoint, m.Count, m.tension, m.FillMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillClosedCurve2I(graphics, brush, pPoint, Count, tension, FillMd)
*********************************************************************
	DECLARE Long GdipFillClosedCurve2I IN GDIPLUS.DLL AS xfcGdipFillClosedCurve2I Long graphics, Long brush, String @pPoint, Long Count, Single tension, Long FillMd
	RETURN xfcGdipFillClosedCurve2I(m.graphics, m.brush, @m.pPoint, m.Count, m.tension, m.FillMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillClosedCurveI(graphics, brush, pPoint, Count)
*********************************************************************
	DECLARE Long GdipFillClosedCurveI IN GDIPLUS.DLL AS xfcGdipFillClosedCurveI Long graphics, Long brush, String @pPoint, Long Count
	RETURN xfcGdipFillClosedCurveI(m.graphics, m.brush, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillEllipse(graphics, brush, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipFillEllipse IN GDIPLUS.DLL AS xfcGdipFillEllipse Long graphics, Long brush, Single x, Single y, Single nWidth, Single Height
	RETURN xfcGdipFillEllipse(m.graphics, m.brush, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillEllipseI(graphics, brush, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipFillEllipseI IN GDIPLUS.DLL AS xfcGdipFillEllipseI Long graphics, Long brush, Long x, Long y, Long nWidth, Long Height
	RETURN xfcGdipFillEllipseI(m.graphics, m.brush, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillPath(graphics, brush, path)
*********************************************************************
	DECLARE Long GdipFillPath IN GDIPLUS.DLL AS xfcGdipFillPath Long graphics, Long brush, Long path
	RETURN xfcGdipFillPath(m.graphics, m.brush, m.path)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillPie(graphics, brush, x, y, nWidth, Height, startAngle, sweepAngle)
*********************************************************************
	DECLARE Long GdipFillPie IN GDIPLUS.DLL AS xfcGdipFillPie Long graphics, Long brush, Single x, Single y, Single nWidth, Single Height, Single startAngle, Single sweepAngle
	RETURN xfcGdipFillPie(m.graphics, m.brush, m.x, m.y, m.nWidth, m.Height, m.startAngle, m.sweepAngle)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillPieI(graphics, brush, x, y, nWidth, Height, startAngle, sweepAngle)
*********************************************************************
	DECLARE Long GdipFillPieI IN GDIPLUS.DLL AS xfcGdipFillPieI Long graphics, Long brush, Long x, Long y, Long nWidth, Long Height, Single startAngle, Single sweepAngle
	RETURN xfcGdipFillPieI(m.graphics, m.brush, m.x, m.y, m.nWidth, m.Height, m.startAngle, m.sweepAngle)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillPolygon(graphics, brush, pPoint, Count, FillMd)
*********************************************************************
	DECLARE Long GdipFillPolygon IN GDIPLUS.DLL AS xfcGdipFillPolygon Long graphics, Long brush, String @pPoint, Long Count, Long FillMd
	RETURN xfcGdipFillPolygon(m.graphics, m.brush, @m.pPoint, m.Count, m.FillMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillPolygonI(graphics, brush, pPoint, Count, FillMd)
*********************************************************************
	DECLARE Long GdipFillPolygonI IN GDIPLUS.DLL AS xfcGdipFillPolygonI Long graphics, Long brush, String @pPoint, Long Count, Long FillMd
	RETURN xfcGdipFillPolygonI(m.graphics, m.brush, @m.pPoint, m.Count, m.FillMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillRectangle(graphics, brush, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipFillRectangle IN GDIPLUS.DLL AS xfcGdipFillRectangle Long graphics, Long brush, Single x, Single y, Single nWidth, Single Height
	RETURN xfcGdipFillRectangle(m.graphics, m.brush, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillRectangleI(graphics, brush, x, y, nWidth, Height)
*********************************************************************
	DECLARE Long GdipFillRectangleI IN GDIPLUS.DLL AS xfcGdipFillRectangleI Long graphics, Long brush, Long x, Long y, Long nWidth, Long Height
	RETURN xfcGdipFillRectangleI(m.graphics, m.brush, m.x, m.y, m.nWidth, m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillRectangles(graphics, brush, rects, Count)
*********************************************************************
	DECLARE Long GdipFillRectangles IN GDIPLUS.DLL AS xfcGdipFillRectangles Long graphics, Long brush, String @rects, Long Count
	RETURN xfcGdipFillRectangles(m.graphics, m.brush, @m.rects, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillRectanglesI(graphics, brush, rects, Count)
*********************************************************************
	DECLARE Long GdipFillRectanglesI IN GDIPLUS.DLL AS xfcGdipFillRectanglesI Long graphics, Long brush, String @rects, Long Count
	RETURN xfcGdipFillRectanglesI(m.graphics, m.brush, @m.rects, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFillRegion(graphics, brush, region)
*********************************************************************
	DECLARE Long GdipFillRegion IN GDIPLUS.DLL AS xfcGdipFillRegion Long graphics, Long brush, Long region
	RETURN xfcGdipFillRegion(m.graphics, m.brush, m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipFlush(graphics, intention)
*********************************************************************
	DECLARE Long GdipFlush IN GDIPLUS.DLL AS xfcGdipFlush Long graphics, Long intention
	RETURN xfcGdipFlush(m.graphics, m.intention)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetClip(graphics, region)
*********************************************************************
	DECLARE Long GdipGetClip IN GDIPLUS.DLL AS xfcGdipGetClip Long graphics, Long region
	RETURN xfcGdipGetClip(m.graphics, m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetClipBounds(graphics, nRect)
*********************************************************************
	DECLARE Long GdipGetClipBounds IN GDIPLUS.DLL AS xfcGdipGetClipBounds Long graphics, String @nRect
	RETURN xfcGdipGetClipBounds(m.graphics, @m.nRect)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetClipBoundsI(graphics, nRect)
*********************************************************************
	DECLARE Long GdipGetClipBoundsI IN GDIPLUS.DLL AS xfcGdipGetClipBoundsI Long graphics, String @nRect
	RETURN xfcGdipGetClipBoundsI(m.graphics, @m.nRect)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetCompositingMode(graphics, CompositingMd)
*********************************************************************
	DECLARE Long GdipGetCompositingMode IN GDIPLUS.DLL AS xfcGdipGetCompositingMode Long graphics, Long @CompositingMd
	RETURN xfcGdipGetCompositingMode(m.graphics, @m.CompositingMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetCompositingQuality(graphics, CompositingQlty)
*********************************************************************
	DECLARE Long GdipGetCompositingQuality IN GDIPLUS.DLL AS xfcGdipGetCompositingQuality Long graphics, Long @CompositingQlty
	RETURN xfcGdipGetCompositingQuality(m.graphics, @m.CompositingQlty)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetDC(graphics, hdc)
*********************************************************************
	DECLARE Long GdipGetDC IN GDIPLUS.DLL AS xfcGdipGetDC Long graphics, Long @hdc
	RETURN xfcGdipGetDC(m.graphics, @m.hdc)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetDpiX(graphics, dpi)
*********************************************************************
	DECLARE Long GdipGetDpiX IN GDIPLUS.DLL AS xfcGdipGetDpiX Long graphics, Single @dpi
	RETURN xfcGdipGetDpiX(m.graphics, @m.dpi)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetDpiY(graphics, dpi)
*********************************************************************
	DECLARE Long GdipGetDpiY IN GDIPLUS.DLL AS xfcGdipGetDpiY Long graphics, Single @dpi
	RETURN xfcGdipGetDpiY(m.graphics, @m.dpi)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageGraphicsContext(nImage, graphics)
*********************************************************************
	DECLARE Long GdipGetImageGraphicsContext IN GDIPLUS.DLL AS xfcGdipGetImageGraphicsContext Long nImage, Long @graphics
	RETURN xfcGdipGetImageGraphicsContext(m.nImage, @m.graphics)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetInterpolationMode(graphics, interpolation)
*********************************************************************
	DECLARE Long GdipGetInterpolationMode IN GDIPLUS.DLL AS xfcGdipGetInterpolationMode Long graphics, Long @interpolation
	RETURN xfcGdipGetInterpolationMode(m.graphics, @m.interpolation)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetNearestColor(graphics, Argb)
*********************************************************************
	DECLARE Long GdipGetNearestColor IN GDIPLUS.DLL AS xfcGdipGetNearestColor Long graphics, Long @Argb
	RETURN xfcGdipGetNearestColor(m.graphics, @m.Argb)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPageScale(graphics, sscale)
*********************************************************************
	DECLARE Long GdipGetPageScale IN GDIPLUS.DLL AS xfcGdipGetPageScale Long graphics, Single @sscale
	RETURN xfcGdipGetPageScale(m.graphics, @m.sscale)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPageUnit(graphics, unit)
*********************************************************************
	DECLARE Long GdipGetPageUnit IN GDIPLUS.DLL AS xfcGdipGetPageUnit Long graphics, Long @unit
	RETURN xfcGdipGetPageUnit(m.graphics, @m.unit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPixelOffsetMode(graphics, PixOffsetMode)
*********************************************************************
	DECLARE Long GdipGetPixelOffsetMode IN GDIPLUS.DLL AS xfcGdipGetPixelOffsetMode Long graphics, Long @PixOffsetMode
	RETURN xfcGdipGetPixelOffsetMode(m.graphics, @m.PixOffsetMode)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRenderingOrigin(graphics, x, y)
*********************************************************************
	DECLARE Long GdipGetRenderingOrigin IN GDIPLUS.DLL AS xfcGdipGetRenderingOrigin Long graphics, Long @x, Long @y
	RETURN xfcGdipGetRenderingOrigin(m.graphics, @m.x, @m.y)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetSmoothingMode(graphics, SmoothingMd)
*********************************************************************
	DECLARE Long GdipGetSmoothingMode IN GDIPLUS.DLL AS xfcGdipGetSmoothingMode Long graphics, Long @SmoothingMd
	RETURN xfcGdipGetSmoothingMode(m.graphics, @m.SmoothingMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetStringFormatMeasurableCharacterRangeCount(StringFormat, Count)
*********************************************************************
	DECLARE Long GdipGetStringFormatMeasurableCharacterRangeCount IN GDIPLUS.DLL AS xfcGdipGetStringFormatMeasurableCharacterRangeCount Long StringFormat, Long @Count
	RETURN xfcGdipGetStringFormatMeasurableCharacterRangeCount(m.StringFormat, @m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetTextContrast(graphics, contrast)
*********************************************************************
	DECLARE Long GdipGetTextContrast IN GDIPLUS.DLL AS xfcGdipGetTextContrast Long graphics, Long @contrast
	RETURN xfcGdipGetTextContrast(m.graphics, @m.contrast)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetTextRenderingHint(graphics, mode)
*********************************************************************
	DECLARE Long GdipGetTextRenderingHint IN GDIPLUS.DLL AS xfcGdipGetTextRenderingHint Long graphics, Long @mode
	RETURN xfcGdipGetTextRenderingHint(m.graphics, @m.mode)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetVisibleClipBounds(graphics, nRect)
*********************************************************************
	DECLARE Long GdipGetVisibleClipBounds IN GDIPLUS.DLL AS xfcGdipGetVisibleClipBounds Long graphics, String @nRect
	RETURN xfcGdipGetVisibleClipBounds(m.graphics, @m.nRect)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetVisibleClipBoundsI(graphics, nRect)
*********************************************************************
	DECLARE Long GdipGetVisibleClipBoundsI IN GDIPLUS.DLL AS xfcGdipGetVisibleClipBoundsI Long graphics, String @nRect
	RETURN xfcGdipGetVisibleClipBoundsI(m.graphics, @m.nRect)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetWorldTransform(graphics, matrix)
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
*********************************************************************
	DECLARE Long GdipGetWorldTransform IN GDIPLUS.DLL AS xfcGdipGetWorldTransform Long graphics, Long matrix
	RETURN xfcGdipGetWorldTransform(m.graphics, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGraphicsClear(graphics, lColor)
*********************************************************************
	DECLARE Long GdipGraphicsClear IN GDIPLUS.DLL AS xfcGdipGraphicsClear Long graphics, Long lColor
	RETURN xfcGdipGraphicsClear(m.graphics, m.lColor)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsClipEmpty(graphics, result)
*********************************************************************
	DECLARE Long GdipIsClipEmpty IN GDIPLUS.DLL AS xfcGdipIsClipEmpty Long graphics, Long @result
	RETURN xfcGdipIsClipEmpty(m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisibleClipEmpty(graphics, result)
*********************************************************************
	DECLARE Long GdipIsVisibleClipEmpty IN GDIPLUS.DLL AS xfcGdipIsVisibleClipEmpty Long graphics, Long @result
	RETURN xfcGdipIsVisibleClipEmpty(m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisiblePoint(graphics, x, y, result)
*********************************************************************
	DECLARE Long GdipIsVisiblePoint IN GDIPLUS.DLL AS xfcGdipIsVisiblePoint Long graphics, Single x, Single y, Long @result
	RETURN xfcGdipIsVisiblePoint(m.graphics, m.x, m.y, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisiblePointI(graphics, x, y, result)
*********************************************************************
	DECLARE Long GdipIsVisiblePointI IN GDIPLUS.DLL AS xfcGdipIsVisiblePointI Long graphics, Long x, Long y, Long @result
	RETURN xfcGdipIsVisiblePointI(m.graphics, m.x, m.y, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisibleRect(graphics, x, y, nWidth, Height, result)
*********************************************************************
	DECLARE Long GdipIsVisibleRect IN GDIPLUS.DLL AS xfcGdipIsVisibleRect Long graphics, Single x, Single y, Single nWidth, Single Height, Long @result
	RETURN xfcGdipIsVisibleRect(m.graphics, m.x, m.y, m.nWidth, m.Height, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisibleRectI(graphics, x, y, nWidth, Height, result)
*********************************************************************
	DECLARE Long GdipIsVisibleRectI IN GDIPLUS.DLL AS xfcGdipIsVisibleRectI Long graphics, Long x, Long y, Long nWidth, Long Height, Long @result
	RETURN xfcGdipIsVisibleRectI(m.graphics, m.x, m.y, m.nWidth, m.Height, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipMeasureCharacterRanges(graphics, str, length, thefont, layoutRect, StringFormat, regionCount, regions)
** 2013/04/12 CEhlscheidt fixed API declaration for the 'regions' parameter to string
*********************************************************************
	DECLARE Long GdipMeasureCharacterRanges IN GDIPLUS.DLL AS xfcGdipMeasureCharacterRanges Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, Long regionCount, String @regions
	RETURN xfcGdipMeasureCharacterRanges(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, m.regionCount, @m.regions)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipMeasureString(graphics, str, length, thefont, layoutRect, StringFormat, boundingBox, codepointsFitted, linesFilled)
*********************************************************************
	DECLARE Long GdipMeasureString IN GDIPLUS.DLL AS xfcGdipMeasureString Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, String @boundingBox, Long @codepointsFitted, Long @linesFilled
	RETURN xfcGdipMeasureString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, @m.boundingBox, @m.codepointsFitted, @m.linesFilled)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipMultiplyWorldTransform(graphics, matrix, order)
*********************************************************************
	DECLARE Long GdipMultiplyWorldTransform IN GDIPLUS.DLL AS xfcGdipMultiplyWorldTransform Long graphics, Long matrix, Long order
	RETURN xfcGdipMultiplyWorldTransform(m.graphics, m.matrix, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipReleaseDC(graphics, hdc)
*********************************************************************
	DECLARE Long GdipReleaseDC IN GDIPLUS.DLL AS xfcGdipReleaseDC Long graphics, Long hdc
	RETURN xfcGdipReleaseDC(m.graphics, m.hdc)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipResetClip(graphics)
*********************************************************************
	DECLARE Long GdipResetClip IN GDIPLUS.DLL AS xfcGdipResetClip Long graphics
	RETURN xfcGdipResetClip(m.graphics)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipResetWorldTransform(graphics)
*********************************************************************
	DECLARE Long GdipResetWorldTransform IN GDIPLUS.DLL AS xfcGdipResetWorldTransform Long graphics
	RETURN xfcGdipResetWorldTransform(m.graphics)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipRestoreGraphics(graphics, State)
*********************************************************************
	DECLARE Long GdipRestoreGraphics IN GDIPLUS.DLL AS xfcGdipRestoreGraphics Long graphics, Long State
	RETURN xfcGdipRestoreGraphics(m.graphics, m.State)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipRotateWorldTransform(graphics, Angle, order)
*********************************************************************
	DECLARE Long GdipRotateWorldTransform IN GDIPLUS.DLL AS xfcGdipRotateWorldTransform Long graphics, Single Angle, Long order
	RETURN xfcGdipRotateWorldTransform(m.graphics, m.Angle, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSaveGraphics(graphics, State)
*********************************************************************
	DECLARE Long GdipSaveGraphics IN GDIPLUS.DLL AS xfcGdipSaveGraphics Long graphics, Long @State
	RETURN xfcGdipSaveGraphics(m.graphics, @m.State)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipScaleWorldTransform(graphics, sx, sy, order)
*********************************************************************
	DECLARE Long GdipScaleWorldTransform IN GDIPLUS.DLL AS xfcGdipScaleWorldTransform Long graphics, Single sx, Single sy, Long order
	RETURN xfcGdipScaleWorldTransform(m.graphics, m.sx, m.sy, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetClipGraphics(graphics, srcgraphics, CombineMd)
*********************************************************************
	DECLARE Long GdipSetClipGraphics IN GDIPLUS.DLL AS xfcGdipSetClipGraphics Long graphics, Long srcgraphics, Long CombineMd
	RETURN xfcGdipSetClipGraphics(m.graphics, m.srcgraphics, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetClipHrgn(graphics, hRgn, CombineMd)
*********************************************************************
	DECLARE Long GdipSetClipHrgn IN GDIPLUS.DLL AS xfcGdipSetClipHrgn Long graphics, Long hRgn, Long CombineMd
	RETURN xfcGdipSetClipHrgn(m.graphics, m.hRgn, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetClipPath(graphics, path, CombineMd)
*********************************************************************
	DECLARE Long GdipSetClipPath IN GDIPLUS.DLL AS xfcGdipSetClipPath Long graphics, Long path, Long CombineMd
	RETURN xfcGdipSetClipPath(m.graphics, m.path, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetClipRect(graphics, x, y, nWidth, Height, CombineMd)
*********************************************************************
	DECLARE Long GdipSetClipRect IN GDIPLUS.DLL AS xfcGdipSetClipRect Long graphics, Single x, Single y, Single nWidth, Single Height, Long CombineMd
	RETURN xfcGdipSetClipRect(m.graphics, m.x, m.y, m.nWidth, m.Height, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetClipRectI(graphics, x, y, nWidth, Height, CombineMd)
*********************************************************************
	DECLARE Long GdipSetClipRectI IN GDIPLUS.DLL AS xfcGdipSetClipRectI Long graphics, Long x, Long y, Long nWidth, Long Height, Long CombineMd
	RETURN xfcGdipSetClipRectI(m.graphics, m.x, m.y, m.nWidth, m.Height, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetClipRegion(graphics, region, CombineMd)
*********************************************************************
	DECLARE Long GdipSetClipRegion IN GDIPLUS.DLL AS xfcGdipSetClipRegion Long graphics, Long region, Long CombineMd
	RETURN xfcGdipSetClipRegion(m.graphics, m.region, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetCompositingMode(graphics, CompositingMd)
*********************************************************************
	DECLARE Long GdipSetCompositingMode IN GDIPLUS.DLL AS xfcGdipSetCompositingMode Long graphics, Long CompositingMd
	RETURN xfcGdipSetCompositingMode(m.graphics, m.CompositingMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetCompositingQuality(graphics, CompositingQlty)
*********************************************************************
	DECLARE Long GdipSetCompositingQuality IN GDIPLUS.DLL AS xfcGdipSetCompositingQuality Long graphics, Long CompositingQlty
	RETURN xfcGdipSetCompositingQuality(m.graphics, m.CompositingQlty)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetInterpolationMode(graphics, interpolation)
*********************************************************************
	DECLARE Long GdipSetInterpolationMode IN GDIPLUS.DLL AS xfcGdipSetInterpolationMode Long graphics, Long interpolation
	RETURN xfcGdipSetInterpolationMode(m.graphics, m.interpolation)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPageScale(graphics, sscale)
*********************************************************************
	DECLARE Long GdipSetPageScale IN GDIPLUS.DLL AS xfcGdipSetPageScale Long graphics, Single sscale
	RETURN xfcGdipSetPageScale(m.graphics, m.sscale)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPageUnit(graphics, unit)
*********************************************************************
	DECLARE Long GdipSetPageUnit IN GDIPLUS.DLL AS xfcGdipSetPageUnit Long graphics, Long unit
	RETURN xfcGdipSetPageUnit(m.graphics, m.unit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPixelOffsetMode(graphics, PixOffsetMode)
*********************************************************************
	DECLARE Long GdipSetPixelOffsetMode IN GDIPLUS.DLL AS xfcGdipSetPixelOffsetMode Long graphics, Long PixOffsetMode
	RETURN xfcGdipSetPixelOffsetMode(m.graphics, m.PixOffsetMode)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetRenderingOrigin(graphics, x, y)
*********************************************************************
	DECLARE Long GdipSetRenderingOrigin IN GDIPLUS.DLL AS xfcGdipSetRenderingOrigin Long graphics, Long x, Long y
	RETURN xfcGdipSetRenderingOrigin(m.graphics, m.x, m.y)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetSmoothingMode(graphics, SmoothingMd)
*********************************************************************
	DECLARE Long GdipSetSmoothingMode IN GDIPLUS.DLL AS xfcGdipSetSmoothingMode Long graphics, Long SmoothingMd
	RETURN xfcGdipSetSmoothingMode(m.graphics, m.SmoothingMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatAlign(StringFormat, Align)
*********************************************************************
	DECLARE Long GdipSetStringFormatAlign IN GDIPLUS.DLL AS xfcGdipSetStringFormatAlign Long StringFormat, Long Align
	RETURN xfcGdipSetStringFormatAlign(m.StringFormat, m.Align)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatFlags(StringFormat, flags)
*********************************************************************
	DECLARE Long GdipSetStringFormatFlags IN GDIPLUS.DLL AS xfcGdipSetStringFormatFlags Long StringFormat, Long flags
	RETURN xfcGdipSetStringFormatFlags(m.StringFormat, m.flags)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetTextContrast(graphics, contrast)
*********************************************************************
	DECLARE Long GdipSetTextContrast IN GDIPLUS.DLL AS xfcGdipSetTextContrast Long graphics, Long contrast
	RETURN xfcGdipSetTextContrast(m.graphics, m.contrast)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetTextRenderingHint(graphics, mode)
*********************************************************************
	DECLARE Long GdipSetTextRenderingHint IN GDIPLUS.DLL AS xfcGdipSetTextRenderingHint Long graphics, Long mode
	RETURN xfcGdipSetTextRenderingHint(m.graphics, m.mode)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetWorldTransform(graphics, matrix)
*********************************************************************
	DECLARE Long GdipSetWorldTransform IN GDIPLUS.DLL AS xfcGdipSetWorldTransform Long graphics, Long matrix
	RETURN xfcGdipSetWorldTransform(m.graphics, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipStringFormatGetGenericTypographic(StringFormat)
*********************************************************************
	DECLARE Long GdipStringFormatGetGenericTypographic IN GDIPLUS.DLL AS xfcGdipStringFormatGetGenericTypographic Long @StringFormat
	RETURN xfcGdipStringFormatGetGenericTypographic(@m.StringFormat)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTransformPoints(graphics, destSpace, srcSpace, pPoint, Count)
*********************************************************************
	DECLARE Long GdipTransformPoints IN GDIPLUS.DLL AS xfcGdipTransformPoints Long graphics, Long destSpace, Long srcSpace, String @pPoint, Long Count
	RETURN xfcGdipTransformPoints(m.graphics, m.destSpace, m.srcSpace, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTransformPointsI(graphics, destSpace, srcSpace, pPoint, Count)
*********************************************************************
	DECLARE Long GdipTransformPointsI IN GDIPLUS.DLL AS xfcGdipTransformPointsI Long graphics, Long destSpace, Long srcSpace, String @pPoint, Long Count
	RETURN xfcGdipTransformPointsI(m.graphics, m.destSpace, m.srcSpace, @m.pPoint, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTranslateClip(graphics, dx, dy)
*********************************************************************
	DECLARE Long GdipTranslateClip IN GDIPLUS.DLL AS xfcGdipTranslateClip Long graphics, Single dx, Single dy
	RETURN xfcGdipTranslateClip(m.graphics, m.dx, m.dy)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTranslateClipI(graphics, dx, dy)
*********************************************************************
	DECLARE Long GdipTranslateClipI IN GDIPLUS.DLL AS xfcGdipTranslateClipI Long graphics, Long dx, Long dy
	RETURN xfcGdipTranslateClipI(m.graphics, m.dx, m.dy)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTranslateWorldTransform(graphics, dx, dy, order)
*********************************************************************
	DECLARE Long GdipTranslateWorldTransform IN GDIPLUS.DLL AS xfcGdipTranslateWorldTransform Long graphics, Single dx, Single dy, Long order
	RETURN xfcGdipTranslateWorldTransform(m.graphics, m.dx, m.dy, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcDrawIcon(hDC, XPos, YPos, HICON)
*********************************************************************
	DECLARE Long DrawIcon IN WIN32API AS xfcDrawIcon Long hDC, Integer XPos, Integer YPos, Long HICON
	RETURN xfcDrawIcon(m.hDC, m.XPos, m.YPos, m.HICON)
ENDFUNC

*********************************************************************
FUNCTION xfcDrawIconEx(hdc, xLeft, yTop, hIcon, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDraw, diFlags)
*********************************************************************
	DECLARE Long DrawIconEx IN WIN32API AS xfcDrawIconEx Long hdc, Long xLeft, Long yTop, Long hIcon, Long cxWidth, Long cyWidth, Long istepIfAniCur, Long hbrFlickerFreeDraw, Long diFlags
	RETURN xfcDrawIconEx(m.hdc, m.xLeft, m.yTop, m.hIcon, m.cxWidth, m.cyWidth, m.istepIfAniCur, m.hbrFlickerFreeDraw, m.diFlags)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCICON
*********************************************************************
FUNCTION GetObject1(hgdiobj, cbBuffer, lpvObject)
*********************************************************************
	DECLARE Long GetObject IN WIN32API AS GetObject1 Long hgdiobj, Long cbBuffer, String @lpvObject
	RETURN GetObject1(m.hgdiobj, m.cbBuffer, @m.lpvObject)
ENDFUNC

*********************************************************************
FUNCTION xfcDestroyIcon(hIcon)
*********************************************************************
	DECLARE Long DestroyIcon IN WIN32API AS xfcDestroyIcon Long hIcon
	RETURN xfcDestroyIcon(m.hIcon)
ENDFUNC

*********************************************************************
FUNCTION xfcGetIconInfo(hIcon, piconinfo)
*********************************************************************
	DECLARE Long GetIconInfo IN WIN32API AS xfcGetIconInfo Long hIcon, String @piconinfo
	RETURN xfcGetIconInfo(m.hIcon, @m.piconinfo)
ENDFUNC

*********************************************************************
FUNCTION xfcExtractAssociatedIcon(hInst, lpIconPath, lpiIcon)
*********************************************************************
	DECLARE Integer ExtractAssociatedIcon IN shell32 AS xfcExtractAssociatedIcon Integer hInst, String lpIconPath, Integer @lpiIcon
	RETURN xfcExtractAssociatedIcon(m.hInst, m.lpIconPath, @m.lpiIcon)
ENDFUNC

*********************************************************************
FUNCTION xfcExtractIcon(hInst, lpszExeFileName, lpiIcon)
*********************************************************************
	DECLARE Integer ExtractIcon IN shell32 AS xfcExtractIcon Integer hInst, String lpszExeFileName, Integer lpiIcon
	RETURN xfcExtractIcon(m.hInst, m.lpszExeFileName, m.lpiIcon)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCIMAGE
*********************************************************************
FUNCTION xfcGdipSaveAddImage_S(nImage, newnImage, encoderParams)
*********************************************************************
	DECLARE Long GdipSaveAddImage IN GDIPLUS.DLL AS xfcGdipSaveAddImage_S Long nImage, Long newnImage, String encoderParams
	RETURN xfcGdipSaveAddImage_S(m.nImage, m.newnImage, m.encoderParams)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSaveAdd_S(nImage, encoderParams)
*********************************************************************
	DECLARE Long GdipSaveAdd IN GDIPLUS.DLL AS xfcGdipSaveAdd_S Long nImage, String encoderParams
	RETURN xfcGdipSaveAdd_S(m.nImage, m.encoderParams)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSaveImageToFile_I(nImage, FileName, clsidEncoder, encoderParams)
*********************************************************************
	DECLARE Long GdipSaveImageToFile IN GDIPLUS.DLL AS xfcGdipSaveImageToFile_I Long nImage, String FileName, String clsidEncoder, Long encoderParams
	RETURN xfcGdipSaveImageToFile_I(m.nImage, m.FileName, m.clsidEncoder, m.encoderParams)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSaveImageToStream_I(nImage, stream, clsidEncoder, encoderParams)
*********************************************************************
	DECLARE Long GdipSaveImageToStream IN GDIPLUS.DLL AS xfcGdipSaveImageToStream_I Long nImage, Integer stream, String clsidEncoder, Long encoderParams
	RETURN xfcGdipSaveImageToStream_I(m.nImage, m.stream, m.clsidEncoder, m.encoderParams)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCloneImage(image, cloneImage)
*********************************************************************
	DECLARE Long GdipCloneImage IN GDIPLUS.DLL AS xfcGdipCloneImage Long image, Long @cloneImage
	RETURN xfcGdipCloneImage(m.image, @m.cloneImage)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateBitmapFromHBITMAP(hbitmap, hpalette, hGpBitmap)
*********************************************************************
	DECLARE Long GdipCreateBitmapFromHBITMAP IN GDIPLUS.DLL AS xfcGdipCreateBitmapFromHBITMAP Long hbitmap, Long hpalette, Long @hGpBitmap
	RETURN xfcGdipCreateBitmapFromHBITMAP(m.hbitmap, m.hpalette, @m.hGpBitmap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateHBITMAPFromBitmap(nativeImage, hbmReturn, Argb)
*********************************************************************
	DECLARE Long GdipCreateHBITMAPFromBitmap IN GDIPLUS.DLL AS xfcGdipCreateHBITMAPFromBitmap Long nativeImage, Long @hbmReturn, Long Argb
	RETURN xfcGdipCreateHBITMAPFromBitmap(m.nativeImage, @m.hbmReturn, m.Argb)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDisposeImage(image)
*********************************************************************
	DECLARE Long GdipDisposeImage IN GDIPLUS.DLL AS xfcGdipDisposeImage Long image
	RETURN xfcGdipDisposeImage(m.image)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetAllPropertyItems(nImage, totalBufferSize, numProperties, allItems)
*********************************************************************
	DECLARE Long GdipGetAllPropertyItems IN GDIPLUS.DLL AS xfcGdipGetAllPropertyItems Long nImage, Long totalBufferSize, Long numProperties, String @allItems
	RETURN xfcGdipGetAllPropertyItems(m.nImage, m.totalBufferSize, m.numProperties, @m.allItems)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetEncoderParameterList(nImage, clsidEncoder, Size, buffer)
*********************************************************************
	DECLARE Long GdipGetEncoderParameterList IN GDIPLUS.DLL AS xfcGdipGetEncoderParameterList Long nImage, String @clsidEncoder, Long Size, Long buffer
	RETURN xfcGdipGetEncoderParameterList(m.nImage, @m.clsidEncoder, m.Size, m.buffer)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetEncoderParameterListSize(nImage, clsidEncoder, Size)
*********************************************************************
	DECLARE Long GdipGetEncoderParameterListSize IN GDIPLUS.DLL AS xfcGdipGetEncoderParameterListSize Long nImage, String @clsidEncoder, Long @Size
	RETURN xfcGdipGetEncoderParameterListSize(m.nImage, @m.clsidEncoder, @m.Size)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageBounds(nImage, srcRect, srcUnit)
*********************************************************************
	DECLARE Long GdipGetImageBounds IN GDIPLUS.DLL AS xfcGdipGetImageBounds Long nImage, String @srcRect, Long @srcUnit
	RETURN xfcGdipGetImageBounds(m.nImage, @m.srcRect, @m.srcUnit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageDimension(nImage, nWidth, Height)
*********************************************************************
	DECLARE Long GdipGetImageDimension IN GDIPLUS.DLL AS xfcGdipGetImageDimension Long nImage, Single @nWidth, Single @Height
	RETURN xfcGdipGetImageDimension(m.nImage, @m.nWidth, @m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageFlags(nImage, flags)
*********************************************************************
	DECLARE Long GdipGetImageFlags IN GDIPLUS.DLL AS xfcGdipGetImageFlags Long nImage, Long @flags
	RETURN xfcGdipGetImageFlags(m.nImage, @m.flags)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageHeight(nImage, Height)
*********************************************************************
	DECLARE Long GdipGetImageHeight IN GDIPLUS.DLL AS xfcGdipGetImageHeight Long nImage, Long @Height
	RETURN xfcGdipGetImageHeight(m.nImage, @m.Height)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageHorizontalResolution(nImage, resolution)
*********************************************************************
	DECLARE Long GdipGetImageHorizontalResolution IN GDIPLUS.DLL AS xfcGdipGetImageHorizontalResolution Long nImage, Single @resolution
	RETURN xfcGdipGetImageHorizontalResolution(m.nImage, @m.resolution)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImagePalette(nImage, palette, Size)
*********************************************************************
	DECLARE Long GdipGetImagePalette IN GDIPLUS.DLL AS xfcGdipGetImagePalette Long nImage, String @palette, Long Size
	RETURN xfcGdipGetImagePalette(m.nImage, @m.palette, m.Size)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImagePaletteSize(nImage, Size)
*********************************************************************
	DECLARE Long GdipGetImagePaletteSize IN GDIPLUS.DLL AS xfcGdipGetImagePaletteSize Long nImage, Long @Size
	RETURN xfcGdipGetImagePaletteSize(m.nImage, @m.Size)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImagePixelFormat(nImage, PixelFormat)
*********************************************************************
	DECLARE Long GdipGetImagePixelFormat IN GDIPLUS.DLL AS xfcGdipGetImagePixelFormat Long nImage, Long @PixelFormat
	RETURN xfcGdipGetImagePixelFormat(m.nImage, @m.PixelFormat)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageRawFormat(nImage, format)
*********************************************************************
	DECLARE Long GdipGetImageRawFormat IN GDIPLUS.DLL AS xfcGdipGetImageRawFormat Long nImage, String @format
	RETURN xfcGdipGetImageRawFormat(m.nImage, @m.format)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageThumbnail(nImage, thumbWidth, thumbHeight, thumbImage, pCALLBACK, callbackData)
*********************************************************************
	DECLARE Long GdipGetImageThumbnail IN GDIPLUS.DLL AS xfcGdipGetImageThumbnail Long nImage, Long thumbWidth, Long thumbHeight, Long @thumbImage, Long pCALLBACK, Long callbackData
	RETURN xfcGdipGetImageThumbnail(m.nImage, m.thumbWidth, m.thumbHeight, @m.thumbImage, m.pCALLBACK, m.callbackData)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageVerticalResolution(nImage, resolution)
*********************************************************************
	DECLARE Long GdipGetImageVerticalResolution IN GDIPLUS.DLL AS xfcGdipGetImageVerticalResolution Long nImage, Single @resolution
	RETURN xfcGdipGetImageVerticalResolution(m.nImage, @m.resolution)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetImageWidth(nImage, nWidth)
*********************************************************************
	DECLARE Long GdipGetImageWidth IN GDIPLUS.DLL AS xfcGdipGetImageWidth Long nImage, Long @nWidth
	RETURN xfcGdipGetImageWidth(m.nImage, @m.nWidth)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPropertyCount(nImage, numOfProperty)
*********************************************************************
	DECLARE Long GdipGetPropertyCount IN GDIPLUS.DLL AS xfcGdipGetPropertyCount Long nImage, Long @numOfProperty
	RETURN xfcGdipGetPropertyCount(m.nImage, @m.numOfProperty)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPropertyIdList(nImage, numOfProperty, list)
*********************************************************************
	DECLARE Long GdipGetPropertyIdList IN GDIPLUS.DLL AS xfcGdipGetPropertyIdList Long nImage, Long numOfProperty, String @list
	RETURN xfcGdipGetPropertyIdList(m.nImage, m.numOfProperty, @m.list)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPropertyItem(nImage, propId, propSize, dwPtr)
*********************************************************************
	DECLARE Long GdipGetPropertyItem IN GDIPLUS.DLL AS xfcGdipGetPropertyItem Long nImage, Long propId, Long propSize, Long dwPtr
	RETURN xfcGdipGetPropertyItem(m.nImage, m.propId, m.propSize, m.dwPtr)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPropertyItemSize(nImage, propId, Size)
*********************************************************************
	DECLARE Long GdipGetPropertyItemSize IN GDIPLUS.DLL AS xfcGdipGetPropertyItemSize Long nImage, Long propId, Long @Size
	RETURN xfcGdipGetPropertyItemSize(m.nImage, m.propId, @m.Size)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipImageGetFrameCount(nImage, dimensionID, Count)
*********************************************************************
	DECLARE Long GdipImageGetFrameCount IN GDIPLUS.DLL AS xfcGdipImageGetFrameCount Long nImage, String @dimensionID, Long @Count
	RETURN xfcGdipImageGetFrameCount(m.nImage, @m.dimensionID, @m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipImageGetFrameDimensionsCount(nImage, Count)
*********************************************************************
	DECLARE Long GdipImageGetFrameDimensionsCount IN GDIPLUS.DLL AS xfcGdipImageGetFrameDimensionsCount Long nImage, Long @Count
	RETURN xfcGdipImageGetFrameDimensionsCount(m.nImage, @m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipImageGetFrameDimensionsList(nImage, dimensionIDs, Count)
*********************************************************************
	DECLARE Long GdipImageGetFrameDimensionsList IN GDIPLUS.DLL AS xfcGdipImageGetFrameDimensionsList Long nImage, String @dimensionIDs, Long Count
	RETURN xfcGdipImageGetFrameDimensionsList(m.nImage, @m.dimensionIDs, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipImageRotateFlip(nImage, rfType)
*********************************************************************
	DECLARE Long GdipImageRotateFlip IN GDIPLUS.DLL AS xfcGdipImageRotateFlip Long nImage, Long rfType
	RETURN xfcGdipImageRotateFlip(m.nImage, m.rfType)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipImageSelectActiveFrame(nImage, dimensionID, frameIndex)
*********************************************************************
	DECLARE Long GdipImageSelectActiveFrame IN GDIPLUS.DLL AS xfcGdipImageSelectActiveFrame Long nImage, String @dimensionID, Long frameIndex
	RETURN xfcGdipImageSelectActiveFrame(m.nImage, @m.dimensionID, m.frameIndex)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipLoadImageFromFile(FileName, nImage)
*********************************************************************
	DECLARE Long GdipLoadImageFromFile IN GDIPLUS.DLL AS xfcGdipLoadImageFromFile String FileName, Long @nImage
	RETURN xfcGdipLoadImageFromFile(m.FileName, @m.nImage)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipLoadImageFromFileICM(FileName, nImage)
*********************************************************************
	DECLARE Long GdipLoadImageFromFileICM IN GDIPLUS.DLL AS xfcGdipLoadImageFromFileICM String FileName, Long @nImage
	RETURN xfcGdipLoadImageFromFileICM(m.FileName, @m.nImage)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipLoadImageFromStream(stream, nImage)
*********************************************************************
	DECLARE Long GdipLoadImageFromStream IN GDIPLUS.DLL AS xfcGdipLoadImageFromStream Integer stream, Long @nImage
	RETURN xfcGdipLoadImageFromStream(m.stream, @m.nImage)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipLoadImageFromStreamICM(stream, nImage)
*********************************************************************
	DECLARE Long GdipLoadImageFromStreamICM IN GDIPLUS.DLL AS xfcGdipLoadImageFromStreamICM Integer stream, Long @nImage
	RETURN xfcGdipLoadImageFromStreamICM(m.stream, @m.nImage)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipRemovePropertyItem(nImage, propId)
*********************************************************************
	DECLARE Long GdipRemovePropertyItem IN GDIPLUS.DLL AS xfcGdipRemovePropertyItem Long nImage, Long propId
	RETURN xfcGdipRemovePropertyItem(m.nImage, m.propId)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetImagePalette(nImage, palette)
*********************************************************************
	DECLARE Long GdipSetImagePalette IN GDIPLUS.DLL AS xfcGdipSetImagePalette Long nImage, String @palette
	RETURN xfcGdipSetImagePalette(m.nImage, @m.palette)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPropertyItem(nImage, item)
*********************************************************************
	DECLARE Long GdipSetPropertyItem IN GDIPLUS.DLL AS xfcGdipSetPropertyItem Long nImage, String @item
	RETURN xfcGdipSetPropertyItem(m.nImage, @m.item)
ENDFUNC

*********************************************************************
FUNCTION xfcCopyImage(hImage, uType, cx, cy, uFlags)
*********************************************************************
	DECLARE Long CopyImage IN WIN32API AS xfcCopyImage Long hImage, Long uType, Long cx, Long cy, Long uFlags
	RETURN xfcCopyImage(m.hImage, m.uType, m.cx, m.cy, m.uFlags)
ENDFUNC

*********************************************************************
FUNCTION xfcGlobalAlloc(nFlags, nSize)
*********************************************************************
	DECLARE Long GlobalAlloc IN WIN32API AS xfcGlobalAlloc Long nFlags, Long nSize
	RETURN xfcGlobalAlloc(m.nFlags, m.nSize)
ENDFUNC

*********************************************************************
FUNCTION xfcGlobalFree(nHandle)
*********************************************************************
	DECLARE Long GlobalFree IN WIN32API AS xfcGlobalFree Long nHandle
	RETURN xfcGlobalFree(m.nHandle)
ENDFUNC

*********************************************************************
FUNCTION xfcGlobalLock(hMem)
*********************************************************************
	DECLARE Long GlobalLock IN WIN32API AS xfcGlobalLock Long hMem
	RETURN xfcGlobalLock(m.hMem)
ENDFUNC

*********************************************************************
FUNCTION xfcGlobalSize(hMem)
*********************************************************************
	DECLARE Long GlobalSize IN WIN32API AS xfcGlobalSize Long hMem
	RETURN xfcGlobalSize(m.hMem)
ENDFUNC

*********************************************************************
FUNCTION xfcGlobalUnlock(hMem)
*********************************************************************
	DECLARE Long GlobalUnlock IN WIN32API AS xfcGlobalUnlock Long hMem
	RETURN xfcGlobalUnlock(m.hMem)
ENDFUNC

*********************************************************************
FUNCTION xfcLocalAlloc(uFlags, uBytes)
*********************************************************************
	DECLARE Long LocalAlloc IN WIN32API AS xfcLocalAlloc Long uFlags, Long uBytes
	RETURN xfcLocalAlloc(m.uFlags, m.uBytes)
ENDFUNC

*********************************************************************
FUNCTION xfcLocalFree(HMEM)
*********************************************************************
	DECLARE Long LocalFree IN WIN32API AS xfcLocalFree Long HMEM
	RETURN xfcLocalFree(m.HMEM)
ENDFUNC

*********************************************************************
FUNCTION xfcGetHGlobalFromStream(pstm, phglobal)
*********************************************************************
	DECLARE Long GetHGlobalFromStream IN ole32 AS xfcGetHGlobalFromStream Long pstm, Long @phglobal
	RETURN xfcGetHGlobalFromStream(m.pstm, @m.phglobal)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCPEN
*********************************************************************
FUNCTION xfcGdipClonePen(pen, clonepen)
*********************************************************************
	DECLARE Long GdipClonePen IN GDIPLUS.DLL AS xfcGdipClonePen Long pen, Long @clonepen
	RETURN xfcGdipClonePen(m.pen, @m.clonepen)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreatePen1(Color, nWidth, unit, pen)
*********************************************************************
	DECLARE Long GdipCreatePen1 IN GDIPLUS.DLL AS xfcGdipCreatePen1 Long Color, Single nWidth, Long unit, Long @pen
	RETURN xfcGdipCreatePen1(m.Color, m.nWidth, m.unit, @m.pen)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreatePen2(brush, nWidth, unit, pen)
*********************************************************************
	DECLARE Long GdipCreatePen2 IN GDIPLUS.DLL AS xfcGdipCreatePen2 Long brush, Single nWidth, Long unit, Long @pen
	RETURN xfcGdipCreatePen2(m.brush, m.nWidth, m.unit, @m.pen)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDeletePen(pen)
*********************************************************************
	DECLARE Long GdipDeletePen IN GDIPLUS.DLL AS xfcGdipDeletePen Long pen
	RETURN xfcGdipDeletePen(m.pen)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenBrushFill(pen, brush)
*********************************************************************
	DECLARE Long GdipGetPenBrushFill IN GDIPLUS.DLL AS xfcGdipGetPenBrushFill Long pen, Long @brush
	RETURN xfcGdipGetPenBrushFill(m.pen, @m.brush)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenColor(pen, Argb)
*********************************************************************
	DECLARE Long GdipGetPenColor IN GDIPLUS.DLL AS xfcGdipGetPenColor Long pen, Long @Argb
	RETURN xfcGdipGetPenColor(m.pen, @m.Argb)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenCompoundArray(pen, dash, Count)
*********************************************************************
	DECLARE Long GdipGetPenCompoundArray IN GDIPLUS.DLL AS xfcGdipGetPenCompoundArray Long pen, String @dash, Long Count
	RETURN xfcGdipGetPenCompoundArray(m.pen, @m.dash, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenCompoundCount(pen, Count)
*********************************************************************
	DECLARE Long GdipGetPenCompoundCount IN GDIPLUS.DLL AS xfcGdipGetPenCompoundCount Long pen, Long @Count
	RETURN xfcGdipGetPenCompoundCount(m.pen, @m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenCustomEndCap(pen, customCap)
*********************************************************************
	DECLARE Long GdipGetPenCustomEndCap IN GDIPLUS.DLL AS xfcGdipGetPenCustomEndCap Long pen, Long @customCap
	RETURN xfcGdipGetPenCustomEndCap(m.pen, @m.customCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenCustomStartCap(pen, customCap)
*********************************************************************
	DECLARE Long GdipGetPenCustomStartCap IN GDIPLUS.DLL AS xfcGdipGetPenCustomStartCap Long pen, Long @customCap
	RETURN xfcGdipGetPenCustomStartCap(m.pen, @m.customCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenDashArray(pen, dash, Count)
*********************************************************************
	DECLARE Long GdipGetPenDashArray IN GDIPLUS.DLL AS xfcGdipGetPenDashArray Long pen, String @dash, Long Count
	RETURN xfcGdipGetPenDashArray(m.pen, @m.dash, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenDashCap197819(pen, dashCap)
*********************************************************************
	DECLARE Long GdipGetPenDashCap197819 IN GDIPLUS.DLL AS xfcGdipGetPenDashCap197819 Long pen, Long @dashCap
	RETURN xfcGdipGetPenDashCap197819(m.pen, @m.dashCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenDashCount(pen, Count)
*********************************************************************
	DECLARE Long GdipGetPenDashCount IN GDIPLUS.DLL AS xfcGdipGetPenDashCount Long pen, Long @Count
	RETURN xfcGdipGetPenDashCount(m.pen, @m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenDashOffset(pen, offset)
*********************************************************************
	DECLARE Long GdipGetPenDashOffset IN GDIPLUS.DLL AS xfcGdipGetPenDashOffset Long pen, Single @offset
	RETURN xfcGdipGetPenDashOffset(m.pen, @m.offset)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenDashStyle(pen, dStyle)
*********************************************************************
	DECLARE Long GdipGetPenDashStyle IN GDIPLUS.DLL AS xfcGdipGetPenDashStyle Long pen, Long @dStyle
	RETURN xfcGdipGetPenDashStyle(m.pen, @m.dStyle)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenEndCap(pen, endCap)
*********************************************************************
	DECLARE Long GdipGetPenEndCap IN GDIPLUS.DLL AS xfcGdipGetPenEndCap Long pen, Long @endCap
	RETURN xfcGdipGetPenEndCap(m.pen, @m.endCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenFillType(pen, ptype)
*********************************************************************
	DECLARE Long GdipGetPenFillType IN GDIPLUS.DLL AS xfcGdipGetPenFillType Long pen, Long @ptype
	RETURN xfcGdipGetPenFillType(m.pen, @m.ptype)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenLineJoin(pen, LnJoin)
*********************************************************************
	DECLARE Long GdipGetPenLineJoin IN GDIPLUS.DLL AS xfcGdipGetPenLineJoin Long pen, Long @LnJoin
	RETURN xfcGdipGetPenLineJoin(m.pen, @m.LnJoin)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenMiterLimit(pen, miterLimit)
*********************************************************************
	DECLARE Long GdipGetPenMiterLimit IN GDIPLUS.DLL AS xfcGdipGetPenMiterLimit Long pen, Single @miterLimit
	RETURN xfcGdipGetPenMiterLimit(m.pen, @m.miterLimit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenMode(pen, penMode)
*********************************************************************
	DECLARE Long GdipGetPenMode IN GDIPLUS.DLL AS xfcGdipGetPenMode Long pen, Long @penMode
	RETURN xfcGdipGetPenMode(m.pen, @m.penMode)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenStartCap(pen, startCap)
*********************************************************************
	DECLARE Long GdipGetPenStartCap IN GDIPLUS.DLL AS xfcGdipGetPenStartCap Long pen, Long @startCap
	RETURN xfcGdipGetPenStartCap(m.pen, @m.startCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenTransform(pen, matrix)
*********************************************************************
	DECLARE Long GdipGetPenTransform IN GDIPLUS.DLL AS xfcGdipGetPenTransform Long pen, Long matrix
	RETURN xfcGdipGetPenTransform(m.pen, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetPenWidth(pen, nWidth)
*********************************************************************
	DECLARE Long GdipGetPenWidth IN GDIPLUS.DLL AS xfcGdipGetPenWidth Long pen, Single @nWidth
	RETURN xfcGdipGetPenWidth(m.pen, @m.nWidth)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipMultiplyPenTransform(pen, matrix, order)
*********************************************************************
	DECLARE Long GdipMultiplyPenTransform IN GDIPLUS.DLL AS xfcGdipMultiplyPenTransform Long pen, Long matrix, Long order
	RETURN xfcGdipMultiplyPenTransform(m.pen, m.matrix, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipResetPenTransform(pen)
*********************************************************************
	DECLARE Long GdipResetPenTransform IN GDIPLUS.DLL AS xfcGdipResetPenTransform Long pen
	RETURN xfcGdipResetPenTransform(m.pen)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipRotatePenTransform(pen, Angle, order)
*********************************************************************
	DECLARE Long GdipRotatePenTransform IN GDIPLUS.DLL AS xfcGdipRotatePenTransform Long pen, Single Angle, Long order
	RETURN xfcGdipRotatePenTransform(m.pen, m.Angle, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipScalePenTransform(pen, sx, sy, order)
*********************************************************************
	DECLARE Long GdipScalePenTransform IN GDIPLUS.DLL AS xfcGdipScalePenTransform Long pen, Single sx, Single sy, Long order
	RETURN xfcGdipScalePenTransform(m.pen, m.sx, m.sy, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenBrushFill(pen, brush)
*********************************************************************
	DECLARE Long GdipSetPenBrushFill IN GDIPLUS.DLL AS xfcGdipSetPenBrushFill Long pen, Long brush
	RETURN xfcGdipSetPenBrushFill(m.pen, m.brush)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenColor(pen, Argb)
*********************************************************************
	DECLARE Long GdipSetPenColor IN GDIPLUS.DLL AS xfcGdipSetPenColor Long pen, Long Argb
	RETURN xfcGdipSetPenColor(m.pen, m.Argb)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenCompoundArray(pen, dash, Count)
*********************************************************************
	DECLARE Long GdipSetPenCompoundArray IN GDIPLUS.DLL AS xfcGdipSetPenCompoundArray Long pen, String @dash, Long Count
	RETURN xfcGdipSetPenCompoundArray(m.pen, @m.dash, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenCustomEndCap(pen, customCap)
*********************************************************************
	DECLARE Long GdipSetPenCustomEndCap IN GDIPLUS.DLL AS xfcGdipSetPenCustomEndCap Long pen, Long customCap
	RETURN xfcGdipSetPenCustomEndCap(m.pen, m.customCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenCustomStartCap(pen, customCap)
*********************************************************************
	DECLARE Long GdipSetPenCustomStartCap IN GDIPLUS.DLL AS xfcGdipSetPenCustomStartCap Long pen, Long customCap
	RETURN xfcGdipSetPenCustomStartCap(m.pen, m.customCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenDashArray(pen, dash, Count)
*********************************************************************
	DECLARE Long GdipSetPenDashArray IN GDIPLUS.DLL AS xfcGdipSetPenDashArray Long pen, String @dash, Long Count
	RETURN xfcGdipSetPenDashArray(m.pen, @m.dash, m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenDashCap197819(pen, dashCap)
*********************************************************************
	DECLARE Long GdipSetPenDashCap197819 IN GDIPLUS.DLL AS xfcGdipSetPenDashCap197819 Long pen, Long dashCap
	RETURN xfcGdipSetPenDashCap197819(m.pen, m.dashCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenDashOffset(pen, offset)
*********************************************************************
	DECLARE Long GdipSetPenDashOffset IN GDIPLUS.DLL AS xfcGdipSetPenDashOffset Long pen, Single offset
	RETURN xfcGdipSetPenDashOffset(m.pen, m.offset)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenDashStyle(pen, dStyle)
*********************************************************************
	DECLARE Long GdipSetPenDashStyle IN GDIPLUS.DLL AS xfcGdipSetPenDashStyle Long pen, Long dStyle
	RETURN xfcGdipSetPenDashStyle(m.pen, m.dStyle)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenEndCap(pen, endCap)
*********************************************************************
	DECLARE Long GdipSetPenEndCap IN GDIPLUS.DLL AS xfcGdipSetPenEndCap Long pen, Long endCap
	RETURN xfcGdipSetPenEndCap(m.pen, m.endCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenLineCap197819(pen, startCap, endCap, dashCap)
*********************************************************************
	DECLARE Long GdipSetPenLineCap197819 IN GDIPLUS.DLL AS xfcGdipSetPenLineCap197819 Long pen, Long startCap, Long endCap, Long dashCap
	RETURN xfcGdipSetPenLineCap197819(m.pen, m.startCap, m.endCap, m.dashCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenLineJoin(pen, LnJoin)
*********************************************************************
	DECLARE Long GdipSetPenLineJoin IN GDIPLUS.DLL AS xfcGdipSetPenLineJoin Long pen, Long LnJoin
	RETURN xfcGdipSetPenLineJoin(m.pen, m.LnJoin)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenMiterLimit(pen, miterLimit)
*********************************************************************
	DECLARE Long GdipSetPenMiterLimit IN GDIPLUS.DLL AS xfcGdipSetPenMiterLimit Long pen, Single miterLimit
	RETURN xfcGdipSetPenMiterLimit(m.pen, m.miterLimit)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenMode(pen, penMode)
*********************************************************************
	DECLARE Long GdipSetPenMode IN GDIPLUS.DLL AS xfcGdipSetPenMode Long pen, Long penMode
	RETURN xfcGdipSetPenMode(m.pen, m.penMode)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenStartCap(pen, startCap)
*********************************************************************
	DECLARE Long GdipSetPenStartCap IN GDIPLUS.DLL AS xfcGdipSetPenStartCap Long pen, Long startCap
	RETURN xfcGdipSetPenStartCap(m.pen, m.startCap)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenTransform(pen, matrix)
*********************************************************************
	DECLARE Long GdipSetPenTransform IN GDIPLUS.DLL AS xfcGdipSetPenTransform Long pen, Long matrix
	RETURN xfcGdipSetPenTransform(m.pen, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetPenWidth(pen, nWidth)
*********************************************************************
	DECLARE Long GdipSetPenWidth IN GDIPLUS.DLL AS xfcGdipSetPenWidth Long pen, Single nWidth
	RETURN xfcGdipSetPenWidth(m.pen, m.nWidth)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTranslatePenTransform(pen, dx, dy, order)
*********************************************************************
	DECLARE Long GdipTranslatePenTransform IN GDIPLUS.DLL AS xfcGdipTranslatePenTransform Long pen, Single dx, Single dy, Long order
	RETURN xfcGdipTranslatePenTransform(m.pen, m.dx, m.dy, m.order)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCREGION
*********************************************************************
FUNCTION xfcGdipCloneRegion(region, cloneRegion)
*********************************************************************
	DECLARE Long GdipCloneRegion IN GDIPLUS.DLL AS xfcGdipCloneRegion Long region, Long @cloneRegion
	RETURN xfcGdipCloneRegion(m.region, @m.cloneRegion)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCombineRegionPath(region, path, CombineMd)
*********************************************************************
	DECLARE Long GdipCombineRegionPath IN GDIPLUS.DLL AS xfcGdipCombineRegionPath Long region, Long path, Long CombineMd
	RETURN xfcGdipCombineRegionPath(m.region, m.path, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCombineRegionRect(region, nRect, CombineMd)
*********************************************************************
	DECLARE Long GdipCombineRegionRect IN GDIPLUS.DLL AS xfcGdipCombineRegionRect Long region, String @nRect, Long CombineMd
	RETURN xfcGdipCombineRegionRect(m.region, @m.nRect, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCombineRegionRectI(region, nRect, CombineMd)
*********************************************************************
	DECLARE Long GdipCombineRegionRectI IN GDIPLUS.DLL AS xfcGdipCombineRegionRectI Long region, String @nRect, Long CombineMd
	RETURN xfcGdipCombineRegionRectI(m.region, @m.nRect, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCombineRegionRegion(region, region2, CombineMd)
*********************************************************************
	DECLARE Long GdipCombineRegionRegion IN GDIPLUS.DLL AS xfcGdipCombineRegionRegion Long region, Long region2, Long CombineMd
	RETURN xfcGdipCombineRegionRegion(m.region, m.region2, m.CombineMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateRegion(region)
*********************************************************************
	DECLARE Long GdipCreateRegion IN GDIPLUS.DLL AS xfcGdipCreateRegion Long @region
	RETURN xfcGdipCreateRegion(@m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateRegionHrgn(hRgn, region)
*********************************************************************
	DECLARE Long GdipCreateRegionHrgn IN GDIPLUS.DLL AS xfcGdipCreateRegionHrgn Long hRgn, Long @region
	RETURN xfcGdipCreateRegionHrgn(m.hRgn, @m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateRegionPath(path, region)
*********************************************************************
	DECLARE Long GdipCreateRegionPath IN GDIPLUS.DLL AS xfcGdipCreateRegionPath Long path, Long @region
	RETURN xfcGdipCreateRegionPath(m.path, @m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateRegionRect(nRect, region)
*********************************************************************
	DECLARE Long GdipCreateRegionRect IN GDIPLUS.DLL AS xfcGdipCreateRegionRect String nRect, Long @region
	RETURN xfcGdipCreateRegionRect(m.nRect, @m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateRegionRectI(nRect, region)
*********************************************************************
	DECLARE Long GdipCreateRegionRectI IN GDIPLUS.DLL AS xfcGdipCreateRegionRectI String nRect, Long @region
	RETURN xfcGdipCreateRegionRectI(m.nRect, @m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDeleteRegion(region)
*********************************************************************
	DECLARE Long GdipDeleteRegion IN GDIPLUS.DLL AS xfcGdipDeleteRegion Long region
	RETURN xfcGdipDeleteRegion(m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRegionBounds(region, graphics, nRect)
*********************************************************************
	DECLARE Long GdipGetRegionBounds IN GDIPLUS.DLL AS xfcGdipGetRegionBounds Long region, Long graphics, String @nRect
	RETURN xfcGdipGetRegionBounds(m.region, m.graphics, @m.nRect)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRegionBoundsI(region, graphics, nRect)
*********************************************************************
	DECLARE Long GdipGetRegionBoundsI IN GDIPLUS.DLL AS xfcGdipGetRegionBoundsI Long region, Long graphics, String @nRect
	RETURN xfcGdipGetRegionBoundsI(m.region, m.graphics, @m.nRect)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRegionData(region, buffer, bufferSize, sizeFilled)
*********************************************************************
	DECLARE Long GdipGetRegionData IN GDIPLUS.DLL AS xfcGdipGetRegionData Long region, String @buffer, Long bufferSize, Long @sizeFilled
	RETURN xfcGdipGetRegionData(m.region, @m.buffer, m.bufferSize, @m.sizeFilled)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRegionDataSize(region, bufferSize)
*********************************************************************
	DECLARE Long GdipGetRegionDataSize IN GDIPLUS.DLL AS xfcGdipGetRegionDataSize Long region, Long @bufferSize
	RETURN xfcGdipGetRegionDataSize(m.region, @m.bufferSize)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRegionHRgn(region, graphics, hRgn)
*********************************************************************
	DECLARE Long GdipGetRegionHRgn IN GDIPLUS.DLL AS xfcGdipGetRegionHRgn Long region, Long graphics, Long @hRgn
	RETURN xfcGdipGetRegionHRgn(m.region, m.graphics, @m.hRgn)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRegionScans(region, rects, Count, matrix)
	**  2013/03/12: Christian Ehlscheidt (posted as patch in Codeplex in April 2010)
*********************************************************************
	DECLARE Long GdipGetRegionScans IN GDIPLUS.DLL AS xfcGdipGetRegionScans Long region, String @rects, Long @Count, Long matrix
	RETURN xfcGdipGetRegionScans(m.region, @m.rects, @m.Count, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRegionScansCount(region, Ucount, matrix)
*********************************************************************
	DECLARE Long GdipGetRegionScansCount IN GDIPLUS.DLL AS xfcGdipGetRegionScansCount Long region, Long @Ucount, Long matrix
	RETURN xfcGdipGetRegionScansCount(m.region, @m.Ucount, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetRegionScansI(region, rects, Count, matrix)
*********************************************************************
	DECLARE Long GdipGetRegionScansI IN GDIPLUS.DLL AS xfcGdipGetRegionScansI Long region, String @rects, Long Count, Long matrix
	RETURN xfcGdipGetRegionScansI(m.region, @m.rects, m.Count, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsEmptyRegion(region, graphics, result)
*********************************************************************
	DECLARE Long GdipIsEmptyRegion IN GDIPLUS.DLL AS xfcGdipIsEmptyRegion Long region, Long graphics, Long @result
	RETURN xfcGdipIsEmptyRegion(m.region, m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsEqualRegion(region, region2, graphics, result)
*********************************************************************
	DECLARE Long GdipIsEqualRegion IN GDIPLUS.DLL AS xfcGdipIsEqualRegion Long region, Long region2, Long graphics, Long @result
	RETURN xfcGdipIsEqualRegion(m.region, m.region2, m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsInfiniteRegion(region, graphics, result)
*********************************************************************
	DECLARE Long GdipIsInfiniteRegion IN GDIPLUS.DLL AS xfcGdipIsInfiniteRegion Long region, Long graphics, Long @result
	RETURN xfcGdipIsInfiniteRegion(m.region, m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisibleRegionPoint(region, x, y, graphics, result)
*********************************************************************
	DECLARE Long GdipIsVisibleRegionPoint IN GDIPLUS.DLL AS xfcGdipIsVisibleRegionPoint Long region, Single x, Single y, Long graphics, Long @result
	RETURN xfcGdipIsVisibleRegionPoint(m.region, m.x, m.y, m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisibleRegionPointI(region, x, y, graphics, result)
*********************************************************************
	DECLARE Long GdipIsVisibleRegionPointI IN GDIPLUS.DLL AS xfcGdipIsVisibleRegionPointI Long region, Long x, Long y, Long graphics, Long @result
	RETURN xfcGdipIsVisibleRegionPointI(m.region, m.x, m.y, m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisibleRegionRect(region, x, y, nWidth, Height, graphics, result)
*********************************************************************
	DECLARE Long GdipIsVisibleRegionRect IN GDIPLUS.DLL AS xfcGdipIsVisibleRegionRect Long region, Single x, Single y, Single nWidth, Single Height, Long graphics, Long @result
	RETURN xfcGdipIsVisibleRegionRect(m.region, m.x, m.y, m.nWidth, m.Height, m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipIsVisibleRegionRectI(region, x, y, nWidth, Height, graphics, result)
*********************************************************************
	DECLARE Long GdipIsVisibleRegionRectI IN GDIPLUS.DLL AS xfcGdipIsVisibleRegionRectI Long region, Long x, Long y, Long nWidth, Long Height, Long graphics, Long @result
	RETURN xfcGdipIsVisibleRegionRectI(m.region, m.x, m.y, m.nWidth, m.Height, m.graphics, @m.result)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetEmpty(region)
*********************************************************************
	DECLARE Long GdipSetEmpty IN GDIPLUS.DLL AS xfcGdipSetEmpty Long region
	RETURN xfcGdipSetEmpty(m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetInfinite(region)
*********************************************************************
	DECLARE Long GdipSetInfinite IN GDIPLUS.DLL AS xfcGdipSetInfinite Long region
	RETURN xfcGdipSetInfinite(m.region)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTransformRegion(region, matrix)
*********************************************************************
	DECLARE Long GdipTransformRegion IN GDIPLUS.DLL AS xfcGdipTransformRegion Long region, Long matrix
	RETURN xfcGdipTransformRegion(m.region, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTranslateRegion(region, dx, dy)
*********************************************************************
	DECLARE Long GdipTranslateRegion IN GDIPLUS.DLL AS xfcGdipTranslateRegion Long region, Single dx, Single dy
	RETURN xfcGdipTranslateRegion(m.region, m.dx, m.dy)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTranslateRegionI(region, dx, dy)
*********************************************************************
	DECLARE Long GdipTranslateRegionI IN GDIPLUS.DLL AS xfcGdipTranslateRegionI Long region, Long dx, Long dy
	RETURN xfcGdipTranslateRegionI(m.region, m.dx, m.dy)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCSOLIDBRUSH
*********************************************************************
FUNCTION xfcGdipCreateSolidFill(Argb, brush)
*********************************************************************
	DECLARE Long GdipCreateSolidFill IN GDIPLUS.DLL AS xfcGdipCreateSolidFill Long Argb, Long @brush
	RETURN xfcGdipCreateSolidFill(m.Argb, @m.brush)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetSolidFillColor(brush, Argb)
*********************************************************************
	DECLARE Long GdipGetSolidFillColor IN GDIPLUS.DLL AS xfcGdipGetSolidFillColor Long brush, Long @Argb
	RETURN xfcGdipGetSolidFillColor(m.brush, @m.Argb)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetSolidFillColor(brush, Argb)
*********************************************************************
	DECLARE Long GdipSetSolidFillColor IN GDIPLUS.DLL AS xfcGdipSetSolidFillColor Long brush, Long Argb
	RETURN xfcGdipSetSolidFillColor(m.brush, m.Argb)
ENDFUNC


#ENDIF


** Also used by xfcGraphics
*********************************************************************
FUNCTION xfcGdipCloneStringFormat(StringFormat, newFormat)
*********************************************************************
	DECLARE Long GdipCloneStringFormat IN GDIPLUS.DLL AS xfcGdipCloneStringFormat Long StringFormat, Long @newFormat
	RETURN xfcGdipCloneStringFormat(m.StringFormat, @m.newFormat)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateStringFormat(formatAttributes, language, StringFormat)
*********************************************************************
	DECLARE Long GdipCreateStringFormat IN GDIPLUS.DLL AS xfcGdipCreateStringFormat Integer formatAttributes, Integer language, Long @StringFormat
	RETURN xfcGdipCreateStringFormat(m.formatAttributes, m.language, @m.StringFormat)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipDeleteStringFormat(StringFormat)
*********************************************************************
	DECLARE Long GdipDeleteStringFormat IN GDIPLUS.DLL AS xfcGdipDeleteStringFormat Long StringFormat
	RETURN xfcGdipDeleteStringFormat(m.StringFormat)
ENDFUNC





#IFDEF USECLASS_XFCSTRINGFORMAT
*********************************************************************
FUNCTION xfcGdipGetStringFormatAlign(StringFormat, Align)
*********************************************************************
	DECLARE Long GdipGetStringFormatAlign IN GDIPLUS.DLL AS xfcGdipGetStringFormatAlign Long StringFormat, Long @Align
	RETURN xfcGdipGetStringFormatAlign(m.StringFormat, @m.Align)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetStringFormatDigitSubstitution(StringFormat, language, substitute)
*********************************************************************
	DECLARE Long GdipGetStringFormatDigitSubstitution IN GDIPLUS.DLL AS xfcGdipGetStringFormatDigitSubstitution Long StringFormat, Integer @language, Long @substitute
	RETURN xfcGdipGetStringFormatDigitSubstitution(m.StringFormat, @m.language, @m.substitute)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetStringFormatFlags(StringFormat, flags)
*********************************************************************
	DECLARE Long GdipGetStringFormatFlags IN GDIPLUS.DLL AS xfcGdipGetStringFormatFlags Long StringFormat, Long @flags
	RETURN xfcGdipGetStringFormatFlags(m.StringFormat, @m.flags)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetStringFormatHotkeyPrefix(StringFormat, hkPrefix)
*********************************************************************
	DECLARE Long GdipGetStringFormatHotkeyPrefix IN GDIPLUS.DLL AS xfcGdipGetStringFormatHotkeyPrefix Long StringFormat, Long @hkPrefix
	RETURN xfcGdipGetStringFormatHotkeyPrefix(m.StringFormat, @m.hkPrefix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetStringFormatLineAlign(StringFormat, Align)
*********************************************************************
	DECLARE Long GdipGetStringFormatLineAlign IN GDIPLUS.DLL AS xfcGdipGetStringFormatLineAlign Long StringFormat, Long @Align
	RETURN xfcGdipGetStringFormatLineAlign(m.StringFormat, @m.Align)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetStringFormatTabStopCount(StringFormat, Count)
*********************************************************************
	DECLARE Long GdipGetStringFormatTabStopCount IN GDIPLUS.DLL AS xfcGdipGetStringFormatTabStopCount Long StringFormat, Long @Count
	RETURN xfcGdipGetStringFormatTabStopCount(m.StringFormat, @m.Count)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetStringFormatTabStops(StringFormat, Count, firstTabOffset, tabStops)
*********************************************************************
	DECLARE Long GdipGetStringFormatTabStops IN GDIPLUS.DLL AS xfcGdipGetStringFormatTabStops Long StringFormat, Long Count, Single @firstTabOffset, String @tabStops
	RETURN xfcGdipGetStringFormatTabStops(m.StringFormat, m.Count, @m.firstTabOffset, @m.tabStops)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetStringFormatTrimming(StringFormat, trimming)
*********************************************************************
	DECLARE Long GdipGetStringFormatTrimming IN GDIPLUS.DLL AS xfcGdipGetStringFormatTrimming Long StringFormat, Long @trimming
	RETURN xfcGdipGetStringFormatTrimming(m.StringFormat, @m.trimming)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatAlign(StringFormat, Align)
*********************************************************************
	DECLARE Long GdipSetStringFormatAlign IN GDIPLUS.DLL AS xfcGdipSetStringFormatAlign Long StringFormat, Long Align
	RETURN xfcGdipSetStringFormatAlign(m.StringFormat, m.Align)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatDigitSubstitution(StringFormat, language, substitute)
*********************************************************************
	DECLARE Long GdipSetStringFormatDigitSubstitution IN GDIPLUS.DLL AS xfcGdipSetStringFormatDigitSubstitution Long StringFormat, Integer language, Long substitute
	RETURN xfcGdipSetStringFormatDigitSubstitution(m.StringFormat, m.language, m.substitute)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatFlags(StringFormat, flags)
*********************************************************************
	DECLARE Long GdipSetStringFormatFlags IN GDIPLUS.DLL AS xfcGdipSetStringFormatFlags Long StringFormat, Long flags
	RETURN xfcGdipSetStringFormatFlags(m.StringFormat, m.flags)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatHotkeyPrefix(StringFormat, hkPrefix)
*********************************************************************
	DECLARE Long GdipSetStringFormatHotkeyPrefix IN GDIPLUS.DLL AS xfcGdipSetStringFormatHotkeyPrefix Long StringFormat, Long hkPrefix
	RETURN xfcGdipSetStringFormatHotkeyPrefix(m.StringFormat, m.hkPrefix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatLineAlign(StringFormat, Align)
*********************************************************************
	DECLARE Long GdipSetStringFormatLineAlign IN GDIPLUS.DLL AS xfcGdipSetStringFormatLineAlign Long StringFormat, Long Align
	RETURN xfcGdipSetStringFormatLineAlign(m.StringFormat, m.Align)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatMeasurableCharacterRanges(StringFormat, rangeCount, ranges)
*********************************************************************
	DECLARE Long GdipSetStringFormatMeasurableCharacterRanges IN GDIPLUS.DLL AS xfcGdipSetStringFormatMeasurableCharacterRanges Long StringFormat, Long rangeCount, String ranges
	RETURN xfcGdipSetStringFormatMeasurableCharacterRanges(m.StringFormat, m.rangeCount, m.ranges)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatTabStops(StringFormat, firstTabOffset, Count, tabStops)
*********************************************************************
	DECLARE Long GdipSetStringFormatTabStops IN GDIPLUS.DLL AS xfcGdipSetStringFormatTabStops Long StringFormat, Single firstTabOffset, Long Count, String tabStops
	RETURN xfcGdipSetStringFormatTabStops(m.StringFormat, m.firstTabOffset, m.Count, m.tabStops)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetStringFormatTrimming(StringFormat, trimming)
*********************************************************************
	DECLARE Long GdipSetStringFormatTrimming IN GDIPLUS.DLL AS xfcGdipSetStringFormatTrimming Long StringFormat, Long trimming
	RETURN xfcGdipSetStringFormatTrimming(m.StringFormat, m.trimming)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipStringFormatGetGenericDefault(StringFormat)
*********************************************************************
	DECLARE Long GdipStringFormatGetGenericDefault IN GDIPLUS.DLL AS xfcGdipStringFormatGetGenericDefault Long @StringFormat
	RETURN xfcGdipStringFormatGetGenericDefault(@m.StringFormat)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipStringFormatGetGenericTypographic(StringFormat)
*********************************************************************
	DECLARE Long GdipStringFormatGetGenericTypographic IN GDIPLUS.DLL AS xfcGdipStringFormatGetGenericTypographic Long @StringFormat
	RETURN xfcGdipStringFormatGetGenericTypographic(@m.StringFormat)
ENDFUNC


#ENDIF

#IFDEF USECLASS_XFCTEXTUREBRUSH
*********************************************************************
FUNCTION xfcGdipCreateTexture(nImage, WrapMd, texture)
*********************************************************************
	DECLARE Long GdipCreateTexture IN GDIPLUS.DLL AS xfcGdipCreateTexture Long nImage, Long WrapMd, Long @texture
	RETURN xfcGdipCreateTexture(m.nImage, m.WrapMd, @m.texture)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateTexture2(nImage, WrapMd, x, y, nWidth, Height, texture)
*********************************************************************
	DECLARE Long GdipCreateTexture2 IN GDIPLUS.DLL AS xfcGdipCreateTexture2 Long nImage, Long WrapMd, Single x, Single y, Single nWidth, Single Height, Long @texture
	RETURN xfcGdipCreateTexture2(m.nImage, m.WrapMd, m.x, m.y, m.nWidth, m.Height, @m.texture)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateTexture2I(nImage, WrapMd, x, y, nWidth, Height, texture)
*********************************************************************
	DECLARE Long GdipCreateTexture2I IN GDIPLUS.DLL AS xfcGdipCreateTexture2I Long nImage, Long WrapMd, Long x, Long y, Long nWidth, Long Height, Long @texture
	RETURN xfcGdipCreateTexture2I(m.nImage, m.WrapMd, m.x, m.y, m.nWidth, m.Height, @m.texture)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateTextureIA(nImage, imageAttributes, x, y, nWidth, Height, texture)
*********************************************************************
	DECLARE Long GdipCreateTextureIA IN GDIPLUS.DLL AS xfcGdipCreateTextureIA Long nImage, Long imageAttributes, Single x, Single y, Single nWidth, Single Height, Long @texture
	RETURN xfcGdipCreateTextureIA(m.nImage, m.imageAttributes, m.x, m.y, m.nWidth, m.Height, @m.texture)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipCreateTextureIAI(nImage, imageAttributes, x, y, nWidth, Height, texture)
*********************************************************************
	DECLARE Long GdipCreateTextureIAI IN GDIPLUS.DLL AS xfcGdipCreateTextureIAI Long nImage, Long imageAttributes, Long x, Long y, Long nWidth, Long Height, Long @texture
	RETURN xfcGdipCreateTextureIAI(m.nImage, m.imageAttributes, m.x, m.y, m.nWidth, m.Height, @m.texture)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetTextureImage(brush, nImage)
*********************************************************************
	DECLARE Long GdipGetTextureImage IN GDIPLUS.DLL AS xfcGdipGetTextureImage Long brush, Long @nImage
	RETURN xfcGdipGetTextureImage(m.brush, @m.nImage)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetTextureTransform(brush, matrix)
*********************************************************************
	DECLARE Long GdipGetTextureTransform IN GDIPLUS.DLL AS xfcGdipGetTextureTransform Long brush, Long matrix
	RETURN xfcGdipGetTextureTransform(m.brush, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipGetTextureWrapMode(brush, WrapMd)
*********************************************************************
	DECLARE Long GdipGetTextureWrapMode IN GDIPLUS.DLL AS xfcGdipGetTextureWrapMode Long brush, Long @WrapMd
	RETURN xfcGdipGetTextureWrapMode(m.brush, @m.WrapMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipMultiplyTextureTransform(brush, matrix, order)
*********************************************************************
	DECLARE Long GdipMultiplyTextureTransform IN GDIPLUS.DLL AS xfcGdipMultiplyTextureTransform Long brush, Long matrix, Long order
	RETURN xfcGdipMultiplyTextureTransform(m.brush, m.matrix, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipResetTextureTransform(brush)
*********************************************************************
	DECLARE Long GdipResetTextureTransform IN GDIPLUS.DLL AS xfcGdipResetTextureTransform Long brush
	RETURN xfcGdipResetTextureTransform(m.brush)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipRotateTextureTransform(brush, Angle, order)
*********************************************************************
	DECLARE Long GdipRotateTextureTransform IN GDIPLUS.DLL AS xfcGdipRotateTextureTransform Long brush, Single Angle, Long order
	RETURN xfcGdipRotateTextureTransform(m.brush, m.Angle, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipScaleTextureTransform(brush, sx, sy, order)
*********************************************************************
	DECLARE Long GdipScaleTextureTransform IN GDIPLUS.DLL AS xfcGdipScaleTextureTransform Long brush, Single sx, Single sy, Long order
	RETURN xfcGdipScaleTextureTransform(m.brush, m.sx, m.sy, m.order)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetTextureTransform(brush, matrix)
*********************************************************************
	DECLARE Long GdipSetTextureTransform IN GDIPLUS.DLL AS xfcGdipSetTextureTransform Long brush, Long matrix
	RETURN xfcGdipSetTextureTransform(m.brush, m.matrix)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipSetTextureWrapMode(brush, WrapMd)
*********************************************************************
	DECLARE Long GdipSetTextureWrapMode IN GDIPLUS.DLL AS xfcGdipSetTextureWrapMode Long brush, Long WrapMd
	RETURN xfcGdipSetTextureWrapMode(m.brush, m.WrapMd)
ENDFUNC

*********************************************************************
FUNCTION xfcGdipTranslateTextureTransform(brush, dx, dy, order)
*********************************************************************
	DECLARE Long GdipTranslateTextureTransform IN GDIPLUS.DLL AS xfcGdipTranslateTextureTransform Long brush, Single dx, Single dy, Long order
	RETURN xfcGdipTranslateTextureTransform(m.brush, m.dx, m.dy, m.order)
ENDFUNC


#ENDIF




*********************************************************************
FUNCTION ZeroMemory(dest,numBytes)
*********************************************************************
	DECLARE Long RtlZeroMemory IN WIN32API AS ZeroMemory Integer dest, Integer numBytes
	RETURN ZeroMemory(m.dest,m.numBytes)
ENDFUNC
		
*********************************************************************
FUNCTION xfcGetDIBits(hdc, hbmp, uStartScan, cScanLines, lpvBits, lpbi, uUsage)
*********************************************************************
	DECLARE Long GetDIBits IN WIN32API AS xfcGetDIBits Integer hdc, Integer hbmp, Integer uStartScan, Integer cScanLines, Integer lpvBits, String @lpbi, Integer uUsage
	RETURN xfcGetDIBits(m.hdc, m.hbmp, m.uStartScan, m.cScanLines, m.lpvBits, @m.lpbi, m.uUsage)
ENDFUNC


*********************************************************************
FUNCTION xfcReleaseDC(hWnd, hDC)
*********************************************************************
	DECLARE Long ReleaseDC IN WIN32API AS xfcReleaseDC Long hWnd, Long hDC
	RETURN xfcReleaseDC(m.hWnd, m.hDC)
ENDFUNC


*********************************************************************
FUNCTION xfcDeleteObject(hObject)
*********************************************************************
	DECLARE Integer DeleteObject IN WIN32API AS xfcDeleteObject Integer hObject
	RETURN xfcDeleteObject(m.hObject)
ENDFUNC

*********************************************************************
FUNCTION xfcGetDC(hWnd)
*********************************************************************
	DECLARE Integer GetDC IN WIN32API AS xfcGetDC Integer hWnd
	RETURN xfcGetDC(m.hWnd)
ENDFUNC

*********************************************************************
FUNCTION xfcCreateCompatibleDC(hDC)
*********************************************************************
	DECLARE Integer CreateCompatibleDC IN WIN32API AS xfcCreateCompatibleDC Integer hDC
	RETURN xfcCreateCompatibleDC(m.hDC)
ENDFUNC

*********************************************************************
FUNCTION xfcDeleteDC(hdc)
*********************************************************************
	DECLARE Long DeleteDC IN WIN32API AS xfcDeleteDC Long hdc
	RETURN xfcDeleteDC(m.hdc)
ENDFUNC

*********************************************************************
FUNCTION xfcGetWindowDC(hwnd)
*********************************************************************
	DECLARE Long GetWindowDC IN WIN32API AS xfcGetWindowDC Long hwnd
	RETURN xfcGetWindowDC(m.hwnd)
ENDFUNC

*********************************************************************
FUNCTION xfcGetDesktopWindow()
*********************************************************************
	DECLARE Long GetDesktopWindow IN WIN32API AS xfcGetDesktopWindow
	RETURN xfcGetDesktopWindow()
ENDFUNC

*********************************************************************
FUNCTION xfcMoveWindow(hwnd, x, y, nWidth, nHeight, bRepaint)
*********************************************************************
	DECLARE Long MoveWindow IN WIN32API AS xfcMoveWindow INTEGER hWnd, INTEGER X, INTEGER Y, INTEGER nWidth, INTEGER nHeight, INTEGER bRepaint
	RETURN xfcMoveWindow(m.hwnd, m.x, m.y, m.nWidth, m.nHeight, m.bRepaint)
ENDFUNC

*********************************************************************
FUNCTION xfcOpenClipboard(hwnd)
*********************************************************************
	DECLARE Long OpenClipboard IN WIN32API AS xfcOpenClipboard Long hWnd
	RETURN xfcOpenClipboard(m.hwnd)
ENDFUNC

*********************************************************************
FUNCTION xfcCloseClipboard()
*********************************************************************
	DECLARE Long CloseClipboard IN WIN32API AS xfcCloseClipboard
	RETURN xfcCloseClipboard()
ENDFUNC

*********************************************************************
FUNCTION xfcGetClipboardData(uFormat)
*********************************************************************
	DECLARE Long GetClipboardData IN WIN32API AS xfcGetClipboardData Long uFormat
	RETURN xfcGetClipboardData(m.uFormat)
ENDFUNC

*********************************************************************
FUNCTION xfcEmptyClipboard()
*********************************************************************
	DECLARE Long EmptyClipboard IN WIN32API AS xfcEmptyClipboard
	RETURN xfcEmptyClipboard()
ENDFUNC

*********************************************************************
FUNCTION xfcSetClipboardData(uFormat, HMEM)
*********************************************************************
	DECLARE Long SetClipboardData IN WIN32API AS xfcSetClipboardData LONG uFormat, LONG HMEM
	RETURN xfcSetClipboardData(m.uFormat, m.HMEM)
ENDFUNC

*********************************************************************
FUNCTION xfcCopyImage(hImage, uType, cx, cy, uFlags)
*********************************************************************
	DECLARE Long CopyImage IN WIN32API AS xfcCopyImage LONG hImage, LONG uType, LONG cx, LONG cy, LONG uFlags
	RETURN xfcCopyImage(m.hImage, m.uType, m.cx, m.cy, m.uFlags)
ENDFUNC

*********************************************************************
FUNCTION xfcCreateDC(cDriver, cDevice, cOUtput, cInitData)
*********************************************************************
	DECLARE Long CreateDC IN WIN32API AS xfcCreateDC STRING cDriver, STRING cDevice, STRING cOutput, STRING @cInitData
	RETURN xfcCreateDC(m.cDriver, m.cDevice, m.cOUtput, @m.cInitData)
ENDFUNC

*********************************************************************
FUNCTION xfcGetSysColor(nIndex)
*********************************************************************
	DECLARE Long GetSysColor IN WIN32API AS xfcGetSysColor Long nIndex
	RETURN xfcGetSysColor(m.nIndex)
ENDFUNC

*********************************************************************
FUNCTION xfcLoadIcon(hInstance, lpIconName)
*********************************************************************
	DECLARE Long LoadIcon IN WIN32API AS xfcLoadIcon INTEGER hInstance, INTEGER lpIconName
	RETURN xfcLoadIcon(m.hInstance, m.lpIconName)
ENDFUNC

* 2013/03/11 - CChalom - Xfc functions used for the 'FloodFill' method
*********************************************************************
FUNCTION xfcGdiFlush
*********************************************************************
	DECLARE INTEGER GdiFlush IN gdi32 AS xfcGdiFlush
	RETURN xfcGdiFlush()
ENDFUNC

*********************************************************************
FUNCTION xfcCreateSolidBrush(crColor)
*********************************************************************
	DECLARE INTEGER CreateSolidBrush IN WIN32API AS xfcCreateSolidBrush LONG crColor
	RETURN xfcCreateSolidBrush(m.crColor)
ENDFUNC

*********************************************************************
FUNCTION xfcGetPixel(hdc, nXPos, nYPos)
*********************************************************************
	DECLARE INTEGER GetPixel         IN win32API AS xfcGetPixel integer hdc, Integer nXPos, Integer nYPos
	RETURN xfcGetPixel(m.hdc, m.nXPos, m.nYPos)
ENDFUNC

*********************************************************************
FUNCTION xfcExtFloodFill(hdc, x, y, crColor, wFillType)
*********************************************************************
	DECLARE LONG    ExtFloodFill     IN gdi32    AS xfcExtFloodFill LONG hdc, LONG x, LONG y, LONG crColor, LONG wFillType
	RETURN xfcExtFloodFill(hdc, x, y, crColor, wFillType)
ENDFUNC

*********************************************************************
FUNCTION xfcCreateDIBSection(hdc, pbmi, iUsage, ppvBits, hSection, dwOffset)
*********************************************************************
	DECLARE INTEGER CreateDIBSection IN gdi32 AS xfcCreateDIBSection INTEGER hdc, STRING @pbmi, LONG iUsage, INTEGER @ppvBits, INTEGER hSection, LONG dwOffset
	RETURN xfcCreateDIBSection(m.hdc, @pbmi, m.iUsage, @ppvBits, m.hSection, m.dwOffset)
ENDFUNC

