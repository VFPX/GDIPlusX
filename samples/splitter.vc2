*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.20" SourceFile="splitter.vcx" CPID="1250" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS splitter AS shape 		&& Left-Right Splitter class. Support ActiveX controls. Author: gerald.santerre@siteintranet.qc.ca
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: aftermousedown
		*m: beforemousedown
		*m: declaredll
		*m: hidecontrols		&& internal use
		*m: readme
		*m: showcontrols		&& internal use
		*m: split		&& This method is called at the end of a split operation
		*p: rangemax		&& The splitter can be dragged to the right side up to this value. Pixels from the left side of the parent. Value < 1 is percent of parent width.
		*p: rangemin		&& The splitter can be dragged to the left side down to this value. Pixels from the left side of the parent. Value < 1 is percent of parent width.
		*a: hiddencontrols[1,1]		&& Array of controls
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN hiddencontrols
	PROTECTED Init,MouseDown
	*<PropValue>
		Height = 203
		MousePointer = 9
		Name = "splitter"
		rangemax = 0.8
		rangemin = 0.2
		SpecialEffect = 0
		Width = 4
		_memberdata = <VFPData>
			<memberdata name="declaredll" type="method" display="DeclareDll"/>
			<memberdata name="beforemousedown" type="method" display="BeforeMouseDown"/>
			<memberdata name="aftermousedown" type="method" display="AfterMouseDown"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE aftermousedown
	ENDPROC

	PROCEDURE beforemousedown
	ENDPROC

	PROCEDURE declaredll
		
		IF !VARTYPE(_SCREEN.___SplitterApi) = "O"
		  
		  _SCREEN.NEWOBJECT("___SplitterApi", "SplitterAPI", THIS.CLASSLIBRARY)
		  
		ELSE 
		
		  _SCREEN.___SplitterApi.DeclareDll()
		
		ENDIF
		
		RETURN VARTYPE(_SCREEN.___SplitterApi) == "O" AND !ISNULL(_SCREEN.___SplitterApi)
	ENDPROC

	PROCEDURE Destroy
		
		* decrement instance counter, if 0 release object (this.release Dlls)
		*-------------------------------------------------------------------------
		IF TYPE("_screen.___SplitterApi")="O" AND !ISNULL(_SCREEN.___SplitterApi)
		
		  _SCREEN.___SplitterApi.nInstances = _SCREEN.___SplitterApi.nInstances - 1
		
		  IF _SCREEN.___SplitterApi.nInstances <= 0
		
		    _SCREEN.___SplitterApi.nInstances = NULL
		
		    _SCREEN.REMOVEOBJECT("___SplitterApi")
		
		  ENDIF
		  
		ENDIF
		
		
		
	ENDPROC

	HIDDEN PROCEDURE hidecontrols		&& internal use
		
		* hide all controls include ActiveX with property visible inside container tObject
		* without this splitter and form
		*-----------------------------------------------------------------------------------
		LPARAMETERS tObject,nIndex
		
		*	tObject is root object, if not passed, thisform is used
		*-----------------------------------------------------------
		IF EMPTY(nIndex)
		
		  nIndex = 2
		
		ENDIF
		
		LOCAL lcObjectBaseClass, lObject, lTempObject
		
		* build collection hidden object for reverse setting in showcontrols
		* set valid object
		*----------------------------------------------------------------------------
		IF VARTYPE(tObject) = "O"
		
		  lObject = tObject
		
		ELSE
		
		  lObject = THISFORM
		
		ENDIF
		
		* ignore this splitter
		*------------------------
		IF lObject = THIS
		
		  RETURN nIndex
		
		ENDIF
		
		* unify
		*--------------------
		lcObjectBaseClass = LOWER(lObject.BASECLASS) + " " && " " for unique (page # pageframe)
		
		* do not hide form window
		*--------------------------------
		IF lcObjectBaseClass # "form " AND PEMSTATUS(lObject, "visible", 5)
		
		  IF lObject.VISIBLE
		
		    DIMENSION THIS.HiddenControls[nIndex]
		
		    THIS.hiddencontrols[nIndex] = lObject
		
		    lObject.VISIBLE = .F.
		
		    nIndex = nIndex + 1
		
		  ENDIF
		
		ENDIF
		
		* recurse for all children
		*------------------------------
		DO CASE
		
		  CASE INLIST(lcObjectBaseClass,"pageframe ")
		
		    FOR EACH lTempObject IN lObject.PAGES
		
		      nIndex=THIS.hidecontrols(lTempObject, nIndex)
		
		    ENDFOR
		
		  CASE INLIST(lcObjectBaseClass,"form ","container ","page ")
		
		    FOR EACH lTempObject IN lObject.CONTROLS
		
		      nIndex=THIS.hidecontrols(lTempObject, nIndex)
		
		    ENDFOR
		
		  CASE INLIST(lcObjectBaseClass,"commandgroup ","optiongroup ")
		
		    FOR EACH lTempObject IN lObject.BUTTONS
		
		      nIndex=THIS.hidecontrols(lTempObject, nIndex)
		
		    ENDFOR
		
		ENDCASE
		
		RETURN nIndex+1
		
	ENDPROC

	PROTECTED PROCEDURE Init
		
		* API FUNCTIONS - declare only one for all splitter with this class
		*--------------------------------------------------------------------
		IF !VARTYPE(_SCREEN.___SplitterApi) = "O"
		
		  *!*	  IF AT(UPPER((THIS.CLASSLIBRARY)),UPPER(SET("Classlib")))=0
		
		  *!*	    SET CLASSLIB TO (THIS.CLASSLIBRARY) ADDITIVE
		
		  *!*	  ENDIF
		
		  *!*	  _SCREEN.ADDOBJECT("___SplitterApi","SplitterAPI")
		  
		  _SCREEN.NEWOBJECT("___SplitterApi", "SplitterAPI", THIS.CLASSLIBRARY)
		
		ELSE
		
		  _SCREEN.___SplitterApi.nInstances = _SCREEN.___SplitterApi.nInstances + 1
		
		ENDIF
		
		RETURN VARTYPE(_SCREEN.___SplitterApi) == "O" AND !ISNULL(_SCREEN.___SplitterApi)
		
	ENDPROC

	PROTECTED PROCEDURE MouseDown
		
		#DEFINE SRCCOPY		13369376
		
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		THIS.BeforeMouseDown()
		
		THIS.DeclareDll()
		
		LOCAL lcWindowName,lnScaleMode,lnMinCol,lnMaxCol,lnMCol1,lnMCol2
		LOCAL lnColumns,lnLeft,lnOldLeft,lnMin,oldMCol2
		LOCAL llLockScreen,lnMousePointer
		LOCAL lhDC,lhMemDC,lhMemBmp,lHWnd,lnBmpWidth,nLeftOffset,nTopOffset,oContainer,xWidth
		LOCAL lcOldFormName,lhMemSplit
		
		IF nButton # 1
		
			RETURN
			
		ENDIF
		
		lcOldFormName = THISFORM.NAME
		
		THISFORM.NAME = SYS(2015)
		
		lcWindowName = THISFORM.NAME
		
		lnScaleMode = THISFORM.SCALEMODE
		
		THISFORM.SCALEMODE = 3  && pixels
		
		oContainer = THIS.PARENT
		
		nLeftOffset = OBJTOCLIENT(THIS, 2) - THIS.LEFT
		
		nTopOffset = OBJTOCLIENT(THIS, 1) - THIS.TOP
		
		lnMCol1 = MCOL(lcWindowName, 3)
		
		IF TYPE("lnMCol1") # "N" OR lnMCol1 <= 0
		
			THISFORM.SCALEMODE = lnScaleMode
			
			THISFORM.NAME = lcOldFormName
			
			RETURN
			
		ENDIF
		
		lnMCol1 = lnMCol1 - nLeftOffset
		
		IF lnMCol1 <> THIS.LEFT + 1
		
			lnMCol1 = THIS.LEFT + 1
			
			MOUSE AT MROW(lcWindowName, 3), lnMCol1 + nLeftOffset PIXELS WINDOW (lcWindowName)
			
		ENDIF
		
		* set some vars
		*-------------------
		llLockScreen			=	THISFORM.LOCKSCREEN
		
		lnMousePointer			=	THISFORM.MOUSEPOINTER
		
		THISFORM.MOUSEPOINTER	=	9
		
		lnLeft					=	THIS.LEFT
		
		* check two parent level for width - suppose that parent form always present
		*----------------------------------------------------------------------------
		IF PEMSTATUS(oContainer, "Width", 5)
		
			xWidth	=	oContainer.WIDTH
			
		ELSE
		
			IF PEMSTATUS(oContainer.PARENT,"PageWidth",5)
			
				xWidth	=	oContainer.PARENT.PAGEWIDTH
				
			ELSE
			
				* if error that oContainer.width and oContainer.parent.width not exist, something wrong
				*----------------------------------------------------------------------------------------
				xWidth	=	oContainer.PARENT.WIDTH
				
			ENDIF
			
		ENDIF
		
		* RangeMin (RangeMax) < 1
		* 		RangeMin (RangeMax) are used as coeficient (%/100)
		* RangeMin (RangeMax) > 1
		*		RangeMin (RangeMax) are used as absolute offset in pixels
		* RangeMin (RangeMax) =0
		*		RangeMin (RangeMax) are ignored - let 2 times this.width
		
		DO CASE
		
			CASE THIS.RangeMin <= 0
			
				lnMinCol = THIS.WIDTH*2
				
			CASE THIS.RangeMin > 1
			
				lnMinCol = MAX(THIS.WIDTH*2, INT(THIS.RangeMin))
				
			CASE THIS.RangeMin < 1
			
				lnMinCol = MAX(THIS.WIDTH * 2, INT(THIS.RangeMin * xWidth))
				
		ENDCASE
		
		DO CASE
		
			CASE THIS.RangeMax <= 0
			
				lnMaxCol = xWidth - (THIS.WIDTH * 3)
				
			CASE THIS.RangeMax > 1
			
				lnMaxCol = MIN(xWidth - (THIS.WIDTH*3), THIS.RangeMax)
				
			CASE THIS.RangeMax < 1
			
				lnMaxCol = MIN(xWidth - (THIS.WIDTH*3), THIS.RangeMax * xWidth)
				
		ENDCASE
		
		IF lnMinCol > lnMaxCol
		
			* nothing to move!!!
			*------------------------------
			THISFORM.SCALEMODE = lnScaleMode
			
			THISFORM.NAME = lcOldFormName
			
			RETURN
			
		ENDIF
		
		lnMCol2 = lnMCol1
		
		oldMCol2 = lnMCol2
		
		* API CALLS
		*-----------------------------
		IF THISFORM.SHOWWINDOW = 2
		
			* workaround, when showwindow=2 the handle is not the right one...
			* worst if you have a toolbar!
			*--------------------------------------------------------------------
			*#define GW_HWNDFIRST        0
			#define GW_HWNDLAST         1
			*#define GW_HWNDNEXT         2
			*#define GW_HWNDPREV         3
			*#define GW_OWNER            4
			#define GW_CHILD            5
		
			lHWnd=THISFORM.HWND
			
			lHWnd = GS_SplitGetWindow(lHWnd, GW_CHILD)
			
			lHWnd = GS_SplitGetWindow(lHWnd, GW_HWNDLAST)
			
		ELSE
			lHWnd = THISFORM.HWND
			
		ENDIF
		
		lhDC = GS_SplitGetDC(lHWnd)
		
		lhMemDC = GS_SplitCreateCompatibleDC(lhDC)
		
		* Take a copy of the portion of the form that can be dragged over
		*-------------------------------------------------------------------
		lnBmpWidth = THIS.WIDTH + 1
		
		lhMemBmp = GS_SplitCreateCompatibleBitmap(lhDC, lnBmpWidth, THIS.HEIGHT)
		
		lhMemSplit = GS_SplitCreateCompatibleBitmap(lhDC, lnBmpWidth, THIS.HEIGHT)
		
		DECLARE LONG SelectObject IN Win32API AS GS_SplitSelectObject  LONG hdc, LONG hObject
		
		= GS_SplitSelectObject(lhMemDC , lhMemBmp)
		
		= GS_SplitBitBlt(lhMemDC, 0, 0, lnBmpWidth, THIS.HEIGHT, ;
			lhDC, lnMCol1 + nLeftOffset - 2, THIS.TOP + nTopOffset, SRCCOPY)
			
		= GS_SplitSelectObject(lhMemDC , lhMemSplit)
		
		= GS_SplitBitBlt(lhMemDC, 0, 0, lnBmpWidth, THIS.HEIGHT, ;
			lhDC, lnMCol1 + nLeftOffset - 1, THIS.TOP + nTopOffset, SRCCOPY)
			
		
		* Stop fox drawing in the screen
		*--------------------------------
		THISFORM.LOCKSCREEN = .T.
		
		THIS.hidecontrols(oContainer)
		
		* update the display while dragging
		*-----------------------------------
		DO WHILE MDOWN()
		
			DOEVENTS
			
			lnMCol2 = MCOL(lcWindowName, 3) - nLeftOffset
			
			IF TYPE("lnMCol2") # "N" OR lnMCol2 = 0
			
				LOOP
				
			ENDIF
			
			IF lnMCol2<=lnMinCol
			
				*force the mouse to stay at this position
				*--------------------------------------------------------------------------------
				MOUSE AT MROW(lcWindowName, 3), lnMinCol+nLeftOffset PIXELS WINDOW (lcWindowName)
				
				lnMCol2 = lnMinCol + 1
				
			ENDIF
			
			IF lnMCol2 >= (lnMaxCol - THIS.WIDTH)
			
				*force the mouse to stay at this position
				*----------------------------------------------
				MOUSE AT MROW(lcWindowName,3), lnMaxCol - THIS.WIDTH+nLeftOffset + 1 PIXELS WINDOW (lcWindowName)
				
				lnMCol2 = lnMaxCol - THIS.WIDTH
				
			ENDIF
			
			lnMCol2 = MIN(MAX(lnMCol2, lnMinCol), lnMaxCol)
			
			IF oldMCol2 = lnMCol2
			
				LOOP
				
			ELSE
			
				* on mouse move, redraw a part of the screen from the memory copy
				* and draw "this" image at the mouse position
				* bitblt (dest...source...)
				*------------------------------------------------------------------
				WITH THIS
				
					.LEFT=lnLeft+(lnMCol2 - lnMCol1)
					
					*restore
					*-------------------------------------------
					= GS_SplitSelectObject(lhMemDC , lhMemBmp)
					
					= GS_SplitBitBlt(lhDC, oldMCol2+nLeftOffset - 2, .TOP+nTopOffset, lnBmpWidth, .HEIGHT,;
						lhMemDC, 0, 0,  SRCCOPY)
						
					*take a new copy
					*-------------------------------------------------------------
					= GS_SplitBitBlt(lhMemDC, 0, 0, lnBmpWidth, THIS.HEIGHT, ;
						lhDC, lnMCol2 + nLeftOffset - 2, THIS.TOP + nTopOffset, SRCCOPY)
						
					*draw the bar
					*--------------------------------------------
					= GS_SplitSelectObject(lhMemDC , lhMemSplit)
					
					= GS_SplitBitBlt(lhDC, .LEFT + nLeftOffset-1, .TOP + nTopOffset, lnBmpWidth, .HEIGHT,;
						lhMemDC, 0, 0,  SRCCOPY)
						
				ENDWITH
				
				oldMCol2 = lnMCol2
				
			ENDIF
			
		ENDDO
		
		THIS.showcontrols()
		
		THISFORM.NAME = lcOldFormName
		
		IF lnMCol2<0
		
			lnMCol2=lnMCol1
			
		ENDIF
		
		lnColumns=lnMCol2-lnMCol1
		
		THIS.LEFT=lnLeft + lnColumns
		
		THISFORM.SCALEMODE=lnScaleMode
		
		THISFORM.MOUSEPOINTER=lnMousePointer
		
		This.Split()
		
		THISFORM.LOCKSCREEN=llLockScreen
		
		IF !THIS.DeclareDll()
		
		  RETURN
		
		ENDIF 
		
		* free the memory
		*--------------------------------
		= GS_SplitReleaseDC(lHWnd, lhDC)
		= GS_SplitDeleteObject(lhMemBmp)
		= GS_SplitDeleteObject(lhMemSplit)
		= GS_SplitDeleteDC(lhMemDC)
		
		THIS.AfterMouseDown()
		
	ENDPROC

	HIDDEN PROCEDURE readme
		*!*	Splitter class
		*!*	May 2004
		
		*!*	Active-X controls always drive me nuts because they use there own windows handle.
		*!*	You cannot put a fox native control over them to resize the control visually.
		*!*	You have to use some tricks like changing the control to 
		*!*	another one for this operation and rechange it back after.
		*!*	( See the class browser code )
		
		*!*	What I want is a splitter that can handle this in a visual way 
		*!*	while keeping the form (look) unchanged until the end of the split.
		
		*!*	After many try and fail, I have finally found a way to do it
		*!*	by the use of API calls. IT WORK!!!
		*!* Days of work to end with only a couple of code lines :)
		
		*!*	I am not an API guru, so if you find a way to improve this class
		*!*	feel free to let me know how :)
		
		*!*	Tested with VFP 8-7 on Windows 2000 
		*!*	(no animal other than the usual fox was used in the tests)
		*!*	Disclaimer: (...) <- put the usual disclaimer here!
		
		*!*	Gérald Santerre
		*!*	gerald.santerre@siteintranet.qc.ca
		
		
		*!*		USAGE:
		
		*!*		Drop this class on a form or in a container between
		*!*		objects that share the same container (form,page or container).
		
		*!*	New release, complete redesing.
		*!*	If you already use a previous version of the class, read this carefully. 
		*!*	I have removed a couple of properties and change the way the classes work. 
		*!*	For this reason I have also renamed the classlib to avoid conflicts 
		*!*	with previous version of the class. The new design is cleaner and the control 
		*!*	don't touch anything in the form (except hiding controls during split). 
		
		*!*	A large part of the new design is from suggestions received 
		*!*	from "Jaromír Stacha" from Czech Republic. 
		*!*		Thank you Jaromir :). 
		
		*!*	The new splitter classes don't move or resize controls anymore. 
		*!*	The splitter.split() method is always called after a split operation 
		*!*	and you have to resize/reposition your controls from this (fake)event. 
		*!*	If you don't put code in the split() method, the form.resize() event 
		*!*	of the form will be called. See the resize() and splitter1.split() 
		*!*	method of the demo form for a working sample.
		
		*!*	You have only 2 properties to set in the class, 
		*!*	RangeMin and RangeMax. 
		*!*	If you set the value of this properties between 0 and 1, 
		*!*	the value is handled as a % of the splitter's parent container width ot height. 
		*!*	For example, if you enter 0.2 as value for RangeMin, 
		*!*	you will be able to move the splitter down to 20% of the width/height 
		*!*	of the splitter's parent container. 
		*!*	Values greater than 1 will be handle as absolute values. 
		*!*	Don't forget to reset absolute values when the splitter's parent container is resized.
		
		*!*	The splitter API is now self contained and you dont have 
		*!*	to worry about releasing the references to API functions. 
		*!*	The splitter now also handle correctly multiple instances 
		*!*	of the same form (or forms with the same name). 
		*!*	The splitter automatically hide every controls that are in 
		*!*	the same parent container (recursive) to avoid side effects 
		*!*	(like mouse cursor beam over text boxes).
		
		*!*	Contact: gerald.santerre@siteintranet.qc.ca
		
		
		
		
		
		
		
	ENDPROC

	HIDDEN PROCEDURE showcontrols		&& internal use
		
		* show temporary hidden objects and clear list (collection)
		*--------------------------------------------------------------
		LPARAMETERS toRoot
		
		IF ALEN(THIS.hiddencontrols,1) < 2
		
		  RETURN
		
		ENDIF
		
		FOR i = 2 TO ALEN(THIS.hiddencontrols, 1)
		
		  IF TYPE("THIS.hiddencontrols[i]")="O"
		
		    THIS.hiddencontrols[i].VISIBLE = .T.
		
		  ENDIF
		
		ENDFOR
		
		DIMENSION THIS.hiddencontrols[1]
		
	ENDPROC

	PROCEDURE split		&& This method is called at the end of a split operation
		
		*default behaviour
		*----------------------
		THISFORM.RESIZE()
	ENDPROC

ENDDEFINE

DEFINE CLASS splitter2 AS shape 		&& Up-Down Splitter class. Support ActiveX controls. Author: gerald.santerre@siteintranet.qc.ca
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: hidecontrols		&& internal use
		*m: readme
		*m: showcontrols		&& internal use
		*m: split		&& This method is called at the end of the split operation.
		*p: rangemax		&& The splitter can be dragged to the bottom up to this value. Pixels from the top of the parent. Value < 1 is percent of parent height.
		*p: rangemin		&& The splitter can be dragged to the top down to this value. Value < 1 is percent of parent height.
		*a: hiddencontrols[1,1]		&& Array of controls
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN hiddencontrols
	PROTECTED Init,MouseDown
	*<PropValue>
		Height = 4
		MousePointer = 7
		Name = "splitter2"
		rangemax = 0.8
		rangemin = 0.2
		SpecialEffect = 0
		Width = 100
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		
		* decrement instance counter, if 0 release object (this.release Dlls)
		*-------------------------------------------------------------------------------
		IF TYPE("_screen.___SplitterApi")="O" AND !ISNULL(_SCREEN.___SplitterApi)
		
		  _SCREEN.___SplitterApi.nInstances = _SCREEN.___SplitterApi.nInstances - 1
		
		  IF _SCREEN.___SplitterApi.nInstances <= 0
		
		    _SCREEN.___SplitterApi.nInstances = NULL
		
		    _SCREEN.REMOVEOBJECT("___SplitterApi")
		
		  ENDIF
		
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE hidecontrols		&& internal use
		
		* hide all controls include ActiveX with property visible inside container tObject
		* without this splitter and form
		*--------------------------------------------------------------------------------------------
		LPARAMETERS tObject,nIndex
		
		*	tObject is root object, if not passed, thisform is used
		*--------------------------------------------------------------------------------------------
		IF EMPTY(nIndex)
		
		  nIndex = 2
		  
		ENDIF
		
		LOCAL lcObjectBaseClass, lObject, lTempObject
		
		* build collection hidden object for reverse setting in showcontrols
		* set valid object
		*--------------------------------------------------------------------------------------------
		IF VARTYPE(tObject) = "O"
		
		  lObject = tObject
		
		ELSE
		
		  lObject = THISFORM
		
		ENDIF
		
		* ignore this splitter
		*--------------------------------------------------------------------------------------------
		IF lObject = THIS
		
		  RETURN nIndex
		
		ENDIF
		
		* unify
		*--------------------------------------------------------------------------------------------
		lcObjectBaseClass = LOWER(lObject.BASECLASS) + " " && " " for unique (page # pageframe)
		
		* do not hide form window
		*--------------------------------------------------------------------------------------------
		IF lcObjectBaseClass # "form " AND PEMSTATUS(lObject,"visible",5)
		
		  IF lObject.VISIBLE
		
		    DIMENSION THIS.HiddenControls[nIndex]
		
		    THIS.hiddencontrols[nIndex] = lObject
		
		    lObject.VISIBLE = .F.
		
		    nIndex = nIndex + 1
		
		  ENDIF
		
		ENDIF
		
		* recurse for all children
		*--------------------------------------------------------------------------------------------
		DO CASE
		
		  CASE INLIST(lcObjectBaseClass,"pageframe ")
		
		    FOR EACH lTempObject IN lObject.PAGES
		
		      nIndex=THIS.hidecontrols(lTempObject,nIndex)
		
		    ENDFOR
		
		  CASE INLIST(lcObjectBaseClass,"form ","container ","page ")
		
		    FOR EACH lTempObject IN lObject.CONTROLS
		
		      nIndex=THIS.hidecontrols(lTempObject,nIndex)
		
		    ENDFOR
		
		  CASE INLIST(lcObjectBaseClass,"commandgroup ","optiongroup ")
		
		    FOR EACH lTempObject IN lObject.BUTTONS
		
		      nIndex=THIS.hidecontrols(lTempObject,nIndex)
		
		    ENDFOR
		
		ENDCASE
		
		RETURN nIndex + 1
		
	ENDPROC

	PROTECTED PROCEDURE Init
		
		* API FUNCTIONS - declare only one for all splitter with this class
		*--------------------------------------------------------------------------------------------
		IF !VARTYPE(_SCREEN.___SplitterApi) = "O"
		
		  *!*	  IF AT(UPPER((THIS.CLASSLIBRARY)),UPPER(SET("Classlib")))=0
		
		  *!*	    SET CLASSLIB TO (THIS.CLASSLIBRARY) ADDITIVE
		
		  *!*	  ENDIF
		
		  *!*	  _SCREEN.ADDOBJECT("___SplitterApi","SplitterAPI")
		  
		  _SCREEN.NEWOBJECT("___SplitterApi","SplitterAPI", THIS.CLASSLIBRARY)
		
		ELSE
		
		  _SCREEN.___SplitterApi.nInstances = _SCREEN.___SplitterApi.nInstances + 1
		
		ENDIF
		
		RETURN VARTYPE(_SCREEN.___SplitterApi)="O"
		
	ENDPROC

	PROTECTED PROCEDURE MouseDown
		
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL lcWindowName,lnScaleMode,lnMinRow,lnMaxRow,lnMRow1,lnMRow2
		LOCAL lnRows,lnTop,lnOldTop,lnMin,oldMRow2
		LOCAL llLockScreen,lnMousePointer
		LOCAL lhDC,lhMemDC,lhMemBmp,lHWnd,lnBmpHeight,nLeftOffset,nTopOffset,oContainer,xHeight
		LOCAL lcOldFormName,lhMemSplit
		
		IF nButton # 1
		
		  RETURN
		
		ENDIF
		
		lcOldFormName = THISFORM.NAME
		
		THISFORM.NAME = SYS(2015)
		
		lcWindowName = THISFORM.NAME
		
		lnScaleMode = THISFORM.SCALEMODE
		
		THISFORM.SCALEMODE = 3  && pixels
		
		oContainer = THIS.PARENT
		
		nLeftOffset = OBJTOCLIENT(THIS,2) - THIS.LEFT
		
		nTopOffset = OBJTOCLIENT(THIS,1) - THIS.TOP
		
		lnMRow1 = MROW(lcWindowName,3)
		
		IF TYPE("lnMRow1") # "N" OR lnMRow1 <= 0
		
		  THISFORM.SCALEMODE = lnScaleMode
		
		  THISFORM.NAME = lcOldFormName
		
		  RETURN
		
		ENDIF
		
		lnMRow1 = lnMRow1 - nTopOffset
		
		IF lnMRow1 <> THIS.TOP + 1
		
		  lnMRow1 = THIS.TOP + 1
		
		  MOUSE AT lnMRow1 + nTopOffset, MCOL(lcWindowName,3) PIXELS WINDOW (lcWindowName)
		
		ENDIF
		
		* set some vars
		*--------------------------------------------------------------------------------------------
		llLockScreen = THISFORM.LOCKSCREEN
		
		lnMousePointer = THISFORM.MOUSEPOINTER
		
		THISFORM.MOUSEPOINTER = 7
		
		lnTop = THIS.TOP
		
		* check two parent level for Height- suppose that parent form always present
		*--------------------------------------------------------------------------------------------
		IF PEMSTATUS(oContainer,"Height",5)
		
		  xHeight	=	oContainer.HEIGHT
		
		ELSE
		
		  IF PEMSTATUS(oContainer.PARENT,"PageHeight",5)
		
		    xHeight	=	oContainer.PARENT.PAGEHEIGHT
		
		  ELSE
		
		    * if error that oContainer.Height and oContainer.parent.width not exist, something wrong
		    *--------------------------------------------------------------------------------------------
		    xHeight	=	oContainer.PARENT.HEIGHT
		
		  ENDIF
		
		ENDIF
		
		* RangeMin (RangeMax) < 1
		* 		RangeMin (RangeMax) are used as coeficient (%/100)
		* RangeMin (RangeMax) > 1
		*		RangeMin (RangeMax) are used as absolute offset in pixels
		* RangeMin (RangeMax) =0
		*		RangeMin (RangeMax) are ignored - no restriction
		
		DO CASE
		
		  CASE THIS.RangeMin <= 0
		
		    lnMinRow = THIS.HEIGHT * 2
		
		  CASE THIS.RangeMin > 1
		
		    lnMinRow = MAX(THIS.HEIGHT * 2, INT(THIS.RangeMin))
		
		  CASE THIS.RangeMin < 1
		
		    lnMinRow = MAX(THIS.HEIGHT * 2, INT(THIS.RangeMin * xHeight))
		
		ENDCASE
		
		DO CASE
		
		  CASE THIS.RangeMax <= 0
		
		    lnMaxRow = xHeight - (THIS.HEIGHT * 3)
		
		  CASE THIS.RangeMax > 1
		
		    lnMaxRow = MIN(xHeight - (THIS.HEIGHT * 3), THIS.RangeMax)
		
		  CASE THIS.RangeMax < 1
		
		    lnMaxRow = MIN(xHeight - (THIS.HEIGHT * 3), THIS.RangeMax * xHeight)
		
		ENDCASE
		
		IF lnMinRow > lnMaxRow
		
		  * nothing to move!!!
		  *-------------------------------
		  THISFORM.SCALEMODE = lnScaleMode
		  THISFORM.NAME = lcOldFormName
		
		  RETURN
		
		ENDIF
		
		lnMRow2 = lnMRow1
		oldMRow2 = lnMRow2
		
		#DEFINE SRCCOPY		13369376
		
		* API CALLS
		*---------------------------
		IF THISFORM.SHOWWINDOW = 2
		
		  * workaround, when showwindow=2 the handle is not the right one...
		  * worst if you have a toolbar!
		  *------------------------------------------------------------------
		  *#define GW_HWNDFIRST        0
		  #DEFINE GW_HWNDLAST         1
		  *#define GW_HWNDNEXT         2
		  *#define GW_HWNDPREV         3
		  *#define GW_OWNER            4
		  #DEFINE GW_CHILD            5
		
		  lHWnd = THISFORM.HWND
		  lHWnd = GS_SplitGetWindow(lHWnd,GW_CHILD)
		  lHWnd = GS_SplitGetWindow(lHWnd,GW_HWNDLAST)
		
		ELSE
		
		  lHWnd = THISFORM.HWND
		
		ENDIF
		
		lhDC = GS_SplitGetDC(lHWnd)
		
		lhMemDC = GS_SplitCreateCompatibleDC(lhDC)
		
		* Take a copy of the portion of the form that can be dragged over
		*------------------------------------------------------------------
		lnBmpHeight = THIS.HEIGHT
		
		lhMemBmp = GS_SplitCreateCompatibleBitmap(lhDC, THIS.WIDTH, lnBmpHeight)
		
		lhMemSplit = GS_SplitCreateCompatibleBitmap(lhDC, THIS.WIDTH, lnBmpHeight)
		
		= GS_SplitSelectObject(lhMemDC, lhMemBmp)
		
		= GS_SplitBitBlt(lhMemDC, 0, 0,  THIS.WIDTH, lnBmpHeight, ;
		  lhDC, THIS.LEFT + nLeftOffset, lnMRow1 - 1 + nTopOffset, SRCCOPY)
		
		= GS_SplitSelectObject(lhMemDC , lhMemSplit)
		
		= GS_SplitBitBlt(lhMemDC, 0, 0,  THIS.WIDTH, lnBmpHeight, ;
		  lhDC, THIS.LEFT + nLeftOffset, lnMRow1 - 1 + nTopOffset, SRCCOPY)
		
		* Stop fox drawing in the screen
		*---------------------------------
		THISFORM.LOCKSCREEN = .T.
		THIS.hidecontrols(oContainer)
		
		* update the display while dragging
		*------------------------------------
		DO WHILE MDOWN()
		
		  DOEVENTS
		
		  lnMRow2 = MROW(lcWindowName,3) - nTopOffset
		
		  IF TYPE("lnMRow2") # "N" OR lnMRow2 = 0
		
		    LOOP
		
		  ENDIF
		
		  IF lnMRow2 <= lnMinRow
		
		    *force the mouse to stay at this position
		    *------------------------------------------
		    MOUSE AT lnMinRow + nTopOffset, MCOL(lcWindowName,3) PIXELS WINDOW (lcWindowName)
		
		    lnMRow2 = lnMinRow + 1
		
		  ENDIF
		
		  IF lnMRow2 >= (lnMaxRow - THIS.HEIGHT)
		
		    *force the mouse to stay at this position
		    *--------------------------------------------------------------------------------------------
		    MOUSE AT lnMaxRow - THIS.HEIGHT + nTopOffset, MCOL(lcWindowName,3) PIXELS WINDOW (lcWindowName)
		
		    lnMRow2 = lnMaxRow - THIS.HEIGHT
		
		  ENDIF
		
		  lnMRow2 = MIN(MAX(lnMRow2, lnMinRow), lnMaxRow)
		
		  IF oldMRow2 = lnMRow2
		
		    LOOP
		
		  ELSE
		
		    * on mouse move, redraw a part of the screen from the memory copy
		    * and draw "this" image at the mouse position
		    * bitblt (dest...source...)
		    *-------------------------------------------------------------------
		    WITH THIS
		
		      .TOP = lnTop + (lnMRow2 - lnMRow1)
		
		      *restore
		      *--------------
		      = GS_SplitSelectObject(lhMemDC, lhMemBmp)
		
		      = GS_SplitBitBlt(lhDC, .LEFT+nLeftOffset, oldMRow2 - 1 + nTopOffset, .WIDTH, .HEIGHT+3,;
		        lhMemDC, 0, 0,  SRCCOPY)
		
		      *take a new copy
		      *-----------------
		      = GS_SplitBitBlt(lhMemDC, 0, 0,  THIS.WIDTH, lnBmpHeight, ;
		        lhDC, THIS.LEFT+nLeftOffset, lnMRow2 - 1 + nTopOffset, SRCCOPY)
		
		      *draw
		      *--------
		      = GS_SplitSelectObject(lhMemDC , lhMemSplit)
		
		      = GS_SplitBitBlt(lhDC, .LEFT+nLeftOffset, .TOP+nTopOffset, .WIDTH, .HEIGHT + 1,;
		        lhMemDC, 0, 0,  SRCCOPY)
		
		    ENDWITH
		
		    oldMRow2 = lnMRow2
		
		  ENDIF
		
		ENDDO
		
		THIS.showcontrols()
		
		THISFORM.NAME = lcOldFormName
		
		IF lnMRow2 < 0
		
		  lnMRow2 = lnMRow1
		
		ENDIF
		
		lnRows = lnMRow2 - lnMRow1
		
		THIS.TOP = lnTop + lnRows
		
		THISFORM.SCALEMODE = lnScaleMode
		
		THISFORM.MOUSEPOINTER = lnMousePointer
		
		THIS.SPLIT()
		
		THISFORM.LOCKSCREEN = llLockScreen
		
		* free the memory
		*----------------------------------
		= GS_SplitReleaseDC(lHWnd, lhDC)
		= GS_SplitDeleteObject(lhMemBmp)
		= GS_SplitDeleteObject(lhMemSplit)
		= GS_SplitDeleteDC(lhMemDC)
		
	ENDPROC

	HIDDEN PROCEDURE readme
		*!*	Splitter class
		*!*	May 2004
		
		*!*	Active-X controls always drive me nuts because they use there own windows handle.
		*!*	You cannot put a fox native control over them to resize the control visually.
		*!*	You have to use some tricks like changing the control to 
		*!*	another one for this operation and rechange it back after.
		*!*	( See the class browser code )
		
		*!*	What I want is a splitter that can handle this in a visual way 
		*!*	while keeping the form (look) unchanged until the end of the split.
		
		*!*	After many try and fail, I have finally found a way to do it
		*!*	by the use of API calls. IT WORK!!!
		*!* Days of work to end with only a couple of code lines :)
		
		*!*	I am not an API guru, so if you find a way to improve this class
		*!*	feel free to let me know how :)
		
		*!*	Tested with VFP 8-7 on Windows 2000 
		*!*	(no animal other than the usual fox was used in the tests)
		*!*	Disclaimer: (...) <- put the usual disclaimer here!
		
		*!*	Gérald Santerre
		*!*	gerald.santerre@siteintranet.qc.ca
		
		
		*!*		USAGE:
		
		*!*		Drop this class on a form or a container between the objects that share the container. 
		
		*!*	New release, complete redesing.
		*!*	If you already use a previous version of the class, read this carefully. 
		*!*	I have removed a couple of properties and change the way the classes work. 
		*!*	For this reason I have also renamed the classlib to avoid conflicts 
		*!*	with previous version of the class. The new design is cleaner and the control 
		*!*	don't touch anything in the form (except hiding controls during split). 
		
		*!*	A large part of the new design is from suggestions received 
		*!*	from "Jaromír Stacha" from Czech Republic. 
		*!*		Thank you Jaromir :). 
		
		*!*	The new splitter classes don't move or resize controls anymore. 
		*!*	The splitter.split() method is always called after a split operation 
		*!*	and you have to resize/reposition your controls from this (fake)event. 
		*!*	If you don't put code in the split() method, the form.resize() event 
		*!*	of the form will be called. See the resize() and splitter1.split() 
		*!*	method of the demo form for a working sample.
		
		*!*	You have only 2 properties to set in the class, 
		*!*	RangeMin and RangeMax. 
		*!*	If you set the value of this properties between 0 and 1, 
		*!*	the value is handled as a % of the splitter's parent container width ot height. 
		*!*	For example, if you enter 0.2 as value for RangeMin, 
		*!*	you will be able to move the splitter down to 20% of the width/height 
		*!*	of the splitter's parent container. 
		*!*	Values greater than 1 will be handle as absolute values. 
		*!*	Don't forget to reset absolute values when the splitter's parent container is resized.
		
		*!*	The splitter API is now self contained and you dont have 
		*!*	to worry about releasing the references to API functions. 
		*!*	The splitter now also handle correctly multiple instances 
		*!*	of the same form (or forms with the same name). 
		*!*	The splitter automatically hide every controls that are in 
		*!*	the same parent container (recursive) to avoid side effects 
		*!*	(like mouse cursor beam over text boxes).
		
		*!*	Contact: gerald.santerre@siteintranet.qc.ca
		
	ENDPROC

	HIDDEN PROCEDURE showcontrols		&& internal use
		
		* show temporary hidden objects and clear list (collection)
		*------------------------------------------------------------
		LPARAMETERS toRoot
		
		IF ALEN(THIS.hiddencontrols, 1) < 2
		
		  RETURN
		
		ENDIF
		
		FOR i = 2 TO ALEN(THIS.hiddencontrols, 1)
		
		  IF TYPE("THIS.hiddencontrols[i]") = "O"
		
		    THIS.hiddencontrols[i].VISIBLE = .T.
		
		  ENDIF
		
		ENDFOR
		
		DIMENSION THIS.hiddencontrols[1]
		
	ENDPROC

	PROCEDURE split		&& This method is called at the end of the split operation.
		
		* default behaviour
		*--------------------
		THISFORM.RESIZE()
	ENDPROC

ENDDEFINE

DEFINE CLASS splitterapi AS custom 		&& Splitter API declaration class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: declaredll
		*p: ninstances
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 15
		Name = "splitterapi"
		ninstances = 1
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="declaredll" type="method" display="DeclareDll"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE declaredll
		
		DECLARE LONG GetDC					IN Win32API AS GS_SplitGetDC LONG HWND
		
		DECLARE LONG CreateCompatibleDC		IN Win32API AS GS_SplitCreateCompatibleDC LONG hdc
		
		DECLARE LONG CreateCompatibleBitmap IN Win32API AS GS_SplitCreateCompatibleBitmap  LONG hdc, LONG nWidth, LONG nHeight
		
		DECLARE LONG SelectObject 			IN Win32API AS GS_SplitSelectObject  LONG hdc, LONG hObject
		
		DECLARE LONG ReleaseDC 				IN Win32API AS GS_SplitReleaseDC  LONG HWND, LONG hdc
		
		DECLARE LONG DeleteDC 				IN Win32API AS GS_SplitDeleteDC  LONG hdc
		
		DECLARE LONG BitBlt 				IN Win32API AS GS_SplitBitBlt  ;
		  LONG hDestDC, LONG x, LONG Y, LONG nWidth, LONG nHeight, ;
		  LONG hSrcDC, LONG xSrc, LONG ySrc, LONG dwRop
		
		DECLARE INTEGER DeleteObject 		IN Win32API AS GS_SplitDeleteObject  LONG hObject
		
		DECLARE INTEGER GetWindow 			IN user32 AS GS_SplitGetWindow  ;
		  INTEGER HWND,;
		  INTEGER wFlag
		
	ENDPROC

	PROCEDURE Destroy
		Clear Dlls	;
			"GS_SplitGetDC",;
			"GS_SplitCreateCompatibleDC",;
			"GS_SplitCreateCompatibleBitmap",;
			"GS_SplitSelectObject",;
			"GS_SplitReleaseDC",;
			"GS_SplitDeleteDC",;
			"GS_SplitBitBlt",;
			"GS_SplitGetWindow",;
			"GS_SplitDeleteObject"
	ENDPROC

	PROCEDURE Init
		
		THIS.DeclareDll()
	ENDPROC

ENDDEFINE
